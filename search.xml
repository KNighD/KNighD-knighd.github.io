<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【译】ReactHooks-并非黑魔法，本质是数组</title>
      <link href="/2020/07/26/%E3%80%90%E8%AF%91%E3%80%91ReactHooks-%E5%B9%B6%E9%9D%9E%E9%BB%91%E9%AD%94%E6%B3%95%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B0%E7%BB%84/"/>
      <url>/2020/07/26/%E3%80%90%E8%AF%91%E3%80%91ReactHooks-%E5%B9%B6%E9%9D%9E%E9%BB%91%E9%AD%94%E6%B3%95%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本文翻译自 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a>，该文章很好的阐释了 react hooks 原理，我将保持原文的意思进行翻译，如有自己感觉不清楚的地方将会在括号中注明。以下为翻译内容。</p><p>我是 hooks api 的忠实粉丝。然而 hooks 在使用时却有一些<a href="https://reactjs.org/docs/hooks-rules.html" target="_blank" rel="noopener">奇怪的约束</a>。在这里，我给尝试去理解这些规则由来的人提供一个了模型，用于思考如何去使用这些新 api。</p><a id="more"></a><h4 id="hooks-的规则"><a href="#hooks-的规则" class="headerlink" title="hooks 的规则"></a>hooks 的规则</h4><p>在 <a href="https://reactjs.org/docs/hooks-rules.html" target="_blank" rel="noopener">hooks proposal documentation</a>  的提纲中，React 核心团队规定了两条开发者在使用 hooks 时需要遵守的主要规则：</p><ul><li>不要在循环，条件或者是嵌套函数中使用 hooks</li><li>只能在 React Functions 中才能使用 hooks</li></ul><p>后者我认为是显而易见的。要将行为附加到函数式组件上，你需要能够以某种方式将该行为与组件关联起来。（原文为： To attach behaviour to a functional component you need to be able to associate that behaviour with the component somehow. 不太理解作者想表达的意思）</p><p>前者我认为会比较让人困惑，因为像这样使用 api 可能看起来不太自然。而这正是我今天想要探讨的内容。</p><h4 id="hooks-的状态管理都是基于数组"><a href="#hooks-的状态管理都是基于数组" class="headerlink" title="hooks 的状态管理都是基于数组"></a>hooks 的状态管理都是基于数组</h4><p>为了更清晰地理解心智模型，让我们来看一下如何实现一个简单的 hooks api。</p><p><strong>注意这只是 API 的一种可能的实现方式及猜想，用于让你理解，而非 API 真正的内部实现方式</strong></p><h4 id="我们如何实现-useState"><a href="#我们如何实现-useState" class="headerlink" title="我们如何实现 useState?"></a>我们如何实现 <code>useState</code>?</h4><p>让我们打开一个实例来演示如何实现一个 state hook。</p><p>首先，我们定义一个组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs react">function RenderFunctionComponent() &#123;<br>  const [firstName, setFirstName] &#x3D; useState(&quot;Rudi&quot;);<br>  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;);<br><br>  return (<br>    &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 Hooks api 背后的思想是，你可以用 hook 函数返回的数组的第二个元素作为 setter 方法，这个 setter 方法可以控制被 hook 管理的状态。</p><h4 id="那么-React-是如何做到这个的呢？"><a href="#那么-React-是如何做到这个的呢？" class="headerlink" title="那么 React 是如何做到这个的呢？"></a>那么 React 是如何做到这个的呢？</h4><p>让我们看看这个在 React 内部是如何运作的。以下内容将在特定组件的上下文中运行。这就是说数据存储在要渲染的组件的上一层。这个 state 不与其他组件共享，但是维护在一个可以用于该组件后续渲染的作用域内。（原文：The following would work within the execution context for rendering a particular component. That means that the data stored here lives one level outside of the component being rendered. This state is not shared with other components but it is maintained in a scope that is accessible to subsequent rendering of the specific component）</p><ol><li><p>初始化</p><p>创建两个空数组：<code>setter</code> 和 <code>state</code></p><p>将指针设置为 0</p><p><img src="https://miro.medium.com/max/1280/1*LAZDuAEm7nbcx0vWVKJJ2w.png" alt="Image for post"></p></li></ol><ol start="2"><li><p>首次渲染</p><p>首次运行该组件。</p><p>每次调用 <code>useState</code> ，如果是首次运行，则 push 一个 setter 方法（绑定到指针的位置）到 setters 数组中，并且 push 一些 state 到 state 数组中。</p><p><img src="https://miro.medium.com/max/1260/1*8TpWnrL-Jqh7PymLWKXbWg.png" alt="Image for post"></p></li><li><p>后续渲染</p><p>每次后续渲染，指针将被重置，然后从各个数组中读取对应的值。</p><p><img src="https://miro.medium.com/max/1254/1*qtwvPWj-K3PkLQ6SzE2u8w.png" alt="Image for post"></p></li><li><p>事件处理</p><p>每一个 setter 都保存一个对应的指针位置的引用，因此触发任意一个 <code>setter</code> 都可以修改 state 数组中对应指针位置的 state。</p><p><img src="https://miro.medium.com/max/1260/1*3L8YJnn5eV5ev1FuN6rKSQ.png" alt="Image for post"></p></li></ol><h4 id="简单的实现-And-the-naive-implementation"><a href="#简单的实现-And-the-naive-implementation" class="headerlink" title="简单的实现(And the naive implementation)"></a>简单的实现(And the naive implementation)</h4><p>下面是简单的代码演示：</p><p><strong>注意：这不代表 hooks 的实际实现，但是应该能给你一个理解 hooks 工作原理的思路。这就是我为什么使用块级变量的原因（原文： That is why we are using module level vars etc）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs react">let state &#x3D; [];<br>let setters &#x3D; [];<br>let firstRun &#x3D; true;<br>let cursor &#x3D; 0;<br><br>function createSetter(cursor) &#123;<br>  return function setterWithCursor(newVal) &#123;<br>    state[cursor] &#x3D; newVal;<br>  &#125;;<br>&#125;<br><br>&#x2F;&#x2F; This is the pseudocode for the useState helper<br>export function useState(initVal) &#123;<br>  if (firstRun) &#123;<br>    state.push(initVal);<br>    setters.push(createSetter(cursor));<br>    firstRun &#x3D; false;<br>  &#125;<br><br>  const setter &#x3D; setters[cursor];<br>  const value &#x3D; state[cursor];<br><br>  cursor++;<br>  return [value, setter];<br>&#125;<br><br>&#x2F;&#x2F; Our component code that uses hooks<br>function RenderFunctionComponent() &#123;<br>  const [firstName, setFirstName] &#x3D; useState(&quot;Rudi&quot;); &#x2F;&#x2F; cursor: 0<br>  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;); &#x2F;&#x2F; cursor: 1<br><br>  return (<br>    &lt;div&gt;<br>      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Richard&quot;)&#125;&gt;Richard&lt;&#x2F;Button&gt;<br>      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;<br>    &lt;&#x2F;div&gt;<br>  );<br>&#125;<br><br>&#x2F;&#x2F; This is sort of simulating Reacts rendering cycle<br>function MyComponent() &#123;<br>  cursor &#x3D; 0; &#x2F;&#x2F; resetting the cursor<br>  return &lt;RenderFunctionComponent &#x2F;&gt;; &#x2F;&#x2F; render<br>&#125;<br><br>console.log(state); &#x2F;&#x2F; Pre-render: []<br>MyComponent();<br>console.log(state); &#x2F;&#x2F; First-render: [&#39;Rudi&#39;, &#39;Yardley&#39;]<br>MyComponent();<br>console.log(state); &#x2F;&#x2F; Subsequent-render: [&#39;Rudi&#39;, &#39;Yardley&#39;]<br><br>&#x2F;&#x2F; click the &#39;Fred&#39; button<br><br>console.log(state); &#x2F;&#x2F; After-click: [&#39;Fred&#39;, &#39;Yardley&#39;]<br></code></pre></td></tr></table></figure><h4 id="为什么顺序很重要？"><a href="#为什么顺序很重要？" class="headerlink" title="为什么顺序很重要？"></a>为什么顺序很重要？</h4><p>现在如果在一个生命周期里，我们基于外部的因素或者组件状态改变了 hooks 的顺序，将会发生什么事情？</p><p>让我们试试看 react 不建议我们做的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs react">let firstRender &#x3D; true;<br><br>function RenderFunctionComponent() &#123;<br>  let initName;<br>  <br>  if(firstRender)&#123;<br>    [initName] &#x3D; useState(&quot;Rudi&quot;);<br>    firstRender &#x3D; false;<br>  &#125;<br>  const [firstName, setFirstName] &#x3D; useState(initName);<br>  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;);<br><br>  return (<br>    &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在一个条件语句中使用了 <code>useState</code>，让我们看看造成了什么样的破坏：</p><h4 id="坏组件的第一次渲染"><a href="#坏组件的第一次渲染" class="headerlink" title="坏组件的第一次渲染"></a>坏组件的第一次渲染</h4><p><img src="https://miro.medium.com/max/1270/1*C4IA_Y7v6eoptZTBspRszQ.png" alt="Image for post"></p><p>在这个时候，我们的实例变量 <code>firstName</code> 和 <code>lastName</code> 指向的正确的数据，但是我们看看第二次渲染发生了什么：</p><h4 id="坏组件的第二次渲染"><a href="#坏组件的第二次渲染" class="headerlink" title="坏组件的第二次渲染"></a>坏组件的第二次渲染</h4><p><img src="https://miro.medium.com/max/1274/1*aK7jIm6oOeHJqgWnNXt8Ig.png" alt="Image for post"></p><p>现在我们的 state 存储出现异常， <code>firstName</code> 和 <code>lastName</code> 都指向 “Rudi”。上述明显错误的操作给了我们一个思路：为什么 hooks 要如此规定。</p><blockquote><p>The React team are stipulating the usage rules because not following them will lead to inconsistent data</p></blockquote><h4 id="想想-hooks-操作一系列的数组，那么你就不会打破规则了（Think-about-hooks-manipulating-a-set-of-arrays-and-you-wont-break-the-rules）"><a href="#想想-hooks-操作一系列的数组，那么你就不会打破规则了（Think-about-hooks-manipulating-a-set-of-arrays-and-you-wont-break-the-rules）" class="headerlink" title="想想 hooks 操作一系列的数组，那么你就不会打破规则了（Think about hooks manipulating a set of arrays and you wont break the rules）"></a>想想 hooks 操作一系列的数组，那么你就不会打破规则了（Think about hooks manipulating a set of arrays and you wont break the rules）</h4><p>现在应该能很清晰理解为什么不能在条件或者循环语句中使用 <code>use</code> hook 了：因为我们使用了指针指向了数组，如果在 render 的时候改变了顺序，那么指针就不能对应正确的数据，所以调用 use 也不会指向正确的数据和 setter。</p><p>因此，诀窍就是将 hooks 想像成用恒定的指针来管理一系列数组。如果能做到这个，那么一切就能按预期进行。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>希望我已经就如何思考 hooks api 的工作原理指出了一个清晰的心智模型。（后面就偷个懒不翻译了，基本是上述观点的重复强调。）</p><p>Hopefully I have laid out a clearer mental model for how to think about what is going on under the hood with the new hooks API. Remember the true value here is being able to group concerns together so being careful about order and using the hooks API will have a high payoff.</p><p>Hooks is an effective plugin API for React Components. There is a reason why people are excited about this and if you think about this kind of model where state exists as a set of arrays then you should not find yourselves breaking the rules around their usage.</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端入坑flutter</title>
      <link href="/2020/07/24/%E5%89%8D%E7%AB%AF%E5%85%A5%E5%9D%91flutter/"/>
      <url>/2020/07/24/%E5%89%8D%E7%AB%AF%E5%85%A5%E5%9D%91flutter/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>踩过 RN 的坑之后越发想尝试学习下 flutter 的开发，本文用于记录下开发过程中的问题与思考，本来是写在 notion 里的，最近 notion 无法打开，故记录于此。</p><a id="more"></a><h4 id="Flutter为什么选择了-Dart而不是-JavaScript"><a href="#Flutter为什么选择了-Dart而不是-JavaScript" class="headerlink" title="Flutter为什么选择了 Dart而不是 JavaScript"></a>Flutter为什么选择了 Dart而不是 JavaScript</h4><p>首先要了解两个概念：JIT和AOT。<br>目前，程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为<strong>AOT</strong> （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为<strong>JIT</strong>（Just-in-time）即“即时编译”。AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。在此，读者不必纠结于概念，概念就是为了传达精神而发明的，只要读者能够理解其原理即可，得其神忘其形。<br>JavaScript为脚本语言，执行时需要JIT(Just In Time)，执行效率和AOT(Ahead Of Time)代码仍有差距。<br>Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。<br>但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。</p><h4 id="网页开发"><a href="#网页开发" class="headerlink" title="网页开发"></a>网页开发</h4><p>现在 flutter 已经支持 web 了，切换到 beta ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 启动开发模式<br>flutter run -d chrome<br></code></pre></td></tr></table></figure><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><p>过程不提，文档讲的比较清晰了，注意配置国内的源即可。</p><h4 id="项目结构与命名规范"><a href="#项目结构与命名规范" class="headerlink" title="项目结构与命名规范"></a>项目结构与命名规范</h4><p>dart 的文件名是用下划线连接的，源文件在 lib 目录下，main.dart 为入口文件, 从 main 函数开始执行，下划线开头的变量为私有变量</p><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>dart 里如何导入本地文件的呢？和引用第三方的库的用法一样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:&#123;项目名&#125;/&#123;文件名&#125;'</span>;<br></code></pre></td></tr></table></figure><p>其中成员变量自动导出，那么如何防止命名冲突？:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:&#123;项目名&#125;/&#123;文件名&#125;'</span> <span class="hljs-keyword">as</span> MyModule;<br></code></pre></td></tr></table></figure><p>通过 as 来指定包名，此时要使用内部成员就需要 MyModule.xxx。</p><p>也可以屏蔽某些变量导出：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:&#123;项目名&#125;/&#123;文件名&#125;'</span> <span class="hljs-keyword">hide</span> MyVar;<br></code></pre></td></tr></table></figure><h4 id="💀-Divider-在-web-需要传-thickness"><a href="#💀-Divider-在-web-需要传-thickness" class="headerlink" title="💀 Divider 在 web 需要传 thickness"></a>💀 Divider 在 web 需要传 thickness</h4><p>否则不渲染， issue 如下： <a href="https://github.com/flutter/flutter/issues/46339" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/46339</a></p><h4 id="💀-BottomNavigationBar"><a href="#💀-BottomNavigationBar" class="headerlink" title="💀 BottomNavigationBar"></a>💀 BottomNavigationBar</h4><p>如果超过 3 个 items，背景会变白，原因是超过 3 个 BottomNavigationBar 的 type 会变成 BottomNavigationBarType.shifting 类型，详情见 <a href="https://github.com/flutter/flutter/issues/13642#issuecomment-371875044，解决的办法是设置" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/13642#issuecomment-371875044，解决的办法是设置</a> type 属性为 fixed。</p><h4 id="进程锁死"><a href="#进程锁死" class="headerlink" title="进程锁死"></a>进程锁死</h4><p>遇到控制台提示，Waiting for another flutter command to release the startup lock… 可以简单粗暴杀进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">killall -9 dart<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见的安全问题汇总</title>
      <link href="/2020/07/23/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/23/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近安全部门的小伙伴提了一个前端安全的漏洞，想到前端开发过程中有时候往往追求开发效率，忽略掉一些安全问题，以下简单总结一些自己遇到过的以及一些常见的攻击手段，以自查自省。</p><a id="more"></a><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>回到安全部门提出的漏洞，场景还原如下：<br>这是一个老项目，展示文章用，页面路由为 <a href="http://xxx/article/:id?these-are-queries，node" target="_blank" rel="noopener">http://xxx/article/:id?these-are-queries，node</a> 层收到这个 url 后，返回返回该文章 html，内容则包括了【推荐文章】， 而推荐文章的链接则是根据 url 的值来的，仅变化 id。此时如果在 url 上的 query 上构造一段恶意脚本，然后引导用户打开，那么用户打开页面后就会运行该恶意脚本。<br>上述正是一个典型的 XSS 攻击，定义如下：</p><blockquote><p>XSS是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p></blockquote><p>XSS 的本质是信任了某些不安全的输入，导致恶意代码混入正常代码，进而发生的攻击行为。常见的不安全输入有：</p><ol><li>上面提到的 url 参数，这种需要诱导用户取点击</li><li>用户输入的内容，比如用户发表评论</li><li>第三方的链接等</li></ol><p>防范的方法通常是：对用户输入内容和服务端返回内容进行过滤和转译。</p><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>CSRF 攻击常见的过程如下：</p><ol><li>用户登录你的网站，产生登录凭证，如 cookie</li><li>用户被<strong>诱导</strong>登录到恶意网站</li><li>恶意网站携带刚刚在浏览器产生的凭证向你的服务器发送一个恶意请求</li><li>你的服务器无法识别是否恶意请求，请求完成，用户受害。</li></ol><p>与上面提到的 XSS 攻击有个明显的区别在于：CSRF 攻击发生在恶意网站，而不是被攻击的网站。而这也使得攻击者并不能获取到受害者的登录凭证，仅仅只能使用。<br>防范的方法通常是：</p><ol><li>请求 url 添加 token 或者是在 http 请求头自定义属性进行验证</li><li>同源检测，通过解析 请求头中的 referer 判断请求来源</li><li>Samesite，Google 起草了一份草案来改进 HTTP 协议，为 Set-Cookie 响应头新增 Samesite 属性，用于标明 Cookie 是否能作用于其他网站，目前兼容性还不是很好。</li></ol><h4 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h4><p>当我们使用 iframe 加载第三方网站时，第三方网站可以对我们的网站执行恶意操作，如操作DOM，加载 js 等。<br>防范的方法是通过设置 sandbox 属性控制 iframe 的操作权限。</p><h4 id="opener"><a href="#opener" class="headerlink" title="opener"></a>opener</h4><p>我们在通常通过以下写法在 新 tab 下打开链接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> &lt;a target=<span class="hljs-string">'_blank'</span> href=<span class="hljs-string">'new-site.com'</span>&gt;<br><span class="hljs-number">2.</span> <span class="hljs-built_in">window</span>.open(<span class="hljs-string">'new-site.com'</span>)<br></code></pre></td></tr></table></figure><p>上述两种写法的问题在于， <code>new-site.com</code> 是可以通过 <code>window.opener</code> 来拿到源页面的 <code>window</code> 对象，进而进行恶意操作。<br>防范的方法通常是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> &lt;a target=<span class="hljs-string">"_blank"</span> href=<span class="hljs-string">"new-site.com"</span> rel=<span class="hljs-string">"noopener noreferrer nofollow"</span>&gt;a标签跳转url&lt;<span class="hljs-regexp">/a&gt;</span><br><span class="hljs-regexp">2. function openurl(url) &#123;</span><br><span class="hljs-regexp">    var newTab = window.open();</span><br><span class="hljs-regexp">    newTab.opener = null;</span><br><span class="hljs-regexp">    newTab.location = url;</span><br><span class="hljs-regexp">&#125;</span><br></code></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul><li><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener">前端安全系列（一）：如何防止XSS攻击？</a></p></li><li><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener">前端安全系列（二）：如何防止CSRF攻击？</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN 避坑指北</title>
      <link href="/2020/07/21/RN%20%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97/"/>
      <url>/2020/07/21/RN%20%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p>记录平时开发 rn 时遇到的问题，特指 0.59 版本，不同版本可能情况不同，仅供参考。</p><a id="more"></a><h5 id="一像素问题"><a href="#一像素问题" class="headerlink" title="一像素问题"></a>一像素问题</h5><p>rn 解决一像素很简单，只需要  <code>StyleSheet.hairlineWidth</code> 即可解决。</p><h5 id="TextInput-组件"><a href="#TextInput-组件" class="headerlink" title="TextInput  组件"></a>TextInput  组件</h5><p>自带内边距，多行文字时文字居中展示，想要消除需要设置样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">// 文字向上对齐<br>textAlignVertical: 'top'<br>// 消除内边距<br><span class="hljs-selector-tag">padding</span>: 0<br></code></pre></td></tr></table></figure><p>Placeholder 在 ios 和 android 下默认颜色表现不一致，可以通过 <code>placeholderTextColor</code>  属性进行设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">placeholderTextColor=<span class="hljs-string">"#CCCCCC"</span><br></code></pre></td></tr></table></figure><h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><p>因为设计理念的问题，android 下几乎无法实现和 ios 一致的阴影效果。而 flutter 基于 skia 引擎渲染，应该会有比较好的表现？有空尝试下。 🤔</p><h5 id="border-虚线"><a href="#border-虚线" class="headerlink" title="border 虚线"></a>border 虚线</h5><p>border 虚线也是一个比较棘手的问题, android 上实测无效，详情看 <a href="https://github.com/facebook/react-native/issues/17251" target="_blank" rel="noopener">issue</a>。解决方案是循环一个 pattern 然后 overhidden 掉，又多了一个让我想尝试 flutter 的理由 😂</p><h5 id="多行文字"><a href="#多行文字" class="headerlink" title="多行文字"></a>多行文字</h5><p>多行文字在 android 机型下有可能会出现高度不够导致文字被截掉的问题，解决方法：设置  <code>lineHeight</code></p><h5 id="实现不同字号的文字底部对齐"><a href="#实现不同字号的文字底部对齐" class="headerlink" title="实现不同字号的文字底部对齐"></a>实现不同字号的文字底部对齐</h5><p>例如 ¥500 想要 ¥ 字号小一点，而 500 字号大一点，但是需要底部对齐，则可以用 Text 包裹起来，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;Text&gt;<br>  &lt;Text style&#x3D;&#123;&#123; fontSize: 12 &#125;&#125;&gt;¥&lt;&#x2F;Text&gt;<br>  &lt;Text style&#x3D;&#123;&#123; fontSize: 20 &#125;&#125;&gt;500&lt;&#x2F;Text&gt;<br>&lt;&#x2F;Text&gt;<br></code></pre></td></tr></table></figure><h5 id="Text-组件样式继承"><a href="#Text-组件样式继承" class="headerlink" title="Text 组件样式继承"></a>Text 组件样式继承</h5><p>众所周知，css 如果想设置默认的全局样式相当简单，比如字体颜色默认为 ‘#323232’ , 只要在 body 上设置一下 <code>color: #323232</code> 即可 ，然而对于 RN 来说则有两种解决方案：</p><ol><li><p>将原生 Text 替换成自定义 Text 组件（官方推荐）</p><blockquote><p>The recommended way to use consistent fonts and sizes across your application is to create a component <code>MyAppText</code> that includes them and use this component across your app</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs react">import React from &#39;react&#39;;<br>import &#123; TextProps, StyleSheet, Text &#125; from &#39;react-native&#39;;<br><br>const styles &#x3D; StyleSheet.create(&#123;<br>  defaultStyle: &#123;<br>    color: &#39;#323232&#39;,<br>  &#125;,<br>&#125;);<br><br>export default function CustomText(props: TextProps &amp; &#123; children?: any &#125;) &#123;<br>  const &#123; style, ...restProps &#125; &#x3D; props;<br>  return (<br>    &lt;Text style&#x3D;&#123;[styles.defaultStyle, style]&#125; &#123;...restProps&#125;&gt;<br>      &#123;props.children&#125;<br>    &lt;&#x2F;Text&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>参考 <a href="https://github.com/Ajackster" target="_blank" rel="noopener">Ajackster</a>/<strong><a href="https://github.com/Ajackster/react-native-global-props" target="_blank" rel="noopener">react-native-global-props</a></strong> 的实现，在项目入口位置，修改组件的 render 方法。</p></li></ol><p>方案二虽然方便，但不是官方解法，万一有坑就 GG 了。而方案一如果是已有项目，则需要批量修改代码。<br>这里顺便提一下在 vscode 里批量替换的方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// 将正则，大小写，全匹配 三个按钮点亮<br>find: Text(,|\s)(.*react-nativ<span class="hljs-string">e';)</span><br><span class="hljs-string">replace: $2\nimport Text from '</span>Your/<span class="hljs-type">Text</span><span class="hljs-string">';</span><br></code></pre></td></tr></table></figure><p>一开始我是这么写的，只考虑到了单行，结果下面这种情况没有替换掉：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">import &#123;<br><span class="hljs-built_in">  StyleSheet,</span><br><span class="hljs-built_in">  ViewStyle,</span><br><span class="hljs-built_in">  View,</span><br><span class="hljs-built_in">  Text,</span><br><span class="hljs-built_in">  Image,</span><br><span class="hljs-built_in">  TouchableOpacity,</span><br>&#125; from 'react-native'<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>后面换成 <code>\sText[,|\s]\n?([\s\S]*&#39;react-native&#39;;)</code> 在浏览器里可以匹配上，但是 vscode 无法匹配 🤔。 最后简单写个脚本补全上面的漏网之鱼:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<br><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<br><span class="hljs-keyword">const</span> glob = <span class="hljs-built_in">require</span>(<span class="hljs-string">'glob'</span>);<br><br><span class="hljs-keyword">const</span> replace = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    glob(<span class="hljs-string">'src/**/*.tsx'</span>, &#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">er, files</span>) </span>&#123;<br>      <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\sText[,|\s]\n?([\s\S]*'react-native';)/</span>;<br>      files.forEach(<span class="hljs-keyword">async</span> (file) =&gt; &#123;<br>        <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> util.promisify(fs.readFile)(file, <span class="hljs-string">'utf8'</span>);<br>        <span class="hljs-keyword">const</span> newContent = content.replace(reg, (m, p1) =&gt; &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-string">` <span class="hljs-subst">$&#123;p1.trim()&#125;</span></span><br><span class="hljs-string">import Text from '@/components/Text';`</span>;<br>        &#125;);<br>        <span class="hljs-keyword">await</span> util.promisify(fs.writeFile)(file, newContent, <span class="hljs-string">'utf8'</span>);<br>      &#125;);<br>    &#125;);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.log(error);<br>  &#125;<br>&#125;;<br><br>replace();<br></code></pre></td></tr></table></figure><p>🤔 上面 CustomText 的写法有一个问题，即嵌套 Text 的样式如果是自定义组件中默认的样式，将不会被继承:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;Text style&#x3D;&#123;&#123; color: &#39;red&#39; &#125;&#125;&gt;<br>  &lt;Text&gt;red&lt;&#x2F;Text&gt;<br>  &lt;Text&gt;red&lt;&#x2F;Text&gt;<br>&lt;&#x2F;Text&gt;<br><br>&lt;CustomText style&#x3D;&#123;&#123; color: &#39;red&#39; &#125;&#125;&gt;<br>  &lt;CustomText&gt;not red&lt;&#x2F;Text&gt;<br>  &lt;CustomText&gt;not red&lt;&#x2F;Text&gt;<br>&lt;&#x2F;CustomText&gt;<br></code></pre></td></tr></table></figure><p>改良版： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs react">import React, &#123; Children, isValidElement, cloneElement &#125; from &#39;react&#39;;<br>import &#123; TextProps, StyleSheet, Text &#125; from &#39;react-native&#39;;<br><br>const styles &#x3D; StyleSheet.create(&#123;<br>  defaultStyle: &#123;<br>    color: &#39;#323232&#39;,<br>  &#125;,<br>&#125;);<br><br>export default function CustomText(<br>  props: TextProps &amp; &#123; children?: any; useDefaultStyle?: boolean &#125;,<br>) &#123;<br>  const &#123; style, useDefaultStyle &#x3D; true, ...restProps &#125; &#x3D; props;<br>  const newStyle &#x3D; useDefaultStyle ? [styles.defaultStyle, style] : style;<br><br>  const childrenWithProps &#x3D; Children.map(props.children, (child) &#x3D;&gt; &#123; <br>   if (isValidElement(child)) &#123;<br>     &#x2F;&#x2F; 如果子元素是个组件，则子组件不使用默认 style<br>      return cloneElement(child as React.ReactElement&lt;any&gt;, &#123;<br>        useDefaultStyle: false,<br>      &#125;);<br>    &#125;<br>    return child;<br>  &#125;);<br><br>  return (<br>    &lt;Text style&#x3D;&#123;newStyle&#125; &#123;...restProps&#125;&gt;<br>      &#123;childrenWithProps&#125;<br>    &lt;&#x2F;Text&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view" target="_blank" rel="noopener">react-native-scrollable-tab-view</a></p><p><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view" target="_blank" rel="noopener">react-native-scrollable-tab-view</a> 组件作为 ScrollView 的子组件时不可用，会出现 tab 选中不一致，tab content 无法撑开的现象，详情看：<a href="https://github.com/ptomasroos/react-native-scrollable-tab-view/issues/982" target="_blank" rel="noopener">https://github.com/ptomasroos/react-native-scrollable-tab-view/issues/982</a></p></li></ul><p>未完待续～</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次搭建 react 项目遇到的坑</title>
      <link href="/2020/07/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%20react%20%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2020/07/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%20react%20%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>电商项目需要搭建一个 h5 项目。这里简单记录一下搭建过程遇到的坑，作为总结。</p><a id="more"></a><p>ui 框架：为了统一 ui 框架，因此选择使用 antd-mobile。<br>打包：parceljs 在此前的项目中已经使用过很多次了，打包速度较 cra 快，且配置简单，因此拟用 parcel。<br>ts：多人项目还是上 ts，没什么好说的。<br>很快就搭建好 demo，接着就开始遇到一些问题。</p><h5 id="antd-mobile-按需加载"><a href="#antd-mobile-按需加载" class="headerlink" title="antd-mobile 按需加载"></a>antd-mobile 按需加载</h5><p>antd-mobile 按需加载推荐使用 <a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// .babelrc or babel-loader option</span><br>&#123;<br>  <span class="hljs-attr">"plugins"</span>: [<br>    [<span class="hljs-string">"import"</span>, &#123; <span class="hljs-attr">"libraryName"</span>: <span class="hljs-string">"antd-mobile"</span>, <span class="hljs-attr">"style"</span>: <span class="hljs-string">"css"</span> &#125;] <span class="hljs-comment">// `style: true` 会加载 less 文件</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>此前 parcel 实际上内置支持了 ts，直接转成 es5 了，因此此前没有额外再配置 babel。<br>🤔 babel-plugin-import 只支持 es6 module 写法的代码，看来需要先把 ts 转成 es6 然后在通过 babel 转成 es5， 没问题，安排～ 于是：</p><ol><li><p>新增 .babelrc</p></li><li><p>修改 tsconfig 的 module 为 <code>es6</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"compilerOptions"</span>: &#123;<br>    <span class="hljs-attr">"module"</span>: <span class="hljs-string">"ES6"</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>项目启动，没问题。但是 vscode 开始报错：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx">import React from &#39;react&#39;<br>&#x2F;&#x2F; Module &#39;&quot;&#x2F;node_modules&#x2F;@types&#x2F;react&#x2F;index&quot;&#39; can only be default-imported using the &#39;allowSyntheticDefaultImports&#39; flag<br></code></pre></td></tr></table></figure><p>根本原因是由于 react 导出如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react.development.js'</span>)<br></code></pre></td></tr></table></figure><p>而非</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports.default = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react.development.js'</span>)<br></code></pre></td></tr></table></figure><p>Babel 会在 commonjs 格式添加 default 导出，那我们要做的就是让 ts 不要提示这种类型的报错：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"compilerOptions"</span>: &#123;<br>    <span class="hljs-attr">"allowSyntheticDefaultImports"</span>: <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🤔 不过为什么一开始 parcel 不会报错呢？</p><p>接下来路由动态引入组件开始报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tsx">import React, &#123; Suspense, lazy &#125; from &#39;react&#39;<br><br>const List &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;modules&#x2F;List&#39;))<br>&#x2F;&#x2F; Dynamic imports are only supported when the &#39;--module&#39; flag is set to &#39;es2020&#39;, &#39;esnext&#39;, &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, or &#39;umd&#39;.<br></code></pre></td></tr></table></figure><p>看来 <code>es6</code> 是不支持 import() 语法, 那好办，将 module 改成 <code>esnext</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">"compilerOptions"</span>: &#123;<br>    <span class="hljs-attr">"module"</span>: <span class="hljs-string">"ESNext"</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来引入 anti-mobile 组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; List &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'antd-mobile'</span><br><span class="hljs-comment">// Cannot find module 'antd-mobile' or its corresponding type declarations.</span><br></code></pre></td></tr></table></figure><p>此时提示找不到对应的模块声明， 此时我的内心是崩溃的，看起来应该是模块解析路径不对，因此在 tsconfig 中显式配置 <code>moduleResolution</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"compilerOptions"</span>: &#123;<br>    <span class="hljs-attr">"moduleResolution"</span>: <span class="hljs-string">"Node"</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不再报错了，看看 ts 文档的解释吧，ts 共有两种可用的模块解析策略：<a href="https://www.tslang.cn/docs/handbook/module-resolution.html#node" target="_blank" rel="noopener">Node</a>和<a href="https://www.tslang.cn/docs/handbook/module-resolution.html#classic" target="_blank" rel="noopener">Classic</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span> === <span class="hljs-string">"AMD"</span> or <span class="hljs-string">"System"</span> or <span class="hljs-string">"ES6"</span> ? <span class="hljs-string">"Classic"</span> : <span class="hljs-string">"Node"</span><br></code></pre></td></tr></table></figure><p>🤔 按理说 module 为 esnext 的话岂不是应该按 node 策略解析？但是目前看来似乎不是这样的？</p><h5 id="配置-antd-mobile-主题"><a href="#配置-antd-mobile-主题" class="headerlink" title="配置 antd-mobile 主题"></a>配置 antd-mobile 主题</h5><p>接下来需要配置主题，anti-mobile 推荐使用 <a href="http://lesscss.org/usage/#using-less-in-the-browser-modify-variables" target="_blank" rel="noopener">modifyVars</a> 来配置主题。<br>将 .babelrc 改成做一下调整：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    ...<br>    <span class="hljs-string">"plugins"</span>: [<br>        [<span class="hljs-string">"import"</span>, &#123;<span class="hljs-string">"libraryName"</span>: <span class="hljs-string">"antd-mobile"</span>, <span class="hljs-string">"style"</span>: <span class="hljs-literal">true</span>&#125;],<br>        ...<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>按照 webpack 的经验，此时需要开启 <code>javascriptEnabled: true</code>问题来了 parcel 内置支持 less ，那我们要在哪里去配置 less 呢？根据 <a href="https://github.com/parcel-bundler/parcel/issues/907" target="_blank" rel="noopener">issue</a> 提到可以用 .lessrc 文件来配置，但是我经过尝试发现其实是无效的。。<br>至此基本放弃 parcel。parcel 在快速搭建实验性项目时确实有一定的优势，不过生态确实不如 webpack，由此转向使用 create-react-app</p><h5 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h5><p>使用 cra 很快也建好 demo，解决如何让 cra 创建的项目支持 less ，这个简单：<br>通过 <code>customize-cra</code> 提供的 <code>addLessLoader</code> 方法即可，同时也提供了 <code>fixBabelImports</code> 可以很方便的添加 babel-plugin-import 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; override, fixBabelImports, addLessLoader &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'customize-cra'</span>)<br><br><span class="hljs-built_in">module</span>.exports = override(<br>  fixBabelImports(<span class="hljs-string">'import'</span>, &#123;<br>    libraryName: <span class="hljs-string">'antd-mobile'</span>,<br>    style: <span class="hljs-literal">true</span>,<br>  &#125;),<br>  addLessLoader(&#123;<br>    lessOptions: &#123;<br>      javascriptEnabled: <span class="hljs-literal">true</span>,<br>      modifyVars: &#123;<br>        <span class="hljs-string">'@brand-primary'</span>: <span class="hljs-string">'#ff74b9'</span>,<br>        <span class="hljs-string">'brand-primary-tap'</span>: <span class="hljs-string">'#ff9cca'</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;)<br>)<br></code></pre></td></tr></table></figure><h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><p>接着是配置路径别名遇到的问题，通过 <code>customize-cra</code> 提供的 <code>addWebpackAlias</code> 可以配置别名，但是 typescript 一直无法解析对应别名，那么应该只需要配置好 ts 的 paths 就行了吧：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"compilerOptions"</span>: &#123;<br>    <span class="hljs-attr">"baseUrl"</span>: <span class="hljs-string">"."</span>,<br>    <span class="hljs-attr">"paths"</span>: &#123;<br>      <span class="hljs-attr">"@/*"</span>: [<span class="hljs-string">"./src/*"</span>]<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>vscode 不再报错了,接下来就是见证奇迹的时刻了<code>npm run start</code>：<br>控制台显示 <code>- compilerOptions.paths must not be set (aliased imports are not supported)</code> 并且 cra 会自动把 tscongfig 中的 paths 移除掉 😂<br>根据 <a href="https://github.com/timarney/react-app-rewired/issues/375" target="_blank" rel="noopener">issue</a>，使用将 baseUrl 和 paths 的配置移动到单独的文件后，在 tsconfig 里通过 extends 的方式继承，虽然控制台依然提示错误，但是别名可以生效。</p><h5 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h5><p>在 build 时，mini-css-extract-plugin 提示 Conflicting order， 错误位置在 antd-mobile 的样式文件。根据 <a href="https://github.com/ant-design/ant-design/issues/14895" target="_blank" rel="noopener">issue</a> 以及 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250" target="_blank" rel="noopener"> issue </a>看来这个问题主要是由于懒加载加上 antd 组件导入顺序不一致导致的，目前看来无需解决。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学 Generator《一》</title>
      <link href="/2020/07/15/%E9%87%8D%E5%AD%A6%20Generator%E3%80%8A%E4%B8%80%E3%80%8B/"/>
      <url>/2020/07/15/%E9%87%8D%E5%AD%A6%20Generator%E3%80%8A%E4%B8%80%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>在实际工作的业务开发中，使用到 Generator 比较少。近期有个项目状态管理使用的是 redux-saga，而 redux-saga 又是基于 Generator，借此机会重新学了下 Generator。</p><p>本文主要是记录 generator 的要点，以防将来遗忘。</p><a id="more"></a><h5 id="调用-generator-将会返回一个迭代器"><a href="#调用-generator-将会返回一个迭代器" class="headerlink" title="调用 generator 将会返回一个迭代器"></a>调用 generator 将会返回一个迭代器</h5><p>所谓 generator 实际上就是带有 * 的函数，调用后不会执行 generator 内部代码，而是返回一个 iterator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'generator'</span>)<br>&#125;<br><span class="hljs-keyword">const</span> iterator = generatorFunction()<br><span class="hljs-built_in">console</span>.log(iterator[<span class="hljs-built_in">Symbol</span>.iterator])<br><br><span class="hljs-comment">// function [Symbol.iterator]()</span><br></code></pre></td></tr></table></figure><h5 id="执行-generator"><a href="#执行-generator" class="headerlink" title="执行 generator"></a>执行 generator</h5><p>每次调用返回的迭代器的 next 方法可以执行 generator 中的代码，直到执行完遇到的第一个 yield 或者 return 后并交出执行权</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1'</span>)<br>  <span class="hljs-keyword">yield</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2'</span>)<br>  <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">const</span> iterator = generatorFunction()<br>iterator.next()<br><span class="hljs-comment">// 1</span><br>iterator.next()<br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h5 id="return-与-yield-的异同"><a href="#return-与-yield-的异同" class="headerlink" title="return 与 yield 的异同"></a>return 与 yield 的异同</h5><p>执行 iterator.next 返回的是一个包括 value 和 done 两个属性的对象，这个对象的 value 就是 <code>yield</code> 或 <code>return</code> 后面表达式的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">const</span> iterator = generatorFunction()<br><span class="hljs-keyword">var</span> a = iterator.next()<br><span class="hljs-built_in">console</span>.log(a)<br><span class="hljs-comment">// &#123; value: 1, done: false &#125;</span><br><span class="hljs-keyword">var</span> b = iterator.next()<br><span class="hljs-built_in">console</span>.log(b)<br><span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure><p>yield 与 return 类似，但 yield 是暂停的意思，而 return 则代表结束, return 之后的代码将不会被执行到。</p><p>done 为 true 表示遍历结束，但是此时依然可以可以继续调用 iterator.next()，只不过返回值将是 { value: undefined, done: true }。</p><p><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，直到 done 变为 true。</p><p>⚠️ done 为 true 的运行结果会被抛弃掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;;<br><span class="hljs-keyword">const</span> iterator = generatorFunction();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">of</span> iterator) &#123;<br>    <span class="hljs-built_in">console</span>.log(index);<br>&#125;<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h5 id="next-的参数"><a href="#next-的参数" class="headerlink" title="next 的参数"></a>next 的参数</h5><p>next 的参数可以最为 yield 语句的返回值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">yield</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a'</span>, a)<br>&#125;<br><span class="hljs-keyword">const</span> iterator = generatorFunction()<br>iterator.next()<br>iterator.next(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// a 1</span><br></code></pre></td></tr></table></figure><h5 id="yield"><a href="#yield" class="headerlink" title="yield *"></a>yield *</h5><p>通过 yield * 可以进入到另一个 generator 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">'foo'</span>;<br>    <span class="hljs-keyword">yield</span> * bar();<br>&#125;;<br> <br><span class="hljs-keyword">const</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">'bar'</span>;<br>    <span class="hljs-keyword">yield</span> * baz();<br>&#125;;<br> <br><span class="hljs-keyword">const</span> baz = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">'baz'</span>;<br>&#125;;<br> <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">of</span> foo()) &#123;<br>    <span class="hljs-built_in">console</span>.log(index);<br>&#125;<br><span class="hljs-comment">// foo</span><br><span class="hljs-comment">// bar</span><br><span class="hljs-comment">// baz</span><br></code></pre></td></tr></table></figure><h5 id="向-generaotr-内部抛异常"><a href="#向-generaotr-内部抛异常" class="headerlink" title="向 generaotr 内部抛异常"></a>向 generaotr 内部抛异常</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">yield</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-string">'a'</span>) &#123;<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Generator caught'</span>, e);<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> iterator = generatorFunction();<br>iterator.next();<br><span class="hljs-keyword">try</span> &#123;<br>    iterator.throw(<span class="hljs-string">'a'</span>);<br>    iterator.throw(<span class="hljs-string">'b'</span>);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Uncaught'</span>, e);<br>&#125;<br><span class="hljs-comment">// Generator caught a</span><br><span class="hljs-comment">// Uncaught b</span><br></code></pre></td></tr></table></figure><p>资料主要参考自  <a href="https://github.com/gajus/gajus.com-blog/blob/master/posts/the-definitive-guide-to-the-javascript-generators/index.md" target="_blank" rel="noopener">generator 权威指南</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
