<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeScript中的const断言</title>
      <link href="/2020/08/26/TypeScript%E4%B8%AD%E7%9A%84const%E6%96%AD%E8%A8%80/"/>
      <url>/2020/08/26/TypeScript%E4%B8%AD%E7%9A%84const%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近在使用 ant design 的 Table 组件，遇到一个问题，定义 Table 的 columns 属性如下：</p><a id="more"></a><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> columns: ColumnProps&lt;MyRecord&gt;[] = [&#123;</span><br><span class="line">  title: <span class="string">'ID'</span>,</span><br><span class="line">  dataIndex: <span class="string">'id'</span>,</span><br><span class="line">  align: <span class="string">'center'</span>,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>此时 TS 提示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Types of property <span class="string">'align'</span> are incompatible.</span><br><span class="line">       <span class="built_in"> Type </span><span class="string">'string'</span> is <span class="keyword">not</span> assignable <span class="keyword">to</span><span class="built_in"> type </span><span class="string">'"right" | "left" | "center" | undefined'</span>.  TS2322</span><br></pre></td></tr></table></figure><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>经过查看代码发现， ColumnProps 的 align 属性的实际继承自 ColumnSharedType：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ColumnSharedType&lt;RecordType&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    align?: AlignType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> AlignType = <span class="string">'left'</span> | <span class="string">'center'</span> | <span class="string">'right'</span>;</span><br></pre></td></tr></table></figure><p>也就是 column 中的 align 的类型为 string，而 string 无法 cast 到 AlignType。即：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AlignType = <span class="string">'left'</span> | <span class="string">'center'</span> | <span class="string">'right'</span>;</span><br><span class="line"><span class="keyword">let</span> align: AlignType | <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> myAlign = <span class="string">"center"</span></span><br><span class="line"><span class="comment">// Type 'string' is not assignable to type '"left" | "right" | "center" | undefined'.ts(2322)</span></span><br><span class="line">align = myAlign</span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>TypeScript 3.4 版本以上提供了 const 断言，可以通过 as const 来消除以上报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> columns: ColumnProps&lt;MyRecord&gt;[] = [&#123;</span><br><span class="line">  title: <span class="string">'ID'</span>,</span><br><span class="line">  dataIndex: <span class="string">'id'</span>,</span><br><span class="line">  align: <span class="string">'center'</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h4 id="const-assertions"><a href="#const-assertions" class="headerlink" title="const assertions"></a>const assertions</h4><p>以下内容翻译自 <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-4-rc/" target="_blank" rel="noopener">https://devblogs.microsoft.com/typescript/announcing-typescript-3-4-rc/</a> 中的 <code>const</code> assertions。(翻译不动的地方会贴上原文)</p><p>当声明一个可变的变量或者属性时，TypeScript 经常拓宽值以确保我们可以在不写明确切的类型的情况下进行赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以给 x 赋值</span></span><br><span class="line">x = <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure><p>严格来说，每一个字面量都有其字面类型。上面的 x 在类型推断时，由 <code>&quot;hello&quot;</code> 类型转为更为 widen 的 <code>string</code> 类型。</p><p>相对而言，如果 x 原始字面量类型为 “hello”， 那么我们就无法将 x 赋值为 “world”:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="string">"hello"</span> = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error!</span></span><br><span class="line">x = <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure><p>上面的情况看起来比较极端，但是在一些情况下比较有用的，例如，我们经常创建一个联合属性的对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape =</span><br><span class="line">    | &#123; kind: <span class="string">"circle"</span>, radius: <span class="built_in">number</span> &#125;</span><br><span class="line">    | &#123; kind: <span class="string">"square"</span>, sideLength: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getShapes</span>(<span class="params"></span>): <span class="title">readonly</span> <span class="title">Shape</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [</span><br><span class="line">        &#123; kind: <span class="string">"circle"</span>, radius: <span class="number">100</span>, &#125;,</span><br><span class="line">        &#123; kind: <span class="string">"square"</span>, sideLength: <span class="number">50</span>, &#125;,</span><br><span class="line">    ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Some terrible error message because TypeScript inferred</span></span><br><span class="line">    <span class="comment">// 'kind' to have the type 'string' instead of</span></span><br><span class="line">    <span class="comment">// either '"circle"' or '"square"'.</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可修改性是 TypeScript 断定什么时候 widen 类型的重要因素，而非分析所有代码。（Mutability is one of the best heuristics of intent which TypeScript can use to determine when to widen (rather than analyzing our entire program).）</p><p>正如上述例子，不幸的是，JavaScript 中的属性默认可修改。这意味着经常会有不必要的 widen 类型，我们需要在特定的地方对类型进行确切的声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getShapes</span>(<span class="params"></span>): <span class="title">readonly</span> <span class="title">Shape</span>[] </span>&#123;</span><br><span class="line">  <span class="comment">// This explicit annotation gives a hint</span></span><br><span class="line">  <span class="comment">// to avoid widening in the first place.</span></span><br><span class="line">  <span class="keyword">let</span> result: readonly Shape[] = [</span><br><span class="line">  &#123; kind: <span class="string">"circle"</span>, radius: <span class="number">100</span>, &#125;,</span><br><span class="line">  &#123; kind: <span class="string">"square"</span>, sideLength: <span class="number">50</span>, &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的方法可以解决问题，但是当数据结构越来越复杂的时候，这种方式将会显的笨重。</p><p>为了解决这个问题，TypeScript 3.4 为字面值引入了 const 断言。它的语法是一种类型断言，例如 <code>123 as const</code>。当我们这么使用的时候，意味着：</p><ol><li>字面量类型不会被 widen，如不会从 “hello” 变成 string</li><li>对象字面量的属性值为只读</li><li>数组字面量变成只读元组</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type '10'</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">10</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'readonly [10, 20]'</span></span><br><span class="line"><span class="keyword">let</span> y = [<span class="number">10</span>, <span class="number">20</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type '&#123; readonly text: "hello" &#125;'</span></span><br><span class="line"><span class="keyword">let</span> z = &#123; text: <span class="string">"hello"</span> &#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>在 tsx 文件以外，还可以这么使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type '10'</span></span><br><span class="line"><span class="keyword">let</span> x = &lt;<span class="keyword">const</span>&gt;<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'readonly [10, 20]'</span></span><br><span class="line"><span class="keyword">let</span> y = &lt;<span class="keyword">const</span>&gt;[<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type '&#123; readonly text: "hello" &#125;'</span></span><br><span class="line"><span class="keyword">let</span> z = &lt;<span class="keyword">const</span>&gt;&#123; text: <span class="string">"hello"</span> &#125;;</span><br></pre></td></tr></table></figure><p>This feature often means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Works with no types referenced or declared.</span></span><br><span class="line"><span class="comment">// We only needed a single const assertion.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getShapes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [</span><br><span class="line">        &#123; kind: <span class="string">"circle"</span>, radius: <span class="number">100</span>, &#125;,</span><br><span class="line">        &#123; kind: <span class="string">"square"</span>, sideLength: <span class="number">50</span>, &#125;,</span><br><span class="line">    ] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> shape of getShapes()) &#123;</span><br><span class="line">    <span class="comment">// Narrows perfectly!</span></span><br><span class="line">    <span class="keyword">if</span> (shape.kind === <span class="string">"circle"</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Circle radius"</span>, shape.radius);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Square side length"</span>, shape.sideLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面无需类型声明，const 断言允许 ts 使用最精确的表达式类型。</p><h5 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h5><p>需要注意的是，const 断言只能使用在简单的字面表达式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error!</span></span><br><span class="line"><span class="comment">//   A 'const' assertion can only be applied to a string, number, boolean, array, or object literal.</span></span><br><span class="line"><span class="keyword">let</span> a = (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ? <span class="number">0</span> : <span class="number">1</span>) <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Works!</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ?</span><br><span class="line">    <span class="number">0</span> <span class="keyword">as</span> <span class="keyword">const</span> :</span><br><span class="line">    <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>另外需要注意的是，const 不会将表达式转变为完全不可变：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">et arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    name: <span class="string">"foo"</span>,</span><br><span class="line">    contents: arr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.name = <span class="string">"bar"</span>;   <span class="comment">// error!</span></span><br><span class="line">foo.contents = [];  <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line">foo.contents.push(<span class="number">5</span>); <span class="comment">// ...works!</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不变的承诺 Promise</title>
      <link href="/2020/08/25/%E4%B8%8D%E5%8F%98%E7%9A%84%E6%89%BF%E8%AF%BA%20Promise/"/>
      <url>/2020/08/25/%E4%B8%8D%E5%8F%98%E7%9A%84%E6%89%BF%E8%AF%BA%20Promise/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Promise 是异步编程的一种解决方案，可以解决前端的回调地狱。以下根据 <a href="https://es6.ruanyifeng.com/?search=promise&x=0&y=0#docs/promise" target="_blank" rel="noopener">ES6 入门</a> 简单过一下 Promise 的基础及个人的一些见解补充，同时尝试实现一个符合 PromiseA+ 规范的 Promise。</p> <a id="more"></a><h4 id="Promise-基础"><a href="#Promise-基础" class="headerlink" title="Promise 基础"></a>Promise 基础</h4><h5 id="Promise-的状态"><a href="#Promise-的状态" class="headerlink" title="Promise 的状态"></a>Promise 的状态</h5><p>Promise 只有三种状态：<code>pending</code>（进行中），<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。</p><p>Promise 的状态改变只有两种情况：</p><p><code>pending</code> 到 <code>fulfilled</code> 以及 <code>pending</code> 到 <code>rejected</code>。当状态变成  <code>fulfilled</code> 或 <code>rejected</code>时，我们就称这个 Promise  <code>resolved</code>。</p><p>⚠️ 我们通常说的 resolved 仅指代 <code>fulfilled</code>，不包括 <code>rejected</code>。</p><h5 id="构造一个-Promise"><a href="#构造一个-Promise" class="headerlink" title="构造一个 Promise"></a>构造一个 Promise</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="promise-then"><a href="#promise-then" class="headerlink" title="promise.then"></a>promise.then</h5><p>Promise 的实例拥有 then 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>⚠️  Promise 新建后立即执行，而 then 方法则属于微任务的回调，执行时机为宏任务执行之后，具体的事件循环机制后面开新坑总结。</p><h5 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h5><p>构造 Promise 时，第一个参数 resolve 函数所接收的参数，可以是一个普通的值，也可以是一个 promise。如果接收的是一个 promise 实例，那么 promise 的状态取决于 resolve 接收的 promise 的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// 3s 后输出：Error: fail</span></span><br></pre></td></tr></table></figure><p>这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><h5 id="resolve-与-return"><a href="#resolve-与-return" class="headerlink" title="resolve 与 return"></a>resolve 与 return</h5><p>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="catch"><a href="#catch" class="headerlink" title=".catch"></a>.catch</h5><ol><li><p><code>Promise.prototype.catch()</code>方法是<code>.then(null | undefined, rejection)</code>，用于指定发生错误时的回调函数。</p></li><li><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止，即错误总是会被下一个<code>catch</code>语句捕获。</p></li><li><p><code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>与 <code>catch()</code> 方法。</p></li><li><p>promise 内部的错误不会抛到外层，因此 <code>try/catch</code> 无法捕获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'err'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'out'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch you'</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="comment">// 未捕获的异常：Uncaught (in promise) err</span></span><br></pre></td></tr></table></figure><p>因此最好 promise 后都用 catch 来捕获。</p></li></ol><h5 id="finally"><a href="#finally" class="headerlink" title=".finally()"></a>.finally()</h5><ul><li>ES2018 引入，即不管 Promise 对象最后状态如何，都会执行的操作。</li><li><code>finally</code>方法的回调函数不接受任何参数</li></ul><h4 id="手写一个简易的-Promise"><a href="#手写一个简易的-Promise" class="headerlink" title="手写一个简易的 Promise"></a>手写一个简易的 Promise</h4><p>手写一个符合 PromiseA+ 规范的 Promise 并不简单，可以先简单根据上述 promise 的基本功能实现一个简易版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING</span><br><span class="line">    <span class="comment">// 收集 .then 中的 resolve 的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.resolveCallbacks = []</span><br><span class="line">    <span class="comment">// 收集 .then 中的 reject 的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.rejectCallbacks = []</span><br><span class="line">    <span class="comment">// resolve(result)</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// reject(reason)</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 由于 fn 有可能异常，需要捕获</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Promise 一实例化就执行传入的 fn</span></span><br><span class="line">      <span class="comment">// 注意此处将函数当作参数传入，需要 bind 绑定上下文</span></span><br><span class="line">      <span class="comment">// 或者 resolve / reject 用箭头函数实现</span></span><br><span class="line">      fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    <span class="comment">// 修改状态</span></span><br><span class="line">    <span class="keyword">this</span>.state = RESOLVED</span><br><span class="line">    <span class="keyword">this</span>.result = result</span><br><span class="line">    <span class="comment">// 执行 then 中的 resolve 回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.resolveCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(result))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    <span class="comment">// 修改状态</span></span><br><span class="line">    <span class="keyword">this</span>.state = REJECTED</span><br><span class="line">    <span class="keyword">this</span>.reason = reason</span><br><span class="line">    <span class="comment">// 执行 then 中的 reject 回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.rejectCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(reason))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onResolved, onRejected) &#123;</span><br><span class="line">    <span class="comment">// 调用 .then 时如果还在 pending 则将回调先存起来，等待 resolve 后执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="comment">// 收集回调</span></span><br><span class="line">      <span class="keyword">this</span>.resolveCallbacks.push(onResolved)</span><br><span class="line">      <span class="keyword">this</span>.rejectCallbacks.push(onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果调用 .then 时已经 resolve / reject, 那么直接执行对应的回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === RESOLVED) &#123;</span><br><span class="line">      onResolved(<span class="keyword">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">      onResolved(<span class="keyword">this</span>.reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'resolved'</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myPromise.then(</span><br><span class="line">  (result) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;,</span><br><span class="line">  (reason) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个版本实际上还未能达到 Promise / A+ 的规范，比如 catch 方法，链式调用，实现 all，race 方法等等。</p><p>####符合 Promise / A+ 的 Promise</p><p>接下来完善以下几点</p><ol><li>.then 接收的不是函数的情况</li><li>.catch</li><li>resolve 一个 promise 的情况</li><li>.all / .race</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svg 图片的上传下载</title>
      <link href="/2020/08/17/svg%20%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2020/08/17/svg%20%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近有个需求：</p><ol><li>根据传入的 code 生成条形码 svg 图片</li><li>将 svg 图片上传至 cdn</li><li>展示图片时需要点击按钮后保存至本地</li></ol><a id="more"></a><h4 id="生成条形码"><a href="#生成条形码" class="headerlink" title="生成条形码"></a>生成条形码</h4><p>这里借助一个开源的仓库</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> JsBarcode <span class="keyword">from</span> <span class="string">'jsbarcode'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generateBarcode = <span class="keyword">async</span> (barcode, options = &#123;&#125;) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建一个 svg 元素</span></span><br><span class="line">  <span class="keyword">const</span> svg = <span class="built_in">document</span>.createElementNS(<span class="string">'http://www.w3.org/2000/svg'</span>, <span class="string">'svg'</span>);</span><br><span class="line">  <span class="comment">// 甚至宽高</span></span><br><span class="line">  svg.setAttribute(<span class="string">'width'</span>, <span class="string">`<span class="subst">$&#123;width&#125;</span>px`</span>);</span><br><span class="line">  svg.setAttribute(<span class="string">'height'</span>, <span class="string">`<span class="subst">$&#123;height&#125;</span>px`</span>);</span><br><span class="line">  <span class="comment">// 生成条形码 svg 的图片</span></span><br><span class="line">  JsBarcode(svg, barcode, options);</span><br><span class="line">  <span class="keyword">return</span> svg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h4><h5 id="svg-转-canvas"><a href="#svg-转-canvas" class="headerlink" title="svg 转 canvas"></a>svg 转 canvas</h5><p>由于服务端同学提供的接口只支持 canvas，因此首先要将 svg 转成 canvas：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> svgToCanvas = <span class="function">(<span class="params">svg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// svg.outerHTML 获取 svg 元素的 html 字符串</span></span><br><span class="line">  <span class="comment">// btoa 将 svg 转成 base64</span></span><br><span class="line"><span class="keyword">const</span> href = <span class="string">`data:image/svg+xml;base64,<span class="subst">$&#123;<span class="built_in">window</span>.btoa(</span></span></span><br><span class="line"><span class="string"><span class="subst">    <span class="built_in">unescape</span>(<span class="built_in">encodeURIComponent</span>(svg.outerHTML)),</span></span></span><br><span class="line"><span class="string"><span class="subst">  )&#125;</span>`</span>;</span><br><span class="line">  <span class="comment">// 构建一个 Image</span></span><br><span class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.width = width;</span><br><span class="line">  img.height = height;</span><br><span class="line">  </span><br><span class="line">  img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 构建一个 canvas</span></span><br><span class="line">    <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">    <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    <span class="comment">// 将 图片画到 canvas 中</span></span><br><span class="line">    ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    <span class="comment">// 转成 jpeg 的 base64</span></span><br><span class="line"> <span class="keyword">const</span> dataURI = canvas.toDataURL(<span class="string">'image/jpeg'</span>);</span><br><span class="line">    <span class="comment">// 上传</span></span><br><span class="line">    upload(dataURI);</span><br><span class="line">  &#125; </span><br><span class="line">  img.src = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Data-URL"><a href="#Data-URL" class="headerlink" title="Data URL"></a>Data URL</h5><p>通过 `canvas.toDataURL 将 canvas 转成 Data URL，一段 Data URL 由 4 个部分组成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br><span class="line">// 例如： "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC"</span><br></pre></td></tr></table></figure><h5 id="Base64的解码与编码"><a href="#Base64的解码与编码" class="headerlink" title="Base64的解码与编码"></a>Base64的解码与编码</h5><p><code>atob()</code> 函数能够解码通过base-64编码的字符串数据。</p><p><code>btoa()</code> 函数能够从二进制数据“字符串”创建一个base-64编码的ASCII字符串。</p><h5 id="Base64-转-Blob"><a href="#Base64-转-Blob" class="headerlink" title="Base64 转 Blob"></a>Base64 转 Blob</h5><p>上传图片文件需要将 base64 转成 Blob 对象，有两种方法：</p><p>######Base64 转 Blob 第一种方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURItoBlob</span>(<span class="params">dataURI: string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 atob 转回 string</span></span><br><span class="line">  <span class="keyword">const</span> byteString = atob(dataURI.split(<span class="string">','</span>)[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// 获得文件类型</span></span><br><span class="line">  <span class="keyword">const</span> mimeString = dataURI.split(<span class="string">','</span>)[<span class="number">0</span>].split(<span class="string">':'</span>)[<span class="number">1</span>].split(<span class="string">';'</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 转成 </span></span><br><span class="line">  <span class="keyword">const</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(byteString.length);</span><br><span class="line">  <span class="keyword">const</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; byteString.length; i++) &#123;</span><br><span class="line">    ia[i] = byteString.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 转成 blob</span></span><br><span class="line">  <span class="keyword">const</span> bb = <span class="keyword">new</span> Blob([ab], &#123; <span class="attr">type</span>: mimeString &#125;);</span><br><span class="line">  <span class="keyword">return</span> bb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 思路：</p><ol><li>拆解 data uri，通过 atob 将 base64 解码成字符串</li><li>拆解 data uri，获得图片的格式</li><li>创建一个 arraybuffer</li><li>通过TypedArray（这里使用 Uint8Array）将字符串的内容写入 arraybuffer </li><li>将 array buffer 转成 blob</li></ol><h6 id="Base64-转-Blob-第二种方法："><a href="#Base64-转-Blob-第二种方法：" class="headerlink" title="Base64 转 Blob 第二种方法："></a>Base64 转 Blob 第二种方法：</h6><p>通过 <code>fetch</code> 将 dataURI 转成 blob：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bb = <span class="keyword">await</span> fetch(dataURI).then(<span class="function">(<span class="params">res</span>) =&gt;</span> res.blob())</span><br></pre></td></tr></table></figure><h5 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h5><p>构造 FormData 上传图片文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> upload = <span class="function">(<span class="params">dataURI: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建form对象</span></span><br><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">  <span class="comment">// 通过 append 向 form 对象添加数据</span></span><br><span class="line">  formData.append(<span class="string">'file'</span>, dataURItoBlob(dataURI));</span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> axios.post(<span class="string">'/api/upload'</span>, formData, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span>,</span><br><span class="line">      <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h5><p>保存图片到本地：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> download = <span class="function">(<span class="params">fileUrl, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  x.open(<span class="string">'GET'</span>, fileUrl, <span class="literal">true</span>);</span><br><span class="line">  x.responseType = <span class="string">'blob'</span>;</span><br><span class="line">  x.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 转为 objectUrl</span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="built_in">window</span>.URL.createObjectURL(x.response);</span><br><span class="line">    <span class="comment">// 构建一个 a 标签</span></span><br><span class="line">    <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">    a.href = url;</span><br><span class="line">    a.download = name;</span><br><span class="line">    a.click();</span><br><span class="line">  &#125;;</span><br><span class="line">  x.send();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用 a 标签的 download 属性可以实现图片的下载，但是有个限制是 href 必须是同源的地址，否则无法下载。</p><p>因此这里通过 get 请求获得图片的 Blob 格式，并用 window.URL.createObjectURL 将 Blob 转成 objectUrl 解决了跨域问题。之后就可以用 a 标签的 download 属性下载文件。</p><h4 id="补充几个概念"><a href="#补充几个概念" class="headerlink" title="补充几个概念"></a>补充几个概念</h4><h5 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h5><p>上传图片时，我们实现了一个函数 dataURItoBlob， 通过这个函数来将 base64 转为 Blob，最终上传给接口的 formData 中的 file 也是一个 Blob 对象。</p><p>什么是 Blob 对象？</p><blockquote><p>一个 <strong>Blob</strong>对象表示一个不可变的, 原始数据的类似文件对象。Blob 表示的不一定是JavaScript原生格式的数据。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File" target="_blank" rel="noopener"><code>File</code></a> 接口基于<code>Blob</code>，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p></blockquote><p>Blob 属于 web 提供的 api，因此 mdn 上说的 Blob 表示的不一定是JavaScript原生格式的数据。</p><h5 id="File"><a href="#File" class="headerlink" title="File"></a>File</h5><p>File 继承自 Blob，可以看作是特殊的 Blob。常见的获得 File 对象的方法有 <code>input</code> 标签上选择文件后返回的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileList" target="_blank" rel="noopener"><code>FileList</code></a> 对象。</p><h5 id="Blob-转-URL"><a href="#Blob-转-URL" class="headerlink" title="Blob 转 URL"></a>Blob 转 URL</h5><p>在下载时，我们通过 get 请求获得了图片的 blob 格式，之后通过 URL.createObjectURL 转成 objectUrl，这样就可以像普通的 url，赋值给 img 的 src 属性或者 a 标签的 href 属性。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码层面解读Vue响应式原理</title>
      <link href="/2020/08/11/%E6%BA%90%E7%A0%81%E5%B1%82%E9%9D%A2%E8%A7%A3%E8%AF%BBVue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2020/08/11/%E6%BA%90%E7%A0%81%E5%B1%82%E9%9D%A2%E8%A7%A3%E8%AF%BBVue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在 Vue（以下均指的是 2.x 版本） 中，数据模型仅仅是普通的 JavaScript 对象，当你修改它们时，视图会进行更新，这就是 Vue 的响应式系统，其设计模式就是观察者模式。</p><a id="more"></a><h4 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h4><p>以下为阅读源码时，对响应式实现原理的理解，为了思路更清晰，仅考虑最简单的情况，并且可能会省略或修改部分代码。</p><p>首先，顺着 vue 的生命周期开始：</p><h5 id="beforeCreate-与-created"><a href="#beforeCreate-与-created" class="headerlink" title="beforeCreate 与 created"></a>beforeCreate 与 created</h5><p>首先 在 _init 方法中执行 beforeCreate 与 created ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  initState(vm)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callHook(vm, <span class="string">'created'</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住这里执行了一个方法： <code>initState</code></p><p>#####initState</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 略：...初始化 props，methods 等</span></span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 略：...初始化 computed，watch 等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 initData 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 略：...将 data 的每个属性都挂在 vm 上,这样可以通过 this.xx 直接访问到</span></span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住 <code>observe</code> 这个方法。</p><h5 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h5><p><code>observe</code>  用于创建一个 observer 实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="comment">// 判断是否已经 observe 过，是的话直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    <span class="comment">// observer 最终会挂在 value 的 __ob__ 属性上，因此可以这么判断是否  observe 过，详情看 Observer 的代码</span></span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 否则满足一系列条件的情况下就会重新实例化一个 observer</span></span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化  observer 的过程中实际上会将传入对象的每个属性通过 <code>defineReactive</code> 方法转成响应式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="comment">// 初始化数据模型的 dep 实例</span></span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="comment">// observer 最终会挂在 value 的 __ob__ 属性上</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 略：...重写 value 的一些数组方法</span></span><br><span class="line">      <span class="comment">// 略：...遍历数组元素并 observe</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">       <span class="comment">// 遍历传入的每个属性，并用 defineReactive 转成响应式</span></span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h5><p>上面代码中最核心的一个函数是 <code>defineReactive</code>，做了以下几件事情：</p><ol><li>初始化目标属性的 dep 实例，这实际上是一个发布者</li><li>对该属性的子对象递归调用 observe</li><li>通过<code>Object.defineProperty</code>劫持该属性的 getter 与 setter：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化目标属性的 dep 实例</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"><span class="comment">// 略：... 一些容错判断</span></span><br><span class="line">  <span class="comment">// 略：... 一些初始化</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 递归 observe</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="comment">// 劫持 get 与 set</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="comment">// ...一旦获取该属性就会进行依赖收集</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="comment">// ...一旦设置了新值就会派发更新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就用到了观察者模式：当这个属性更新时，会通过发布者通知到观察者，这些观察者收到通知后更新视图。这里发布者实际上是<code>Dep</code> 实例，观察者实际上是 <code>Watcher</code> 实例，它的 <code>update</code> 方法可以更新视图。</p><p>所以，依赖收集实际上就是将<code>Wathcer</code> 实例添加到 <code>Dep</code> 实例的观察者列表。</p><p>reactiveGetter 和 reactiveSetter 这两个方法的具体实现我们先放一边，这里只需要知道大概的作用即可，后面会详细介绍。我们现在来看看什么时候会触发 get 呢？答案是在挂载组件的时候。</p><h5 id="beforeMount-与-mounted"><a href="#beforeMount-与-mounted" class="headerlink" title="beforeMount 与 mounted"></a>beforeMount 与 mounted</h5><p>然后是在 mountComponent 中执行  beforeMount 以及 mounted：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line">  <span class="comment">// 略：...这里有个非生产环境的判断，这里不考虑简化成如下：</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// 这里实例化 Watcher：可以看作是更新视图用的观察者，这里省略一些参数</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent)</span><br><span class="line">  <span class="comment">// ...仅考虑 new Vue 的情况，代码简化如下</span></span><br><span class="line">  callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂载组件的时候就会实例化一个 <code>Watcher</code></p><h5 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h5><p>当我们实例化 Watcher 的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 略：...一些初始化</span></span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.newDeps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="comment">// 略：...一些初始化</span></span><br><span class="line">    <span class="comment">// 略：...对 this.getter 的一些初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.computed) &#123;</span><br><span class="line">      <span class="comment">// computed 的情况，本文暂不考虑</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化时就会执行 get 方法</span></span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="comment">// pushTarget 用于将 watcher 实例挂到 Dep 的 target 这个静态属性上</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 此时的 this.getter 实际上就是 updateComponent</span></span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 略：...错误处理</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 略：...递归访问 value，触发它所有子项的 getter</span></span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pushTarget</code> 将 <code>watcher</code> 实例挂到 <code>Dep</code> 的 <code>target</code> 这个静态属性, 用于 <code>Dep</code> 内部可以访问到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: ?Watcher</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  Dep.target = _target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用 <code>this.getter</code>, 这里的 <code>this.getter</code> 实际上就是 <code>updateComponent</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm._update(vm._render(), hydrating)</span><br></pre></td></tr></table></figure><p><code>vm._render()</code> 会生成 VNode，这个过程会访问 vm 上的数据，至此就会触发数据对象的 getter，进行依赖收集。</p><h5 id="思路小结"><a href="#思路小结" class="headerlink" title="思路小结"></a>思路小结</h5><p>至此我们先梳理一下这一整个过程，以免遗忘：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate =&gt; </span><br><span class="line">initState -&gt; observe -&gt; <span class="keyword">new</span> Observer</span><br><span class="line">  -&gt; defineReactive：实例化 Dep，劫持对象属性 getter 与 setter</span><br><span class="line">=&gt; created</span><br><span class="line">=&gt; beforeMount</span><br><span class="line">  实例化 Watcher -&gt; 将 watcher 实例绑定到 Dep.target，并触发对象属性的 getter，收集依赖</span><br><span class="line">=&gt; mounted</span><br><span class="line">=&gt; 当数据模型变更时，触发 setter，更新视图</span><br></pre></td></tr></table></figure><p>在 defineReactive 中有个关键的步骤是实例化 <code>Dep</code>。</p><h5 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h5><p>上面说过 Dep 实例是一个发布者，其代码其实很简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      <span class="comment">// 这里将 Dep.target 即 watcher 添加到 subs 里</span></span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// 发布通知</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最终调用的是 <code>depend</code>方法来添加观察者，即<code>Dep.target.addDep</code>，我们知道此时 Dep.target 实际上就是 watcher 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.id</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="comment">// 将发布者 id 添加到 this.newDepIds</span></span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">    <span class="comment">// 将发布者 添加到 this.newDeps</span></span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      <span class="comment">// 如果旧的 发布者id 列表中没有这个发布者 id，那么就添加到发布者的观察者列表中</span></span><br><span class="line">      dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>而在 watcher 中，最终还是调用了传入的 dep 实例的 addSub 来添加到 dep 的观察者列表中。之所以这么设计，其原因是为了能在 watcher 中维护一个自己订阅的发布者列表。</p><p>那么 watcher 中的发布者列表有什么用呢？还记得 Watcher 实例化的最后会调用  <code>this.cleanupDeps()</code> 吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cleanupDeps () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">      dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">  <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">  <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">  <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">  tmp = <span class="keyword">this</span>.deps</span><br><span class="line">  <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">  <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">  <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数实际上的作用是：</p><ol><li><p>如果无需再观察，则从发布者的观察者列表中移除</p></li><li><p>将本次的发布者 id 列表记录在 this.depsIds 中，清空 this.newDepIds</p></li><li><p>将本次的发布者列表记录在 this.deps 中，清空 this.newDeps</p><p>那么具体是如何将对象属性转为响应式的呢，我们看看其具体实现：</p></li></ol><h5 id="reactiveGetter"><a href="#reactiveGetter" class="headerlink" title="reactiveGetter"></a>reactiveGetter</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 此时的 Dep.target 就是 watcher，关于 Dep 后面会详细解释</span></span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    <span class="comment">// 这里会将 watcher 实例添加进 dep 的 subs 中维护，即收集依赖</span></span><br><span class="line">    dep.depend()</span><br><span class="line">    <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">      <span class="comment">// 子对象的依赖收集</span></span><br><span class="line">      childOb.dep.depend()</span><br><span class="line">      <span class="comment">// 略：...对数组的一些处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回属性值</span></span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="reactiveSetter"><a href="#reactiveSetter" class="headerlink" title="reactiveSetter"></a>reactiveSetter</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// value：属性值</span></span><br><span class="line">  <span class="keyword">const</span> value = ...</span><br><span class="line">  <span class="comment">// 略：...一些判断是否触发 setter 的条件</span></span><br><span class="line">  <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">    setter.call(obj, newVal)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    val = newVal</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置新值后需要重新 observe</span></span><br><span class="line">  childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">  <span class="comment">// 发布通知</span></span><br><span class="line">  dep.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文简化了一些细节，但是 Vue 的响应式原理大致如此。当理解了原理之后，如果后面遗忘了的话，以下为重要的记忆点：</p><ol><li>observe：实例化 Observe，参数为数据模型，实例化过程会调用遍历对象属性调用 defineReactive</li><li>defineReactive：实例化 Dep，劫持对象属性的 getter 与 setter，getter 时进行依赖收集</li><li>在挂载组件的时候，会实例化 Watcher，此时会触发 getter</li><li>当更新对象属性时，会调用 Dep 实例的 notify，触发 watcher 的 update</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react常见问题解析</title>
      <link href="/2020/08/10/react%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/08/10/react%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>断断续续开始梳理一些 react 的常见问题，将尽可能结合源码来解释。当前版本为 16.x。</p><a id="more"></a><h4 id="Q：为什么-react-组件需要-import-React-from-‘react’？"><a href="#Q：为什么-react-组件需要-import-React-from-‘react’？" class="headerlink" title="Q：为什么 react 组件需要 import React from ‘react’？"></a>Q：为什么 react 组件需要 import React from ‘react’？</h4><p>A：这是因为 babel 在编译 jsx 代码时，是调用 React.createElement 来创建一个组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">转换前：&lt;div /&gt;</span><br><span class="line">转换后：React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="Q：为什么-react-组件开头需要大写？"><a href="#Q：为什么-react-组件开头需要大写？" class="headerlink" title="Q：为什么 react 组件开头需要大写？"></a>Q：为什么 react 组件开头需要大写？</h4><p>A：React.createElement  的第一个参数表示类型。如果开头小写，类型为字符串，此时 react 会认为是一个原生的 dom 节点。而如果是大写，则类型会是个变量，react 会认为这是个自定义的组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">转化前：&lt;Comp /&gt;</span><br><span class="line">转化后：React.createElement(Comp, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="Q：为什么诸如-key，ref-等-props-不会传递给组件？"><a href="#Q：为什么诸如-key，ref-等-props-不会传递给组件？" class="headerlink" title="Q：为什么诸如 key，ref 等 props 不会传递给组件？"></a>Q：为什么诸如 key，ref 等 props 不会传递给组件？</h4><p>A：React.createElement 的第二个参数为 config，babel 转化如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">转化前：&lt;Comp props1=<span class="string">"props1"</span> props2=&#123;props2&#125; /&gt;</span><br><span class="line">转化后：</span><br><span class="line">React.createElement(Comp, &#123;</span><br><span class="line">  props1: <span class="string">"props1"</span>,</span><br><span class="line">  props2: props2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而在生成 props 时会将保留属性移除出去的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">    !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">  ) &#123;</span><br><span class="line">    props[propName] = config[propName];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保留属性就包括了 key 和 ref，因此不会传给组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RESERVED_PROPS = &#123;</span><br><span class="line">  key: <span class="literal">true</span>,</span><br><span class="line">  ref: <span class="literal">true</span>,</span><br><span class="line">  __self: <span class="literal">true</span>,</span><br><span class="line">  __source: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Q-props-children-是什么？"><a href="#Q-props-children-是什么？" class="headerlink" title="Q: props.children 是什么？"></a>Q: props.children 是什么？</h4><p>A：props.children 是组件的子节点合集，babel 转化如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">转换前：</span><br><span class="line">&lt;Comp&gt;</span><br><span class="line">  &lt;div&gt;<span class="number">1</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span&gt;2&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/Comp&gt;</span></span><br><span class="line"><span class="regexp">转换后：</span></span><br><span class="line"><span class="regexp">React.createElement(Comp, null,</span></span><br><span class="line"><span class="regexp">React.createElement("div", null, "1"), </span></span><br><span class="line"><span class="regexp">React.createElement("span", null, "2")</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>React.createElement 虽然只声明了三个参数，实际上从第三个参数开始就都是子节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createElement(type, config, children)</span><br></pre></td></tr></table></figure><p>在生成 props.children 时，如果是单个子节点，则直接赋值给 props.children，如果有多个子节点将这些节点合成一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.freeze) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.freeze(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="Q-React-children-map"><a href="#Q-React-children-map" class="headerlink" title="Q: React.children.map"></a>Q: React.children.map</h4><h4 id="Q-React-遍历元素的-key-属性"><a href="#Q-React-遍历元素的-key-属性" class="headerlink" title="Q: React 遍历元素的 key 属性"></a>Q: React 遍历元素的 key 属性</h4><h4 id="Q：什么是-Fiber？"><a href="#Q：什么是-Fiber？" class="headerlink" title="Q：什么是 Fiber？"></a>Q：什么是 Fiber？</h4><p>A：每个 ReactElement 都有一个对应的 Fiber，Fiber 上记录了组件的各种状态。同时 Fiber 通过 child，sibling，以及 return 来记录其子，兄弟以及父节点的 Fiber。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;son&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child1&quot; &#x2F;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child2&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;son2&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>那么 Fiber 遍历所有节点的顺序为：</p><img src="https://images.gitee.com/uploads/images/2020/0826/084732_693094f2_1748283.png" alt="fiber" style="zoom:50%;" /><p>遍历的顺序为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一直遍历到最后一个层级的叶子结点</span></span><br><span class="line">FiberRoot -&gt; RootFiber -&gt; App -&gt; parent -&gt; son -&gt; child</span><br><span class="line"><span class="comment">// 然后查找兄弟节点</span></span><br><span class="line">child -&gt; child2</span><br><span class="line"><span class="comment">// 如果兄弟节点也没有子节点，则 return ，即返回父节点</span></span><br><span class="line">child2 -&gt; son -&gt; son2 -&gt; parent -&gt; App -&gt; RootFiber -&gt; FiberRoot</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-JS中的观察者模式与发布订阅模式</title>
      <link href="/2020/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在上一篇文章《debounce与throttle》 中提到了 RxJS， RxJS 中有两个重要的概念: Observable（可被观察者） 和 Observer（观察者），RxJS 的 Observable 就是观察者模式和迭代器模式的组合。</p><p>在 javascript 中，观察者模式和发布订阅模式极为相似，因此本文将探讨这两种模式以及其应用。</p> <a id="more"></a><h4 id="观察者模式（Observer-pattern）"><a href="#观察者模式（Observer-pattern）" class="headerlink" title="观察者模式（Observer pattern）"></a>观察者模式（Observer pattern）</h4><blockquote><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 —— Graphic Design Patterns</p></blockquote><p>观察者模式有两个对象：一个是观察者，另一个上面提到的目标对象可以称为是发布者，基本的流程为：</p><ol><li>发布者维护一个观察者列表，可以添加或者删除观察者</li><li>当发布者发布通知时，遍历观察者列表，并调用观察者提供的方法</li></ol><p>发布者的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 维护一个观察者列表</span></span><br><span class="line">    <span class="keyword">this</span>.observers = []</span><br><span class="line">    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">// 添加观察者</span></span><br><span class="line">  addObserver(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除观察者</span></span><br><span class="line">  removeObserver(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = <span class="keyword">this</span>.observers.filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== observer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布通知</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行观察者提供的方法，这里假设为 update</span></span><br><span class="line">      item.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅者则比较简单，实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`observer <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> update`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Observer(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> Observer(<span class="string">'b'</span>)</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Observer(<span class="string">'c'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> publisher = <span class="keyword">new</span> Publisher()</span><br><span class="line">publisher.addObserver(a)</span><br><span class="line">publisher.addObserver(b)</span><br><span class="line">publisher.addObserver(c)</span><br><span class="line"><span class="comment">// 发布通知</span></span><br><span class="line">publisher.notify()</span><br><span class="line"><span class="comment">// a b c</span></span><br></pre></td></tr></table></figure><p>Vue 的响应式原理就是观察者模式的一个典型应用，关于 Vue 的响应式由于篇幅原因，将会另起一篇详细分析。</p><h4 id="发布订阅模式（Pub-sub-pattern）"><a href="#发布订阅模式（Pub-sub-pattern）" class="headerlink" title="发布订阅模式（Pub-sub pattern）"></a>发布订阅模式（Pub-sub pattern）</h4><p>发布订阅模式是从观察者模式发展而来，两者的区别在于：观察者模式中发布者与观察者是松耦合，而发布订阅则在发布者与订阅者中加入了事件中心实现发布者与观察者的完全解耦。</p><p>用发布订阅模式模拟事件绑定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventCenter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addListener(type, fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers[type] = [...(<span class="keyword">this</span>.observers[type] || []), fn]</span><br><span class="line">  &#125;</span><br><span class="line">  removeListener(type, fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="keyword">this</span>.observers[type];</span><br><span class="line">    <span class="keyword">if</span> (!listeners || !listeners.length) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.observers[type] = listeners.filter(<span class="function"><span class="params">v</span> =&gt;</span> v !== fn);</span><br><span class="line">  &#125;</span><br><span class="line">  dispatchEvent(type) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="keyword">this</span>.observers[type];</span><br><span class="line">    <span class="keyword">if</span> (!listeners || !listeners.length) <span class="keyword">return</span>;</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> evtCenter = <span class="keyword">new</span> EventCenter()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅 click 事件</span></span><br><span class="line">evtCenter.addListener(<span class="string">'click'</span>, handleClick)</span><br><span class="line"><span class="comment">// 发布 click 事件</span></span><br><span class="line">evtCenter.dispatchEvent(<span class="string">'click'</span>)</span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">evtCenter.removeListener(<span class="string">'click'</span>, handleClick)</span><br></pre></td></tr></table></figure><p>可以看到与观察者模式不同，在发布订阅模式中，我们的发布和订阅都是通过事件中心来进行调度的。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debounce与throttle</title>
      <link href="/2020/08/06/debounce%E4%B8%8Ethrottle/"/>
      <url>/2020/08/06/debounce%E4%B8%8Ethrottle/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>测试同学提了个 bug，在搜索框中疯狂输入文字，不一会儿接口就报错了。这个 bug 实际上就是由于每输入一个字符时，就去请求接口引起的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleSearch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...请求接口</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;Input onChange=&#123;handleSearch&#125; /&gt;</span><br></pre></td></tr></table></figure><p>解决方法是通过 <code>debounce</code> 来控制输入的频率。</p><p>实际上 <code>debounce</code> 和 <code>throttle</code> 这两个概念经常是一起出现，在工作中也常常使用到。在早年接触前端的时候，项目里有 <code>lodash</code>，因此直接使用其提供的  <code>debounce</code> 和 <code>throttle</code> 。而在一些简单的项目里，往往不引入 <code>lodash</code>，这个时候就需要自己实现，于此做个记录。</p><a id="more"></a><h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><p><code>debounce</code> 也就是防抖，看看 lodash 中 debounce 的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.debounce(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure><p>返回一个函数，该函数会距离上次调用后，延迟 <code>wait</code> 毫秒后调用<code>func</code>。</p><p>在上面的 bug 中，对原搜索方法进行防抖处理后，仅当用户停止输入 300 毫秒后，才请求接口进行搜索：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止输入 300 ms 后，进行搜索</span></span><br><span class="line">_.debounce(handleSearch, <span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>####throttle</p><p><code>throttle</code> 我们称之为截流，同样看看 loads 中 throttle 的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.throttle(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure><p>返回一个函数，该函数最多每 <code>wait</code> 毫秒调用一次 <code>func</code>。</p><p>如果对搜索方法进行截流，则无论用户输入多快，每 1 秒仅请求一次：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止输入 300 ms 后，进行搜索</span></span><br><span class="line">_.debounce(handleSearch, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h4 id="手写一个-debounce"><a href="#手写一个-debounce" class="headerlink" title="手写一个 debounce"></a>手写一个 debounce</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeout) &#123;</span><br><span class="line">      clearTimeout(timeout)</span><br><span class="line">    &#125;</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> func.call(<span class="keyword">this</span>, ...args), wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 func 被当作是参数传递进来，注意上面的 func 需要绑定 this。并且在使用时如果有 this 指向，需要显式指明 this，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = debounce(o.b).bind(o);</span><br></pre></td></tr></table></figure><p>对 debounce 进一步拓展，如果需要在调用时立刻执行一次，则可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait = <span class="number">0</span>, head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callNow = head &amp;&amp; !timeout;</span><br><span class="line">    timeout &amp;&amp; clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!callNow) &#123;</span><br><span class="line">        func.call(<span class="keyword">this</span>, ...args);</span><br><span class="line">      &#125;</span><br><span class="line">      timeout = <span class="literal">null</span></span><br><span class="line">    &#125;, wait);</span><br><span class="line">    <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">      func.call(<span class="keyword">this</span>, ...args)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手写一个-throttle"><a href="#手写一个-throttle" class="headerlink" title="手写一个 throttle"></a>手写一个 throttle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, timeFrame = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      <span class="keyword">if</span> (now - lastTime &gt;= timeFrame) &#123;</span><br><span class="line">          func.call(<span class="keyword">this</span>, ...args);</span><br><span class="line">          lastTime = now;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="what’s-more-rxjs"><a href="#what’s-more-rxjs" class="headerlink" title="what’s more: rxjs"></a>what’s more: rxjs</h4><p>截流和防抖很多时候是出现在事件中的，使用 rxjs 则可以使用 debounceTime 和 throttleTime：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fromEvent &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; debounceTime &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputEle = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>)</span><br><span class="line"><span class="keyword">const</span> inputs = fromEvent(inputEle, <span class="string">'input'</span>);</span><br><span class="line"><span class="keyword">const</span> result = inputs.pipe(debounceTime(<span class="number">1000</span>));</span><br><span class="line"><span class="comment">// 如果是节流可使用 throttleTime</span></span><br><span class="line"><span class="comment">// const result = inputs.pipe(throttleTime(1000));</span></span><br><span class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure><h4 id="rxjs-react"><a href="#rxjs-react" class="headerlink" title="rxjs + react"></a>rxjs + react</h4><p>如果是 react 中的事件需要防抖，那么可以通过 <code>Subject</code> 来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useEffect &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; Subject &#125; from &quot;rxjs&quot;;</span><br><span class="line">import &quot;rxjs&#x2F;add&#x2F;operator&#x2F;debounceTime&quot;;</span><br><span class="line"></span><br><span class="line">const value$ &#x3D; new Subject().debounceTime(300);</span><br><span class="line"></span><br><span class="line">export default function App() &#123;</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    const subscription &#x3D; value$.subscribe(console.log)</span><br><span class="line">      return () &#x3D;&gt; subscription.unsubscribe()</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  const onChange &#x3D; e &#x3D;&gt; &#123;</span><br><span class="line">    value$.next(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input onChange&#x3D;&#123;onChange&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当我们说到打包时，我们在说什么</title>
      <link href="/2020/07/31/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E5%88%B0%E6%89%93%E5%8C%85%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/31/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E5%88%B0%E6%89%93%E5%8C%85%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>从早期的 grunt (我接触前端开发的时候这个已经趋于没落) 到 gulp，再到如今的 webpack，rollup ，parcel，以及 snowpack，vite，如今的前端已经脱离了刀耕火种的时代，各种打包工具层出不穷。前端项目基本离不开打包这个过程。那么当我们说到打包（bundle）时，我们在说的是什么？</p><p>这里不对 webpack 或者这些打包工具的使用进行具体说明，本文想探究的是打包的本质。</p><a id="more"></a><h4 id="从模块化说起"><a href="#从模块化说起" class="headerlink" title="从模块化说起"></a>从模块化说起</h4><p>在没有模块化之前，前端开发时需要格外注意命名冲突以及文件之间的相互依赖，参考 <a href="https://github.com/seajs/seajs/issues/547#issue-11105836。" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/547#issue-11105836。</a></p><p>模块化实际上就是将程序分解成离散的功能块，使代码易于复用，维护和测试。如 less 中通过 @import 引入的样式，ES6 Module / CommonJs 引入的 Js 等都可以称为模块。</p><p>然而浏览器不支持模块化，因此我们需要一个打包工具，将代码中诸如 require, @import, import 进来的模块打包成一个或者多个文件(即 bundle)。</p><h4 id="打包的本质"><a href="#打包的本质" class="headerlink" title="打包的本质"></a>打包的本质</h4><p>参考 webpack 的定义：</p><blockquote><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p></blockquote><p>而至于这个过程中，对代码进行压缩，混淆等等则是锦上添花的功能。</p><h4 id="打包的过程"><a href="#打包的过程" class="headerlink" title="打包的过程"></a>打包的过程</h4><p>这里以 webpack 为例：</p><ol><li>初始化：从配置文件和 Shell 语句中读取并合并配置参数</li><li>开始编译：根据上面得到的参数初始化 Compiler，加载插件（Plugins），执行 Compiler 的 run 方法开始编译</li><li>入口文件：配置的 entry</li><li>从入口文件开始，针对不同的模块使用对应的 Loader 编译，再找到该模块所依赖的模块，递归这个步骤</li><li>完成编译：经过上述步骤后得到每个模块编译后的内容以及相互之间的依赖关系</li><li>输出：根据依赖关系，将模块组合成一个个代码块（Chunk），最后输出成文件</li></ol><h4 id="实现一个简易的打包工具"><a href="#实现一个简易的打包工具" class="headerlink" title="实现一个简易的打包工具"></a>实现一个简易的打包工具</h4><p>参考 <a href="https://github.com/ronami" target="_blank" rel="noopener">ronami</a>/<strong><a href="https://github.com/ronami/minipack" target="_blank" rel="noopener">minipack</a></strong> 实现一个支持 ES Module 的简易打包工具（这里不考虑循环依赖等情况）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">'babylon'</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'babel-traverse'</span>).default</span><br><span class="line"><span class="keyword">const</span> &#123; transformFromAst &#125; = <span class="built_in">require</span>(<span class="string">'babel-core'</span>)</span><br></pre></td></tr></table></figure><p>引入上述相关依赖：</p><ul><li>babylon：生成 AST（抽象语法树）</li><li>babel-traverse：来分析文件的依赖</li><li>transformFromAst：将 AST 转为 ES5</li></ul><p><strong>首先</strong> 定义一个函数用于读取文件的内容和依赖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取文件内容和依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAsset</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(filePath, <span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="comment">// 生成 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = babylon.parse(content, &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 当前文件的依赖关系</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = []</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    <span class="comment">// 当遇到导入的声明时，将其内容 push 到 dependencies 里</span></span><br><span class="line">    ImportDeclaration: <span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      dependencies.push(node.source.value)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 将 AST 转为 ES5</span></span><br><span class="line">  <span class="keyword">const</span> &#123; code &#125; = transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    presets: [<span class="string">'env'</span>],</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    filePath,</span><br><span class="line">    dependencies,</span><br><span class="line">    code,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Asset 接口如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Assets &#123;</span><br><span class="line"><span class="comment">// 文件路径</span></span><br><span class="line">  filePath: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 文件的依赖</span></span><br><span class="line">  dependencies: <span class="built_in">string</span>[];</span><br><span class="line">  <span class="comment">// 转为 ES5 后的文件内容</span></span><br><span class="line">  code: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 相对路径</span></span><br><span class="line">  relativePath?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，我们现在有个文件 entry.js ，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><p>运行 <code>createAsset(&#39;./entry.js&#39;)</code> 将会返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  filePath: <span class="string">'./entry.js'</span>,</span><br><span class="line">  dependencies: [ <span class="string">'./a.js'</span> ],</span><br><span class="line">  code: <span class="string">`"use strict";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _a = require("./a.js");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _a2 = _interopRequireDefault(_a);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(_a2.default);`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接着</strong>定义一个函数用于构建依赖关系图( dependency graph )：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建依赖关系图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGraph</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从入口文件开始</span></span><br><span class="line">  <span class="keyword">const</span> entryAsset = createAsset(entry);</span><br><span class="line">  <span class="comment">// 初始时，queue 中只有 entryAsset, 之后分析依赖关系，会将新的 Asset push 到 queue 中用于分析，直到分析完全部依赖</span></span><br><span class="line">  <span class="keyword">const</span> queue = [entryAsset]</span><br><span class="line">  <span class="comment">// 遍历所有文件依赖关系</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> asset <span class="keyword">of</span> queue) &#123;</span><br><span class="line">    <span class="comment">// 获得文件目录</span></span><br><span class="line">    <span class="keyword">const</span> dirname = path.dirname(asset.filePath)</span><br><span class="line">    <span class="comment">// 遍历当前文件依赖关系</span></span><br><span class="line">    asset.dependencies.forEach(<span class="function">(<span class="params">relativePath</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获得绝对路径</span></span><br><span class="line">      <span class="keyword">const</span> absolutePath = path.join(dirname, relativePath)</span><br><span class="line">      <span class="keyword">const</span> childAsset = createAsset(absolutePath)</span><br><span class="line">      childAsset.relativePath = relativePath</span><br><span class="line">      <span class="comment">// 将当前文件所依赖的文件的 Asset 也 push 到 queue 中用于遍历</span></span><br><span class="line">      queue.push(childAsset)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，在上面的基础上，有个 a.js 以及 b.js 文件, 运行 <code>createGraph</code>会返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">// createGraph('./entry.js')</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    filePath: <span class="string">'./entry.js'</span>,</span><br><span class="line">    dependencies: [ <span class="string">'./a.js'</span> ],</span><br><span class="line">    code: <span class="string">`"use strict";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _a = require("./a.js");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _a2 = _interopRequireDefault(_a);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(_a2.default);`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    filePath: <span class="string">'a.js'</span>,</span><br><span class="line">    dependencies: [ <span class="string">'./b.js'</span> ],</span><br><span class="line">    code: <span class="string">`"use strict";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Object.defineProperty(exports, "__esModule", &#123;</span></span><br><span class="line"><span class="string">  value: true</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _b = require("./b.js");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _b2 = _interopRequireDefault(_b);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var a = '1';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exports.default = a;`</span>,</span><br><span class="line">    relativePath: <span class="string">'./a.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    filePath: <span class="string">'b.js'</span>,</span><br><span class="line">    dependencies: [],</span><br><span class="line">    code: <span class="string">`"use strict";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Object.defineProperty(exports, "__esModule", &#123;</span></span><br><span class="line"><span class="string">  value: true</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">var b = '2';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exports.default = b;`</span>,</span><br><span class="line">    relativePath: <span class="string">'./b.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>最后</strong>实现一个打包函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> graph = createGraph(entry)</span><br><span class="line">  <span class="keyword">let</span> modules = <span class="string">''</span></span><br><span class="line">  <span class="comment">// 构建函数参数</span></span><br><span class="line">  graph.forEach(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> filePath = mod.relativePath || entry</span><br><span class="line">    <span class="comment">// 拼装成 modules</span></span><br><span class="line">    modules += <span class="string">`'<span class="subst">$&#123;filePath&#125;</span>': (</span></span><br><span class="line"><span class="string">      function (module, exports, require) &#123; <span class="subst">$&#123;mod.code&#125;</span> &#125;</span></span><br><span class="line"><span class="string">    ),`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 最终结果</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="string">`</span></span><br><span class="line"><span class="string">    (function(modules) &#123;</span></span><br><span class="line"><span class="string">// ast 转 es5 的代码是 commonjs 风格，而浏览器不支持 commonjs，因此自定义 require，以文件名作为 id</span></span><br><span class="line"><span class="string">      function require(id) &#123;</span></span><br><span class="line"><span class="string">        const module = &#123; exports : &#123;&#125; &#125;</span></span><br><span class="line"><span class="string">        modules[id](module, module.exports, require)</span></span><br><span class="line"><span class="string">        return module.exports</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">// 引入入口文件代码</span></span><br><span class="line"><span class="string">      require('<span class="subst">$&#123;entry&#125;</span>')</span></span><br><span class="line"><span class="string">    &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="comment">// 当生成的内容写入到文件中</span></span><br><span class="line">  fs.writeFileSync(<span class="string">'./bundle.js'</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出一个 IIFE：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;</span><br><span class="line">    modules[id](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, <span class="built_in">require</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./entry.js'</span>)</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">'./entry.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _a2 = _interopRequireDefault(_a)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(_a2.default)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'./a.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(exports, <span class="string">'__esModule'</span>, &#123;</span><br><span class="line">      value: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _b2 = _interopRequireDefault(_b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">    exports.default = a</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'./b.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(exports, <span class="string">'__esModule'</span>, &#123;</span><br><span class="line">      value: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">    exports.default = b</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-JS中的单例模式</title>
      <link href="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>此前项目有个 im  模块，需要用到 websocket。使用 websocket 需要建立连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initWs = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'wss://xxx.com'</span>);</span><br><span class="line">  ws.onopen(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'opened'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  ws.onmessage(<span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received evt'</span>, evt.data)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  <span class="keyword">return</span> ws</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们肯定不希望在每个用到 ws 的地方都重复初始化，即我们只需要一个 WebSocket 的实例。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wsA = <span class="keyword">new</span> SingleWs()</span><br><span class="line"><span class="keyword">const</span> wsB = <span class="keyword">new</span> SingleWs()</span><br><span class="line"><span class="comment">// 有没有办法使得:</span></span><br><span class="line">wsA <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsB <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsA === wsB</span><br></pre></td></tr></table></figure><p>那么要如何做到这一点？实际上就可以用到单例模式。下面列举几个实现的方法：</p><h4 id="使用全局变量"><a href="#使用全局变量" class="headerlink" title="使用全局变量"></a>使用全局变量</h4><p>这个可能是最容易想到的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.ws = <span class="built_in">window</span>.ws || initWs()</span><br></pre></td></tr></table></figure><p>将 ws 挂在 window 对象上，使用时也用 window.ws，显然这个解决方案有个问题是需要小心 window.ws 被覆盖。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包可以保持局部变量保持在内存中不被销毁，通过这个特性可以就可以避免污染全局变量，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SingleWs = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> ws = <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">// const initWs = ....</span></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   getWs() &#123;</span><br><span class="line">     <span class="keyword">if</span>(!ws) &#123;</span><br><span class="line">       ws = initWs()</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ws</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wsA = SingleWs.getWs()</span><br><span class="line"><span class="keyword">const</span> wsB = SingleWs.getWs()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(wsA <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsB <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsA === wsB)</span><br></pre></td></tr></table></figure><p>然而上面的写法也有一些缺点，如 getWs 可以被改写。</p><p>写法还可以进一步改写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SingleWs = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> ws = <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">// const initWs = .... </span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!ws) &#123;</span><br><span class="line">      ws = initWs()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 new 可以不写</span></span><br><span class="line"><span class="keyword">const</span> wsA = <span class="keyword">new</span> SingleWs()</span><br><span class="line"><span class="keyword">const</span> wsB = <span class="keyword">new</span> SingleWs()</span><br><span class="line"></span><br><span class="line">wsA <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsB <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsA === wsB</span><br></pre></td></tr></table></figure><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>通过模块化也能实现上述的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ws.js</span></span><br><span class="line"><span class="keyword">let</span> ws = <span class="literal">null</span></span><br><span class="line"><span class="comment">// const initWs = ....</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SingleWs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ws) &#123;</span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line">  &#125;</span><br><span class="line">  ws = initWs()</span><br><span class="line">  <span class="keyword">return</span> ws</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> SingleWs</span><br></pre></td></tr></table></figure><h4 id="通过-class-的静态属性来实现"><a href="#通过-class-的静态属性来实现" class="headerlink" title="通过 class 的静态属性来实现"></a>通过 class 的静态属性来实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleWs</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SingleWs.instance) &#123;</span><br><span class="line">      SingleWs.instance = <span class="keyword">this</span>.initWs()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SingleWs.instance</span><br><span class="line">  &#125;</span><br><span class="line">  initWs() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wsA = <span class="keyword">new</span> SingleWs()</span><br><span class="line"><span class="keyword">const</span> wsB = <span class="keyword">new</span> SingleWs()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(wsA <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsB <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsA === wsB)</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>JS 中的单例模式：</p><ol><li>实例化时，判断是否已经存在实例。</li><li>如果不存在，则初始化，并将生成的实例存储起来。</li><li>存储的方法可以是全局变量，闭包，模块以及类的静态属性。</li><li>如果已经存在实例，那么就直接返回该实例。</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】ReactHooks-并非黑魔法，本质是数组</title>
      <link href="/2020/07/26/%E3%80%90%E8%AF%91%E3%80%91ReactHooks-%E5%B9%B6%E9%9D%9E%E9%BB%91%E9%AD%94%E6%B3%95%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B0%E7%BB%84/"/>
      <url>/2020/07/26/%E3%80%90%E8%AF%91%E3%80%91ReactHooks-%E5%B9%B6%E9%9D%9E%E9%BB%91%E9%AD%94%E6%B3%95%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本文翻译自 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a>，该文章很好的阐释了 react hooks 原理，我将保持原文的意思进行翻译，如有自己感觉不清楚的地方将会在括号中注明。以下为翻译内容。</p><p>我是 hooks api 的忠实粉丝。然而 hooks 在使用时却有一些<a href="https://reactjs.org/docs/hooks-rules.html" target="_blank" rel="noopener">奇怪的约束</a>。在这里，我给尝试去理解这些规则由来的人提供一个了模型，用于思考如何去使用这些新 api。</p><a id="more"></a><h4 id="hooks-的规则"><a href="#hooks-的规则" class="headerlink" title="hooks 的规则"></a>hooks 的规则</h4><p>在 <a href="https://reactjs.org/docs/hooks-rules.html" target="_blank" rel="noopener">hooks proposal documentation</a>  的提纲中，React 核心团队规定了两条开发者在使用 hooks 时需要遵守的主要规则：</p><ul><li>不要在循环，条件或者是嵌套函数中使用 hooks</li><li>只能在 React Functions 中才能使用 hooks</li></ul><p>后者我认为是显而易见的。要将行为附加到函数式组件上，你需要能够以某种方式将该行为与组件关联起来。（原文为： To attach behaviour to a functional component you need to be able to associate that behaviour with the component somehow. 不太理解作者想表达的意思）</p><p>前者我认为会比较让人困惑，因为像这样使用 api 可能看起来不太自然。而这正是我今天想要探讨的内容。</p><h4 id="hooks-的状态管理都是基于数组"><a href="#hooks-的状态管理都是基于数组" class="headerlink" title="hooks 的状态管理都是基于数组"></a>hooks 的状态管理都是基于数组</h4><p>为了更清晰地理解心智模型，让我们来看一下如何实现一个简单的 hooks api。</p><p><strong>注意这只是 API 的一种可能的实现方式及猜想，用于让你理解，而非 API 真正的内部实现方式</strong></p><h4 id="我们如何实现-useState"><a href="#我们如何实现-useState" class="headerlink" title="我们如何实现 useState?"></a>我们如何实现 <code>useState</code>?</h4><p>让我们打开一个实例来演示如何实现一个 state hook。</p><p>首先，我们定义一个组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function RenderFunctionComponent() &#123;</span><br><span class="line">  const [firstName, setFirstName] &#x3D; useState(&quot;Rudi&quot;);</span><br><span class="line">  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Hooks api 背后的思想是，你可以用 hook 函数返回的数组的第二个元素作为 setter 方法，这个 setter 方法可以控制被 hook 管理的状态。</p><h4 id="那么-React-是如何做到这个的呢？"><a href="#那么-React-是如何做到这个的呢？" class="headerlink" title="那么 React 是如何做到这个的呢？"></a>那么 React 是如何做到这个的呢？</h4><p>让我们看看这个在 React 内部是如何运作的。以下内容将在特定组件的上下文中运行。这就是说数据存储在要渲染的组件的上一层。这个 state 不与其他组件共享，但是维护在一个可以用于该组件后续渲染的作用域内。（原文：The following would work within the execution context for rendering a particular component. That means that the data stored here lives one level outside of the component being rendered. This state is not shared with other components but it is maintained in a scope that is accessible to subsequent rendering of the specific component）</p><ol><li><p>初始化</p><p>创建两个空数组：<code>setter</code> 和 <code>state</code></p><p>将指针设置为 0</p><p><img src="https://miro.medium.com/max/1280/1*LAZDuAEm7nbcx0vWVKJJ2w.png" alt="Image for post"></p></li></ol><ol start="2"><li><p>首次渲染</p><p>首次运行该组件。</p><p>每次调用 <code>useState</code> ，如果是首次运行，则 push 一个 setter 方法（绑定到指针的位置）到 setters 数组中，并且 push 一些 state 到 state 数组中。</p><p><img src="https://miro.medium.com/max/1260/1*8TpWnrL-Jqh7PymLWKXbWg.png" alt="Image for post"></p></li><li><p>后续渲染</p><p>每次后续渲染，指针将被重置，然后从各个数组中读取对应的值。</p><p><img src="https://miro.medium.com/max/1254/1*qtwvPWj-K3PkLQ6SzE2u8w.png" alt="Image for post"></p></li><li><p>事件处理</p><p>每一个 setter 都保存一个对应的指针位置的引用，因此触发任意一个 <code>setter</code> 都可以修改 state 数组中对应指针位置的 state。</p><p><img src="https://miro.medium.com/max/1260/1*3L8YJnn5eV5ev1FuN6rKSQ.png" alt="Image for post"></p></li></ol><h4 id="简单的实现-And-the-naive-implementation"><a href="#简单的实现-And-the-naive-implementation" class="headerlink" title="简单的实现(And the naive implementation)"></a>简单的实现(And the naive implementation)</h4><p>下面是简单的代码演示：</p><p><strong>注意：这不代表 hooks 的实际实现，但是应该能给你一个理解 hooks 工作原理的思路。这就是我为什么使用块级变量的原因（原文： That is why we are using module level vars etc）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">let state &#x3D; [];</span><br><span class="line">let setters &#x3D; [];</span><br><span class="line">let firstRun &#x3D; true;</span><br><span class="line">let cursor &#x3D; 0;</span><br><span class="line"></span><br><span class="line">function createSetter(cursor) &#123;</span><br><span class="line">  return function setterWithCursor(newVal) &#123;</span><br><span class="line">    state[cursor] &#x3D; newVal;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; This is the pseudocode for the useState helper</span><br><span class="line">export function useState(initVal) &#123;</span><br><span class="line">  if (firstRun) &#123;</span><br><span class="line">    state.push(initVal);</span><br><span class="line">    setters.push(createSetter(cursor));</span><br><span class="line">    firstRun &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const setter &#x3D; setters[cursor];</span><br><span class="line">  const value &#x3D; state[cursor];</span><br><span class="line"></span><br><span class="line">  cursor++;</span><br><span class="line">  return [value, setter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Our component code that uses hooks</span><br><span class="line">function RenderFunctionComponent() &#123;</span><br><span class="line">  const [firstName, setFirstName] &#x3D; useState(&quot;Rudi&quot;); &#x2F;&#x2F; cursor: 0</span><br><span class="line">  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;); &#x2F;&#x2F; cursor: 1</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Richard&quot;)&#125;&gt;Richard&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; This is sort of simulating Reacts rendering cycle</span><br><span class="line">function MyComponent() &#123;</span><br><span class="line">  cursor &#x3D; 0; &#x2F;&#x2F; resetting the cursor</span><br><span class="line">  return &lt;RenderFunctionComponent &#x2F;&gt;; &#x2F;&#x2F; render</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(state); &#x2F;&#x2F; Pre-render: []</span><br><span class="line">MyComponent();</span><br><span class="line">console.log(state); &#x2F;&#x2F; First-render: [&#39;Rudi&#39;, &#39;Yardley&#39;]</span><br><span class="line">MyComponent();</span><br><span class="line">console.log(state); &#x2F;&#x2F; Subsequent-render: [&#39;Rudi&#39;, &#39;Yardley&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; click the &#39;Fred&#39; button</span><br><span class="line"></span><br><span class="line">console.log(state); &#x2F;&#x2F; After-click: [&#39;Fred&#39;, &#39;Yardley&#39;]</span><br></pre></td></tr></table></figure><h4 id="为什么顺序很重要？"><a href="#为什么顺序很重要？" class="headerlink" title="为什么顺序很重要？"></a>为什么顺序很重要？</h4><p>现在如果在一个生命周期里，我们基于外部的因素或者组件状态改变了 hooks 的顺序，将会发生什么事情？</p><p>让我们试试看 react 不建议我们做的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let firstRender &#x3D; true;</span><br><span class="line"></span><br><span class="line">function RenderFunctionComponent() &#123;</span><br><span class="line">  let initName;</span><br><span class="line">  </span><br><span class="line">  if(firstRender)&#123;</span><br><span class="line">    [initName] &#x3D; useState(&quot;Rudi&quot;);</span><br><span class="line">    firstRender &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line">  const [firstName, setFirstName] &#x3D; useState(initName);</span><br><span class="line">  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在一个条件语句中使用了 <code>useState</code>，让我们看看造成了什么样的破坏：</p><h4 id="坏组件的第一次渲染"><a href="#坏组件的第一次渲染" class="headerlink" title="坏组件的第一次渲染"></a>坏组件的第一次渲染</h4><p><img src="https://miro.medium.com/max/1270/1*C4IA_Y7v6eoptZTBspRszQ.png" alt="Image for post"></p><p>在这个时候，我们的实例变量 <code>firstName</code> 和 <code>lastName</code> 指向的正确的数据，但是我们看看第二次渲染发生了什么：</p><h4 id="坏组件的第二次渲染"><a href="#坏组件的第二次渲染" class="headerlink" title="坏组件的第二次渲染"></a>坏组件的第二次渲染</h4><p><img src="https://miro.medium.com/max/1274/1*aK7jIm6oOeHJqgWnNXt8Ig.png" alt="Image for post"></p><p>现在我们的 state 存储出现异常， <code>firstName</code> 和 <code>lastName</code> 都指向 “Rudi”。上述明显错误的操作给了我们一个思路：为什么 hooks 要如此规定。</p><blockquote><p>The React team are stipulating the usage rules because not following them will lead to inconsistent data</p></blockquote><h4 id="想想-hooks-操作一系列的数组，那么你就不会打破规则了（Think-about-hooks-manipulating-a-set-of-arrays-and-you-wont-break-the-rules）"><a href="#想想-hooks-操作一系列的数组，那么你就不会打破规则了（Think-about-hooks-manipulating-a-set-of-arrays-and-you-wont-break-the-rules）" class="headerlink" title="想想 hooks 操作一系列的数组，那么你就不会打破规则了（Think about hooks manipulating a set of arrays and you wont break the rules）"></a>想想 hooks 操作一系列的数组，那么你就不会打破规则了（Think about hooks manipulating a set of arrays and you wont break the rules）</h4><p>现在应该能很清晰理解为什么不能在条件或者循环语句中使用 <code>use</code> hook 了：因为我们使用了指针指向了数组，如果在 render 的时候改变了顺序，那么指针就不能对应正确的数据，所以调用 use 也不会指向正确的数据和 setter。</p><p>因此，诀窍就是将 hooks 想像成用恒定的指针来管理一系列数组。如果能做到这个，那么一切就能按预期进行。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>希望我已经就如何思考 hooks api 的工作原理指出了一个清晰的心智模型。（后面就偷个懒不翻译了，基本是上述观点的重复强调。）</p><p>Hopefully I have laid out a clearer mental model for how to think about what is going on under the hood with the new hooks API. Remember the true value here is being able to group concerns together so being careful about order and using the hooks API will have a high payoff.</p><p>Hooks is an effective plugin API for React Components. There is a reason why people are excited about this and if you think about this kind of model where state exists as a set of arrays then you should not find yourselves breaking the rules around their usage.</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端入坑flutter</title>
      <link href="/2020/07/24/%E5%89%8D%E7%AB%AF%E5%85%A5%E5%9D%91flutter/"/>
      <url>/2020/07/24/%E5%89%8D%E7%AB%AF%E5%85%A5%E5%9D%91flutter/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>踩过 RN 的坑之后越发想尝试学习下 flutter 的开发，本文用于记录下开发过程中的问题与思考，本来是写在 notion 里的，最近 notion 无法打开，故记录于此。</p><a id="more"></a><h4 id="Flutter为什么选择了-Dart而不是-JavaScript"><a href="#Flutter为什么选择了-Dart而不是-JavaScript" class="headerlink" title="Flutter为什么选择了 Dart而不是 JavaScript"></a>Flutter为什么选择了 Dart而不是 JavaScript</h4><p>以下内容引用自 <a href="https://book.flutterchina.club/chapter1/flutter_intro.html" target="_blank" rel="noopener">flutter 开发实战</a>。</p><p>首先要了解两个概念：JIT和AOT。<br>目前，程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为<strong>AOT</strong> （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为<strong>JIT</strong>（Just-in-time）即“即时编译”。AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。在此，读者不必纠结于概念，概念就是为了传达精神而发明的，只要读者能够理解其原理即可，得其神忘其形。<br>JavaScript为脚本语言，执行时需要JIT(Just In Time)，执行效率和AOT(Ahead Of Time)代码仍有差距。<br>Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。<br>但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。</p><h4 id="网页开发"><a href="#网页开发" class="headerlink" title="网页开发"></a>网页开发</h4><p>现在 flutter 已经支持 web 了，切换到 beta ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 切换 channel</span><br><span class="line">flutter channel beta</span><br><span class="line">// 更新 sdk</span><br><span class="line">flutter upgrade</span><br><span class="line">// 安装依赖</span><br><span class="line">flutter packages get</span><br><span class="line">// 启动开发模式</span><br><span class="line">flutter run -d chrome</span><br></pre></td></tr></table></figure><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><p>过程不提，文档讲的比较清晰了，注意配置国内的源即可。</p><h4 id="项目结构与命名规范"><a href="#项目结构与命名规范" class="headerlink" title="项目结构与命名规范"></a>项目结构与命名规范</h4><p>dart 的文件名是用下划线连接的，源文件在 lib 目录下，main.dart 为入口文件, 从 main 函数开始执行，下划线开头的变量为私有变量</p><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>dart 里如何导入本地文件的呢？和引用第三方的库的用法一样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:&#123;项目名&#125;/&#123;文件名&#125;'</span>;</span><br></pre></td></tr></table></figure><p>其中成员变量自动导出，那么如何防止命名冲突？:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:&#123;项目名&#125;/&#123;文件名&#125;'</span> <span class="keyword">as</span> MyModule;</span><br></pre></td></tr></table></figure><p>通过 as 来指定包名，此时要使用内部成员就需要 MyModule.xxx。</p><p>也可以屏蔽某些变量导出：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:&#123;项目名&#125;/&#123;文件名&#125;'</span> <span class="keyword">hide</span> MyVar;</span><br></pre></td></tr></table></figure><h4 id="Material-组件库"><a href="#Material-组件库" class="headerlink" title="Material 组件库"></a>Material 组件库</h4><p><a href="https://flutterchina.club/widgets/material/" target="_blank" rel="noopener">https://flutterchina.club/widgets/material/</a></p><h4 id="💀-Divider-在-web-需要传-thickness"><a href="#💀-Divider-在-web-需要传-thickness" class="headerlink" title="💀 Divider 在 web 需要传 thickness"></a>💀 Divider 在 web 需要传 thickness</h4><p>否则不渲染， issue 如下： <a href="https://github.com/flutter/flutter/issues/46339" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/46339</a></p><h4 id="💀-BottomNavigationBar"><a href="#💀-BottomNavigationBar" class="headerlink" title="💀 BottomNavigationBar"></a>💀 BottomNavigationBar</h4><p>如果超过 3 个 items，背景会变白，原因是超过 3 个 BottomNavigationBar 的 type 会变成 BottomNavigationBarType.shifting 类型，详情见： <a href="https://github.com/flutter/flutter/issues/13642#issuecomment-371875044" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/13642#issuecomment-371875044</a></p><p>解决的办法是设置 type 属性为 fixed。</p><h4 id="进程锁死"><a href="#进程锁死" class="headerlink" title="进程锁死"></a>进程锁死</h4><p>遇到控制台提示，Waiting for another flutter command to release the startup lock… 可以简单粗暴杀进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -9 dart</span><br></pre></td></tr></table></figure><h4 id="运行所有的-flutter-命令都被挂起时"><a href="#运行所有的-flutter-命令都被挂起时" class="headerlink" title="运行所有的 flutter 命令都被挂起时"></a>运行所有的 flutter 命令都被挂起时</h4><p>删除 <code>flutter/bin/cache</code>，然后重新运行 <code>flutter doctor -v</code></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见的安全问题汇总</title>
      <link href="/2020/07/23/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/23/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近安全部门的小伙伴提了一个前端安全的漏洞，想到前端开发过程中有时候往往追求开发效率，忽略掉一些安全问题，以下简单总结一些自己遇到过的以及一些常见的攻击手段，以自查自省。</p><a id="more"></a><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>回到安全部门提出的漏洞，场景还原如下：<br>这是一个老项目，展示文章用，页面路由为 <a href="http://xxx/article/:id?these-are-queries，node" target="_blank" rel="noopener">http://xxx/article/:id?these-are-queries，node</a> 层收到这个 url 后，返回返回该文章 html，内容则包括了【推荐文章】， 而推荐文章的链接则是根据 url 的值来的，仅变化 id。此时如果在 url 上的 query 上构造一段恶意脚本，然后引导用户打开，那么用户打开页面后就会运行该恶意脚本。<br>上述正是一个典型的 XSS 攻击，定义如下：</p><blockquote><p>XSS是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p></blockquote><p>XSS 的本质是信任了某些不安全的输入，导致恶意代码混入正常代码，进而发生的攻击行为。常见的不安全输入有：</p><ol><li>上面提到的 url 参数，这种需要诱导用户取点击</li><li>用户输入的内容，比如用户发表评论</li><li>第三方的链接等</li></ol><p>防范的方法通常是：对用户输入内容和服务端返回内容进行过滤和转译。</p><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>CSRF 攻击常见的过程如下：</p><ol><li>用户登录你的网站，产生登录凭证，如 cookie</li><li>用户被<strong>诱导</strong>登录到恶意网站</li><li>恶意网站携带刚刚在浏览器产生的凭证向你的服务器发送一个恶意请求</li><li>你的服务器无法识别是否恶意请求，请求完成，用户受害。</li></ol><p>与上面提到的 XSS 攻击有个明显的区别在于：CSRF 攻击发生在恶意网站，而不是被攻击的网站。而这也使得攻击者并不能获取到受害者的登录凭证，仅仅只能使用。<br>防范的方法通常是：</p><ol><li>请求 url 添加 token 或者是在 http 请求头自定义属性进行验证</li><li>同源检测，通过解析 请求头中的 referer 判断请求来源</li><li>Samesite，Google 起草了一份草案来改进 HTTP 协议，为 Set-Cookie 响应头新增 Samesite 属性，用于标明 Cookie 是否能作用于其他网站，目前兼容性还不是很好。</li></ol><h4 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h4><p>当我们使用 iframe 加载第三方网站时，第三方网站可以对我们的网站执行恶意操作，如操作DOM，加载 js 等。<br>防范的方法是通过设置 sandbox 属性控制 iframe 的操作权限。</p><h4 id="opener"><a href="#opener" class="headerlink" title="opener"></a>opener</h4><p>我们在通常通过以下写法在 新 tab 下打开链接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;a target=<span class="string">'_blank'</span> href=<span class="string">'new-site.com'</span>&gt;</span><br><span class="line"><span class="number">2.</span> <span class="built_in">window</span>.open(<span class="string">'new-site.com'</span>)</span><br></pre></td></tr></table></figure><p>上述两种写法的问题在于， <code>new-site.com</code> 是可以通过 <code>window.opener</code> 来拿到源页面的 <code>window</code> 对象，进而进行恶意操作。<br>防范的方法通常是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;a target=<span class="string">"_blank"</span> href=<span class="string">"new-site.com"</span> rel=<span class="string">"noopener noreferrer nofollow"</span>&gt;a标签跳转url&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">2. function openurl(url) &#123;</span></span><br><span class="line"><span class="regexp">    var newTab = window.open();</span></span><br><span class="line"><span class="regexp">    newTab.opener = null;</span></span><br><span class="line"><span class="regexp">    newTab.location = url;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul><li><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener">前端安全系列（一）：如何防止XSS攻击？</a></p></li><li><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener">前端安全系列（二）：如何防止CSRF攻击？</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN 避坑指北</title>
      <link href="/2020/07/21/RN%20%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97/"/>
      <url>/2020/07/21/RN%20%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p>记录平时开发 rn 时遇到的问题，特指 0.59 版本，不同版本可能情况不同，仅供参考。</p><a id="more"></a><h5 id="一像素问题"><a href="#一像素问题" class="headerlink" title="一像素问题"></a>一像素问题</h5><p>rn 解决一像素很简单，只需要  <code>StyleSheet.hairlineWidth</code> 即可解决。</p><h5 id="TextInput-组件"><a href="#TextInput-组件" class="headerlink" title="TextInput  组件"></a>TextInput  组件</h5><p>自带内边距，多行文字时文字居中展示，想要消除需要设置样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 文字向上对齐</span><br><span class="line">textAlignVertical: 'top'</span><br><span class="line">// 消除内边距</span><br><span class="line"><span class="selector-tag">padding</span>: 0</span><br></pre></td></tr></table></figure><p>Placeholder 在 ios 和 android 下默认颜色表现不一致，可以通过 <code>placeholderTextColor</code>  属性进行设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">placeholderTextColor=<span class="string">"#CCCCCC"</span></span><br></pre></td></tr></table></figure><h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><p>因为设计理念的问题，android 下几乎无法实现和 ios 一致的阴影效果。而 flutter 基于 skia 引擎渲染，应该会有比较好的表现？有空尝试下。 🤔</p><h5 id="border-虚线"><a href="#border-虚线" class="headerlink" title="border 虚线"></a>border 虚线</h5><p>border 虚线也是一个比较棘手的问题, android 上实测无效，详情看 <a href="https://github.com/facebook/react-native/issues/17251" target="_blank" rel="noopener">issue</a>。解决方案是循环一个 pattern 然后 overhidden 掉，又多了一个让我想尝试 flutter 的理由 😂</p><h5 id="多行文字"><a href="#多行文字" class="headerlink" title="多行文字"></a>多行文字</h5><p>多行文字在 android 机型下有可能会出现高度不够导致文字被截掉的问题，解决方法：设置  <code>lineHeight</code></p><h5 id="实现不同字号的文字底部对齐"><a href="#实现不同字号的文字底部对齐" class="headerlink" title="实现不同字号的文字底部对齐"></a>实现不同字号的文字底部对齐</h5><p>例如 ¥500 想要 ¥ 字号小一点，而 500 字号大一点，但是需要底部对齐，则可以用 Text 包裹起来，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text&gt;</span><br><span class="line">  &lt;Text style&#x3D;&#123;&#123; fontSize: 12 &#125;&#125;&gt;¥&lt;&#x2F;Text&gt;</span><br><span class="line">  &lt;Text style&#x3D;&#123;&#123; fontSize: 20 &#125;&#125;&gt;500&lt;&#x2F;Text&gt;</span><br><span class="line">&lt;&#x2F;Text&gt;</span><br></pre></td></tr></table></figure><h5 id="Text-组件样式继承"><a href="#Text-组件样式继承" class="headerlink" title="Text 组件样式继承"></a>Text 组件样式继承</h5><p>众所周知，css 如果想设置默认的全局样式相当简单，比如字体颜色默认为 ‘#323232’ , 只要在 body 上设置一下 <code>color: #323232</code> 即可 ，然而对于 RN 来说则有两种解决方案：</p><ol><li><p>将原生 Text 替换成自定义 Text 组件（官方推荐）</p><blockquote><p>The recommended way to use consistent fonts and sizes across your application is to create a component <code>MyAppText</code> that includes them and use this component across your app</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123; TextProps, StyleSheet, Text &#125; from &#39;react-native&#39;;</span><br><span class="line"></span><br><span class="line">const styles &#x3D; StyleSheet.create(&#123;</span><br><span class="line">  defaultStyle: &#123;</span><br><span class="line">    color: &#39;#323232&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default function CustomText(props: TextProps &amp; &#123; children?: any &#125;) &#123;</span><br><span class="line">  const &#123; style, ...restProps &#125; &#x3D; props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Text style&#x3D;&#123;[styles.defaultStyle, style]&#125; &#123;...restProps&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;&#x2F;Text&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参考 <a href="https://github.com/Ajackster" target="_blank" rel="noopener">Ajackster</a>/<strong><a href="https://github.com/Ajackster/react-native-global-props" target="_blank" rel="noopener">react-native-global-props</a></strong> 的实现，在项目入口位置，修改组件的 render 方法。</p></li></ol><p>方案二虽然方便，但不是官方解法，万一有坑就 GG 了。而方案一如果是已有项目，则需要批量修改代码。<br>这里顺便提一下在 vscode 里批量替换的方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 将正则，大小写，全匹配 三个按钮点亮</span><br><span class="line">find: Text(,|\s)(.*react-nativ<span class="string">e';)</span></span><br><span class="line"><span class="string">replace: $2\nimport Text from '</span>Your/<span class="type">Text</span><span class="string">';</span></span><br></pre></td></tr></table></figure><p>一开始我是这么写的，只考虑到了单行，结果下面这种情况没有替换掉：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line"><span class="built_in">  StyleSheet,</span></span><br><span class="line"><span class="built_in">  ViewStyle,</span></span><br><span class="line"><span class="built_in">  View,</span></span><br><span class="line"><span class="built_in">  Text,</span></span><br><span class="line"><span class="built_in">  Image,</span></span><br><span class="line"><span class="built_in">  TouchableOpacity,</span></span><br><span class="line">&#125; from 'react-native'<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>后面换成 <code>\sText[,|\s]\n?([\s\S]*&#39;react-native&#39;;)</code> 在浏览器里可以匹配上，但是 vscode 无法匹配 🤔。 最后简单写个脚本补全上面的漏网之鱼:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> replace = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    glob(<span class="string">'src/**/*.tsx'</span>, &#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> reg = <span class="regexp">/\sText[,|\s]\n?([\s\S]*'react-native';)/</span>;</span><br><span class="line">      files.forEach(<span class="keyword">async</span> (file) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> content = <span class="keyword">await</span> util.promisify(fs.readFile)(file, <span class="string">'utf8'</span>);</span><br><span class="line">        <span class="keyword">const</span> newContent = content.replace(reg, (m, p1) =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">` <span class="subst">$&#123;p1.trim()&#125;</span></span></span><br><span class="line"><span class="string">import Text from '@/components/Text';`</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">await</span> util.promisify(fs.writeFile)(file, newContent, <span class="string">'utf8'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">replace();</span><br></pre></td></tr></table></figure><p>🤔 上面 CustomText 的写法有一个问题，即嵌套 Text 的样式如果是自定义组件中默认的样式，将不会被继承:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;&#123; color: &#39;red&#39; &#125;&#125;&gt;</span><br><span class="line">  &lt;Text&gt;red&lt;&#x2F;Text&gt;</span><br><span class="line">  &lt;Text&gt;red&lt;&#x2F;Text&gt;</span><br><span class="line">&lt;&#x2F;Text&gt;</span><br><span class="line"></span><br><span class="line">&lt;CustomText style&#x3D;&#123;&#123; color: &#39;red&#39; &#125;&#125;&gt;</span><br><span class="line">  &lt;CustomText&gt;not red&lt;&#x2F;Text&gt;</span><br><span class="line">  &lt;CustomText&gt;not red&lt;&#x2F;Text&gt;</span><br><span class="line">&lt;&#x2F;CustomText&gt;</span><br></pre></td></tr></table></figure><p>改良版： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Children, isValidElement, cloneElement &#125; from &#39;react&#39;;</span><br><span class="line">import &#123; TextProps, StyleSheet, Text &#125; from &#39;react-native&#39;;</span><br><span class="line"></span><br><span class="line">const styles &#x3D; StyleSheet.create(&#123;</span><br><span class="line">  defaultStyle: &#123;</span><br><span class="line">    color: &#39;#323232&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default function CustomText(</span><br><span class="line">  props: TextProps &amp; &#123; children?: any; useDefaultStyle?: boolean &#125;,</span><br><span class="line">) &#123;</span><br><span class="line">  const &#123; style, useDefaultStyle &#x3D; true, ...restProps &#125; &#x3D; props;</span><br><span class="line">  const newStyle &#x3D; useDefaultStyle ? [styles.defaultStyle, style] : style;</span><br><span class="line"></span><br><span class="line">  const childrenWithProps &#x3D; Children.map(props.children, (child) &#x3D;&gt; &#123; </span><br><span class="line">   if (isValidElement(child)) &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果子元素是个组件，则子组件不使用默认 style</span><br><span class="line">      return cloneElement(child as React.ReactElement&lt;any&gt;, &#123;</span><br><span class="line">        useDefaultStyle: false,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return child;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Text style&#x3D;&#123;newStyle&#125; &#123;...restProps&#125;&gt;</span><br><span class="line">      &#123;childrenWithProps&#125;</span><br><span class="line">    &lt;&#x2F;Text&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view" target="_blank" rel="noopener">react-native-scrollable-tab-view</a></p><p><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view" target="_blank" rel="noopener">react-native-scrollable-tab-view</a> 组件作为 ScrollView 的子组件时不可用，会出现 tab 选中不一致，tab content 无法撑开的现象，详情看：<a href="https://github.com/ptomasroos/react-native-scrollable-tab-view/issues/982" target="_blank" rel="noopener">https://github.com/ptomasroos/react-native-scrollable-tab-view/issues/982</a></p></li></ul><p>未完待续～</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次搭建 react 项目遇到的坑</title>
      <link href="/2020/07/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%20react%20%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2020/07/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%20react%20%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>电商项目需要搭建一个 h5 项目。这里简单记录一下搭建过程遇到的坑，作为总结。</p><a id="more"></a><p>ui 框架：为了统一 ui 框架，因此选择使用 antd-mobile。<br>打包：parceljs 在此前的项目中已经使用过很多次了，打包速度较 cra 快，且配置简单，因此拟用 parcel。<br>ts：多人项目还是上 ts，没什么好说的。<br>很快就搭建好 demo，接着就开始遇到一些问题。</p><h5 id="antd-mobile-按需加载"><a href="#antd-mobile-按需加载" class="headerlink" title="antd-mobile 按需加载"></a>antd-mobile 按需加载</h5><p>antd-mobile 按需加载推荐使用 <a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .babelrc or babel-loader option</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"import"</span>, &#123; <span class="attr">"libraryName"</span>: <span class="string">"antd-mobile"</span>, <span class="attr">"style"</span>: <span class="string">"css"</span> &#125;] <span class="comment">// `style: true` 会加载 less 文件</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此前 parcel 实际上内置支持了 ts，直接转成 es5 了，因此此前没有额外再配置 babel。<br>🤔 babel-plugin-import 只支持 es6 module 写法的代码，看来需要先把 ts 转成 es6 然后在通过 babel 转成 es5， 没问题，安排～ 于是：</p><ol><li><p>新增 .babelrc</p></li><li><p>修改 tsconfig 的 module 为 <code>es6</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"ES6"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目启动，没问题。但是 vscode 开始报错：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">&#x2F;&#x2F; Module &#39;&quot;&#x2F;node_modules&#x2F;@types&#x2F;react&#x2F;index&quot;&#39; can only be default-imported using the &#39;allowSyntheticDefaultImports&#39; flag</span><br></pre></td></tr></table></figure><p>根本原因是由于 react 导出如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'react.development.js'</span>)</span><br></pre></td></tr></table></figure><p>而非</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.default = <span class="built_in">require</span>(<span class="string">'react.development.js'</span>)</span><br></pre></td></tr></table></figure><p>Babel 会在 commonjs 格式添加 default 导出，那我们要做的就是让 ts 不要提示这种类型的报错：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🤔 不过为什么一开始 parcel 不会报错呢？</p><p>接下来路由动态引入组件开始报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Suspense, lazy &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">const List &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;modules&#x2F;List&#39;))</span><br><span class="line">&#x2F;&#x2F; Dynamic imports are only supported when the &#39;--module&#39; flag is set to &#39;es2020&#39;, &#39;esnext&#39;, &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, or &#39;umd&#39;.</span><br></pre></td></tr></table></figure><p>看来 <code>es6</code> 是不支持 import() 语法, 那好办，将 module 改成 <code>esnext</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"ESNext"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来引入 anti-mobile 组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; List &#125; <span class="keyword">from</span> <span class="string">'antd-mobile'</span></span><br><span class="line"><span class="comment">// Cannot find module 'antd-mobile' or its corresponding type declarations.</span></span><br></pre></td></tr></table></figure><p>此时提示找不到对应的模块声明， 此时我的内心是崩溃的，看起来应该是模块解析路径不对，因此在 tsconfig 中显式配置 <code>moduleResolution</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"moduleResolution"</span>: <span class="string">"Node"</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不再报错了，看看 ts 文档的解释吧，ts 共有两种可用的模块解析策略：<a href="https://www.tslang.cn/docs/handbook/module-resolution.html#node" target="_blank" rel="noopener">Node</a>和<a href="https://www.tslang.cn/docs/handbook/module-resolution.html#classic" target="_blank" rel="noopener">Classic</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> === <span class="string">"AMD"</span> or <span class="string">"System"</span> or <span class="string">"ES6"</span> ? <span class="string">"Classic"</span> : <span class="string">"Node"</span></span><br></pre></td></tr></table></figure><p>🤔 按理说 module 为 esnext 的话岂不是应该按 node 策略解析？但是目前看来似乎不是这样的？</p><h5 id="配置-antd-mobile-主题"><a href="#配置-antd-mobile-主题" class="headerlink" title="配置 antd-mobile 主题"></a>配置 antd-mobile 主题</h5><p>接下来需要配置主题，anti-mobile 推荐使用 <a href="http://lesscss.org/usage/#using-less-in-the-browser-modify-variables" target="_blank" rel="noopener">modifyVars</a> 来配置主题。<br>将 .babelrc 改成做一下调整：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [<span class="string">"import"</span>, &#123;<span class="string">"libraryName"</span>: <span class="string">"antd-mobile"</span>, <span class="string">"style"</span>: <span class="literal">true</span>&#125;],</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照 webpack 的经验，此时需要开启 <code>javascriptEnabled: true</code>问题来了 parcel 内置支持 less ，那我们要在哪里去配置 less 呢？根据 <a href="https://github.com/parcel-bundler/parcel/issues/907" target="_blank" rel="noopener">issue</a> 提到可以用 .lessrc 文件来配置，但是我经过尝试发现其实是无效的。。<br>至此基本放弃 parcel。parcel 在快速搭建实验性项目时确实有一定的优势，不过生态确实不如 webpack，由此转向使用 create-react-app</p><h5 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h5><p>使用 cra 很快也建好 demo，解决如何让 cra 创建的项目支持 less ，这个简单：<br>通过 <code>customize-cra</code> 提供的 <code>addLessLoader</code> 方法即可，同时也提供了 <code>fixBabelImports</code> 可以很方便的添加 babel-plugin-import 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; override, fixBabelImports, addLessLoader &#125; = <span class="built_in">require</span>(<span class="string">'customize-cra'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = override(</span><br><span class="line">  fixBabelImports(<span class="string">'import'</span>, &#123;</span><br><span class="line">    libraryName: <span class="string">'antd-mobile'</span>,</span><br><span class="line">    style: <span class="literal">true</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  addLessLoader(&#123;</span><br><span class="line">    lessOptions: &#123;</span><br><span class="line">      javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">      modifyVars: &#123;</span><br><span class="line">        <span class="string">'@brand-primary'</span>: <span class="string">'#ff74b9'</span>,</span><br><span class="line">        <span class="string">'brand-primary-tap'</span>: <span class="string">'#ff9cca'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><p>接着是配置路径别名遇到的问题，通过 <code>customize-cra</code> 提供的 <code>addWebpackAlias</code> 可以配置别名，但是 typescript 一直无法解析对应别名，那么应该只需要配置好 ts 的 paths 就行了吧：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"baseUrl"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="attr">"paths"</span>: &#123;</span><br><span class="line">      <span class="attr">"@/*"</span>: [<span class="string">"./src/*"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vscode 不再报错了,接下来就是见证奇迹的时刻了<code>npm run start</code>：<br>控制台显示 <code>- compilerOptions.paths must not be set (aliased imports are not supported)</code> 并且 cra 会自动把 tscongfig 中的 paths 移除掉 😂<br>根据 <a href="https://github.com/timarney/react-app-rewired/issues/375" target="_blank" rel="noopener">issue</a>，使用将 baseUrl 和 paths 的配置移动到单独的文件后，在 tsconfig 里通过 extends 的方式继承，虽然控制台依然提示错误，但是别名可以生效。</p><h5 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h5><p>在 build 时，mini-css-extract-plugin 提示 Conflicting order， 错误位置在 antd-mobile 的样式文件。根据 <a href="https://github.com/ant-design/ant-design/issues/14895" target="_blank" rel="noopener">issue</a> 以及 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250" target="_blank" rel="noopener"> issue </a>看来这个问题主要是由于懒加载加上 antd 组件导入顺序不一致导致的，目前看来无需解决。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学 Generator《一》</title>
      <link href="/2020/07/15/%E9%87%8D%E5%AD%A6%20Generator%E3%80%8A%E4%B8%80%E3%80%8B/"/>
      <url>/2020/07/15/%E9%87%8D%E5%AD%A6%20Generator%E3%80%8A%E4%B8%80%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>在实际工作的业务开发中，使用到 Generator 比较少。近期有个项目状态管理使用的是 redux-saga，而 redux-saga 又是基于 Generator，借此机会重新学了下 Generator。</p><p>本文主要是记录 generator 的要点，以防将来遗忘。</p><a id="more"></a><h5 id="调用-generator-将会返回一个迭代器"><a href="#调用-generator-将会返回一个迭代器" class="headerlink" title="调用 generator 将会返回一个迭代器"></a>调用 generator 将会返回一个迭代器</h5><p>所谓 generator 实际上就是带有 * 的函数，调用后不会执行 generator 内部代码，而是返回一个 iterator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'generator'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction()</span><br><span class="line"><span class="built_in">console</span>.log(iterator[<span class="built_in">Symbol</span>.iterator])</span><br><span class="line"></span><br><span class="line"><span class="comment">// function [Symbol.iterator]()</span></span><br></pre></td></tr></table></figure><h5 id="执行-generator"><a href="#执行-generator" class="headerlink" title="执行 generator"></a>执行 generator</h5><p>每次调用返回的迭代器的 next 方法可以执行 generator 中的代码，直到执行完遇到的第一个 yield 或者 return 后并交出执行权</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">  <span class="keyword">yield</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction()</span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h5 id="return-与-yield-的异同"><a href="#return-与-yield-的异同" class="headerlink" title="return 与 yield 的异同"></a>return 与 yield 的异同</h5><p>执行 iterator.next 返回的是一个包括 value 和 done 两个属性的对象，这个对象的 value 就是 <code>yield</code> 或 <code>return</code> 后面表达式的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction()</span><br><span class="line"><span class="keyword">var</span> a = iterator.next()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="keyword">var</span> b = iterator.next()</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>yield 与 return 类似，但 yield 是暂停的意思，而 return 则代表结束, return 之后的代码将不会被执行到。</p><p>done 为 true 表示遍历结束，但是此时依然可以可以继续调用 iterator.next()，只不过返回值将是 { value: undefined, done: true }。</p><p><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，直到 done 变为 true。</p><p>⚠️ done 为 true 的运行结果会被抛弃掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h5 id="next-的参数"><a href="#next-的参数" class="headerlink" title="next 的参数"></a>next 的参数</h5><p>next 的参数可以最为 yield 语句的返回值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">yield</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// a 1</span></span><br></pre></td></tr></table></figure><h5 id="yield"><a href="#yield" class="headerlink" title="yield *"></a>yield *</h5><p>通过 yield * 可以进入到另一个 generator 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'foo'</span>;</span><br><span class="line">    <span class="keyword">yield</span> * bar();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'bar'</span>;</span><br><span class="line">    <span class="keyword">yield</span> * baz();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'baz'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure><h5 id="向-generaotr-内部抛异常"><a href="#向-generaotr-内部抛异常" class="headerlink" title="向 generaotr 内部抛异常"></a>向 generaotr 内部抛异常</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="string">'a'</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Generator caught'</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction();</span><br><span class="line">iterator.next();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    iterator.throw(<span class="string">'a'</span>);</span><br><span class="line">    iterator.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Uncaught'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Generator caught a</span></span><br><span class="line"><span class="comment">// Uncaught b</span></span><br></pre></td></tr></table></figure><p>资料主要参考自  <a href="https://github.com/gajus/gajus.com-blog/blob/master/posts/the-definitive-guide-to-the-javascript-generators/index.md" target="_blank" rel="noopener">generator 权威指南</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
