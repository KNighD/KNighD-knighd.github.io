<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式-JS中的观察者模式与发布订阅模式</title>
      <link href="/2020/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在上一篇文章《debounce与throttle》 中提到了 RxJS， RxJS 中有两个重要的概念: Observable（可被观察者） 和 Observer（观察者），RxJS 的 Observable 就是观察者模式和迭代器模式的组合。</p><p>在 javascript 中，观察者模式和发布订阅模式极为相似，因此本文将探讨这两种模式以及其应用。</p> <a id="more"></a><h4 id="观察者模式基本原理"><a href="#观察者模式基本原理" class="headerlink" title="观察者模式基本原理"></a>观察者模式基本原理</h4><blockquote><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 —— Graphic Design Patterns</p></blockquote><p>观察者模式有两个对象：一个是观察者，另一个上面提到的目标对象可以称为是发布者，基本的流程为：</p><ol><li>发布者维护一个观察者列表，可以添加或者删除观察者</li><li>当发布者发布通知时，遍历观察者列表，并调用观察者提供的方法</li></ol><p>发布者的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123; observers &#125;) &#123;</span><br><span class="line">    <span class="comment">// 维护一个观察者列表</span></span><br><span class="line">    <span class="keyword">this</span>.observers = observers || []</span><br><span class="line">    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">// 添加观察者</span></span><br><span class="line">  addObserver(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除观察者</span></span><br><span class="line">  removeObserver(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = <span class="keyword">this</span>.observers.filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== observer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布通知</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行观察者提供的方法，这里假设为 update</span></span><br><span class="line">      item.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅者则比较简单，实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`observer <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> update`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Observer(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> Observer(<span class="string">'b'</span>)</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Observer(<span class="string">'c'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> publisher = <span class="keyword">new</span> Publisher(&#123;</span><br><span class="line">  observers: [a, b]</span><br><span class="line">&#125;)</span><br><span class="line">publisher.addObserver(c)</span><br><span class="line">publisher.notify()</span><br></pre></td></tr></table></figure><h4 id="观察者模式在-vue-中的应用"><a href="#观察者模式在-vue-中的应用" class="headerlink" title="观察者模式在 vue 中的应用"></a>观察者模式在 vue 中的应用</h4>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debounce与throttle</title>
      <link href="/2020/08/06/debounce%E4%B8%8Ethrottle/"/>
      <url>/2020/08/06/debounce%E4%B8%8Ethrottle/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>测试同学提了个 bug，在搜索框中疯狂输入文字，不一会儿接口就报错了。这个 bug 实际上就是由于每输入一个字符时，就去请求接口引起的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleSearch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...请求接口</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;Input onChange=&#123;handleSearch&#125; /&gt;</span><br></pre></td></tr></table></figure><p>解决方法是通过 <code>debounce</code> 来控制输入的频率。</p><p>实际上 <code>debounce</code> 和 <code>throttle</code> 这两个概念经常是一起出现，在工作中也常常使用到。在早年接触前端的时候，项目里有 <code>lodash</code>，因此直接使用其提供的  <code>debounce</code> 和 <code>throttle</code> 。而在一些简单的项目里，往往不引入 <code>lodash</code>，这个时候就需要自己实现，于此做个记录。</p><a id="more"></a><h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><p><code>debounce</code> 也就是防抖，看看 lodash 中 debounce 的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.debounce(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure><p>返回一个函数，该函数会距离上次调用后，延迟 <code>wait</code> 毫秒后调用<code>func</code>。</p><p>在上面的 bug 中，对原搜索方法进行防抖处理后，仅当用户停止输入 300 毫秒后，才请求接口进行搜索：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止输入 300 ms 后，进行搜索</span></span><br><span class="line">_.debounce(handleSearch, <span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>####throttle</p><p><code>throttle</code> 我们称之为截流，同样看看 loads 中 throttle 的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.throttle(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure><p>返回一个函数，该函数最多每 <code>wait</code> 毫秒调用一次 <code>func</code>。</p><p>如果对搜索方法进行截流，则无论用户输入多快，每 1 秒仅请求一次：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止输入 300 ms 后，进行搜索</span></span><br><span class="line">_.debounce(handleSearch, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h4 id="手写一个-debounce"><a href="#手写一个-debounce" class="headerlink" title="手写一个 debounce"></a>手写一个 debounce</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeout) &#123;</span><br><span class="line">      clearTimeout(timeout)</span><br><span class="line">    &#125;</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> func.call(<span class="keyword">this</span>, ...args), wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 func 被当作是参数传递进来，注意上面的 func 需要绑定 this。并且在使用时如果有 this 指向，需要显式指明 this，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = debounce(o.b).bind(o);</span><br></pre></td></tr></table></figure><p>对 debounce 进一步拓展，如果需要在调用时立刻执行一次，则可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait = <span class="number">0</span>, head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callNow = head &amp;&amp; !timeout;</span><br><span class="line">    timeout &amp;&amp; clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!callNow) &#123;</span><br><span class="line">        func.call(<span class="keyword">this</span>, ...args);</span><br><span class="line">      &#125;</span><br><span class="line">      timeout = <span class="literal">null</span></span><br><span class="line">    &#125;, wait);</span><br><span class="line">    <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">      func.call(<span class="keyword">this</span>, ...args)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手写一个-throttle"><a href="#手写一个-throttle" class="headerlink" title="手写一个 throttle"></a>手写一个 throttle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, timeFrame = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      <span class="keyword">if</span> (now - lastTime &gt;= timeFrame) &#123;</span><br><span class="line">          func.call(<span class="keyword">this</span>, ...args);</span><br><span class="line">          lastTime = now;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="what’s-more-rxjs"><a href="#what’s-more-rxjs" class="headerlink" title="what’s more: rxjs"></a>what’s more: rxjs</h4><p>截流和防抖很多时候是出现在事件中的，使用 rxjs 则可以使用 debounceTime 和 throttleTime：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fromEvent &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; debounceTime &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputEle = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>)</span><br><span class="line"><span class="keyword">const</span> inputs = fromEvent(inputEle, <span class="string">'input'</span>);</span><br><span class="line"><span class="keyword">const</span> result = inputs.pipe(debounceTime(<span class="number">1000</span>));</span><br><span class="line"><span class="comment">// 如果是节流可使用 throttleTime</span></span><br><span class="line"><span class="comment">// const result = inputs.pipe(throttleTime(1000));</span></span><br><span class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure><h4 id="rxjs-react"><a href="#rxjs-react" class="headerlink" title="rxjs + react"></a>rxjs + react</h4><p>如果是 react 中的事件需要防抖，那么可以通过 <code>Subject</code> 来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useEffect &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; Subject &#125; from &#39;rxjs&#39;;</span><br><span class="line">import &#123; debounceTime &#125; from &#39;rxjs&#x2F;operators&#39;;</span><br><span class="line"></span><br><span class="line">const debounced$ &#x3D; new Subject().pipe(</span><br><span class="line">  debounceTime(300)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default function App() &#123; </span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    const subscription &#x3D; debounced$.subscribe((value) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理输入事件</span><br><span class="line">      console.log(value)</span><br><span class="line">    &#125;)</span><br><span class="line">    return () &#x3D;&gt; subscription.unsubscribe()</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  const onChange &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">    const value &#x3D; e.target.value;</span><br><span class="line">    debounced$.next(value)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input onChange&#x3D;&#123;onChange&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当我们说到打包时，我们在说什么</title>
      <link href="/2020/07/31/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E5%88%B0%E6%89%93%E5%8C%85%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/31/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E5%88%B0%E6%89%93%E5%8C%85%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>从早期的 grunt (我接触前端开发的时候这个已经趋于没落) 到 gulp，再到如今的 webpack，rollup ，parcel，以及 snowpack，vite，如今的前端已经脱离了刀耕火种的时代，各种打包工具层出不穷。前端项目基本离不开打包这个过程。那么当我们说到打包（bundle）时，我们在说的是什么？</p><p>这里不对 webpack 或者这些打包工具的使用进行具体说明，本文想探究的是打包的本质。</p><a id="more"></a><h4 id="从模块化说起"><a href="#从模块化说起" class="headerlink" title="从模块化说起"></a>从模块化说起</h4><p>在没有模块化之前，前端开发时需要格外注意命名冲突以及文件之间的相互依赖，参考 <a href="https://github.com/seajs/seajs/issues/547#issue-11105836。" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/547#issue-11105836。</a></p><p>模块化实际上就是将程序分解成离散的功能块，使代码易于复用，维护和测试。如 less 中通过 @import 引入的样式，ES6 Module / CommonJs 引入的 Js 等都可以称为模块。</p><p>然而浏览器不支持模块化，因此我们需要一个打包工具，将代码中诸如 require, @import, import 进来的模块打包成一个或者多个文件(即 bundle)。</p><h4 id="打包的本质"><a href="#打包的本质" class="headerlink" title="打包的本质"></a>打包的本质</h4><p>参考 webpack 的定义：</p><blockquote><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p></blockquote><p>而至于这个过程中，对代码进行压缩，混淆等等则是锦上添花的功能。</p><h4 id="打包的过程"><a href="#打包的过程" class="headerlink" title="打包的过程"></a>打包的过程</h4><p>这里以 webpack 为例：</p><ol><li>初始化：从配置文件和 Shell 语句中读取并合并配置参数</li><li>开始编译：根据上面得到的参数初始化 Compiler，加载插件（Plugins），执行 Compiler 的 run 方法开始编译</li><li>入口文件：配置的 entry</li><li>从入口文件开始，针对不同的模块使用对应的 Loader 编译，再找到该模块所依赖的模块，递归这个步骤</li><li>完成编译：经过上述步骤后得到每个模块编译后的内容以及相互之间的依赖关系</li><li>输出：根据依赖关系，将模块组合成一个个代码块（Chunk），最后输出成文件</li></ol><h4 id="实现一个简易的打包工具"><a href="#实现一个简易的打包工具" class="headerlink" title="实现一个简易的打包工具"></a>实现一个简易的打包工具</h4><p>参考 <a href="https://github.com/ronami" target="_blank" rel="noopener">ronami</a>/<strong><a href="https://github.com/ronami/minipack" target="_blank" rel="noopener">minipack</a></strong> 实现一个支持 ES Module 的简易打包工具（这里不考虑循环依赖等情况）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">'babylon'</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'babel-traverse'</span>).default</span><br><span class="line"><span class="keyword">const</span> &#123; transformFromAst &#125; = <span class="built_in">require</span>(<span class="string">'babel-core'</span>)</span><br></pre></td></tr></table></figure><p>引入上述相关依赖：</p><ul><li>babylon：生成 AST（抽象语法树）</li><li>babel-traverse：来分析文件的依赖</li><li>transformFromAst：将 AST 转为 ES5</li></ul><p><strong>首先</strong> 定义一个函数用于读取文件的内容和依赖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取文件内容和依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAsset</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(filePath, <span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="comment">// 生成 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = babylon.parse(content, &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 当前文件的依赖关系</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = []</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    <span class="comment">// 当遇到导入的声明时，将其内容 push 到 dependencies 里</span></span><br><span class="line">    ImportDeclaration: <span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      dependencies.push(node.source.value)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 将 AST 转为 ES5</span></span><br><span class="line">  <span class="keyword">const</span> &#123; code &#125; = transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    presets: [<span class="string">'env'</span>],</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    filePath,</span><br><span class="line">    dependencies,</span><br><span class="line">    code,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Asset 接口如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Assets &#123;</span><br><span class="line"><span class="comment">// 文件路径</span></span><br><span class="line">  filePath: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 文件的依赖</span></span><br><span class="line">  dependencies: <span class="built_in">string</span>[];</span><br><span class="line">  <span class="comment">// 转为 ES5 后的文件内容</span></span><br><span class="line">  code: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 相对路径</span></span><br><span class="line">  relativePath?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，我们现在有个文件 entry.js ，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><p>运行 <code>createAsset(&#39;./entry.js&#39;)</code> 将会返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  filePath: <span class="string">'./entry.js'</span>,</span><br><span class="line">  dependencies: [ <span class="string">'./a.js'</span> ],</span><br><span class="line">  code: <span class="string">`"use strict";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _a = require("./a.js");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _a2 = _interopRequireDefault(_a);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(_a2.default);`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接着</strong>定义一个函数用于构建依赖关系图( dependency graph )：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建依赖关系图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGraph</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从入口文件开始</span></span><br><span class="line">  <span class="keyword">const</span> entryAsset = createAsset(entry);</span><br><span class="line">  <span class="comment">// 初始时，queue 中只有 entryAsset, 之后分析依赖关系，会将新的 Asset push 到 queue 中用于分析，直到分析完全部依赖</span></span><br><span class="line">  <span class="keyword">const</span> queue = [entryAsset]</span><br><span class="line">  <span class="comment">// 遍历所有文件依赖关系</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> asset <span class="keyword">of</span> queue) &#123;</span><br><span class="line">    <span class="comment">// 获得文件目录</span></span><br><span class="line">    <span class="keyword">const</span> dirname = path.dirname(asset.filePath)</span><br><span class="line">    <span class="comment">// 遍历当前文件依赖关系</span></span><br><span class="line">    asset.dependencies.forEach(<span class="function">(<span class="params">relativePath</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获得绝对路径</span></span><br><span class="line">      <span class="keyword">const</span> absolutePath = path.join(dirname, relativePath)</span><br><span class="line">      <span class="keyword">const</span> childAsset = createAsset(absolutePath)</span><br><span class="line">      childAsset.relativePath = relativePath</span><br><span class="line">      <span class="comment">// 将当前文件所依赖的文件的 Asset 也 push 到 queue 中用于遍历</span></span><br><span class="line">      queue.push(childAsset)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，在上面的基础上，有个 a.js 以及 b.js 文件, 运行 <code>createGraph</code>会返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">// createGraph('./entry.js')</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    filePath: <span class="string">'./entry.js'</span>,</span><br><span class="line">    dependencies: [ <span class="string">'./a.js'</span> ],</span><br><span class="line">    code: <span class="string">`"use strict";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _a = require("./a.js");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _a2 = _interopRequireDefault(_a);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(_a2.default);`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    filePath: <span class="string">'a.js'</span>,</span><br><span class="line">    dependencies: [ <span class="string">'./b.js'</span> ],</span><br><span class="line">    code: <span class="string">`"use strict";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Object.defineProperty(exports, "__esModule", &#123;</span></span><br><span class="line"><span class="string">  value: true</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _b = require("./b.js");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _b2 = _interopRequireDefault(_b);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var a = '1';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exports.default = a;`</span>,</span><br><span class="line">    relativePath: <span class="string">'./a.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    filePath: <span class="string">'b.js'</span>,</span><br><span class="line">    dependencies: [],</span><br><span class="line">    code: <span class="string">`"use strict";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Object.defineProperty(exports, "__esModule", &#123;</span></span><br><span class="line"><span class="string">  value: true</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">var b = '2';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exports.default = b;`</span>,</span><br><span class="line">    relativePath: <span class="string">'./b.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>最后</strong>实现一个打包函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> graph = createGraph(entry)</span><br><span class="line">  <span class="keyword">let</span> modules = <span class="string">''</span></span><br><span class="line">  <span class="comment">// 构建函数参数</span></span><br><span class="line">  graph.forEach(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> filePath = mod.relativePath || entry</span><br><span class="line">    <span class="comment">// 拼装成 modules</span></span><br><span class="line">    modules += <span class="string">`'<span class="subst">$&#123;filePath&#125;</span>': (</span></span><br><span class="line"><span class="string">      function (module, exports, require) &#123; <span class="subst">$&#123;mod.code&#125;</span> &#125;</span></span><br><span class="line"><span class="string">    ),`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 最终结果</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="string">`</span></span><br><span class="line"><span class="string">    (function(modules) &#123;</span></span><br><span class="line"><span class="string">// ast 转 es5 的代码是 commonjs 风格，而浏览器不支持 commonjs，因此自定义 require，以文件名作为 id</span></span><br><span class="line"><span class="string">      function require(id) &#123;</span></span><br><span class="line"><span class="string">        const module = &#123; exports : &#123;&#125; &#125;</span></span><br><span class="line"><span class="string">        modules[id](module, module.exports, require)</span></span><br><span class="line"><span class="string">        return module.exports</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">// 引入入口文件代码</span></span><br><span class="line"><span class="string">      require('<span class="subst">$&#123;entry&#125;</span>')</span></span><br><span class="line"><span class="string">    &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="comment">// 当生成的内容写入到文件中</span></span><br><span class="line">  fs.writeFileSync(<span class="string">'./bundle.js'</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出一个 IIFE：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;</span><br><span class="line">    modules[id](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, <span class="built_in">require</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./entry.js'</span>)</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">'./entry.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _a2 = _interopRequireDefault(_a)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(_a2.default)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'./a.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(exports, <span class="string">'__esModule'</span>, &#123;</span><br><span class="line">      value: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _b2 = _interopRequireDefault(_b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">    exports.default = a</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'./b.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(exports, <span class="string">'__esModule'</span>, &#123;</span><br><span class="line">      value: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">    exports.default = b</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-JS中的单例模式</title>
      <link href="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>此前项目有个 im  模块，需要用到 websocket。使用 websocket 需要建立连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initWs = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'wss://xxx.com'</span>);</span><br><span class="line">  ws.onopen(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'opened'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  ws.onmessage(<span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received evt'</span>, evt.data)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  <span class="keyword">return</span> ws</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们肯定不希望在每个用到 ws 的地方都重复初始化，即我们只需要一个 WebSocket 的实例。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wsA = <span class="keyword">new</span> SingleWs()</span><br><span class="line"><span class="keyword">const</span> wsB = <span class="keyword">new</span> SingleWs()</span><br><span class="line"><span class="comment">// 有没有办法使得:</span></span><br><span class="line">wsA <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsB <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsA === wsB</span><br></pre></td></tr></table></figure><p>那么要如何做到这一点？实际上就可以用到单例模式。下面列举几个实现的方法：</p><h4 id="使用全局变量"><a href="#使用全局变量" class="headerlink" title="使用全局变量"></a>使用全局变量</h4><p>这个可能是最容易想到的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.ws = <span class="built_in">window</span>.ws || initWs()</span><br></pre></td></tr></table></figure><p>将 ws 挂在 window 对象上，使用时也用 window.ws，显然这个解决方案有个问题是需要小心 window.ws 被覆盖。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包可以保持局部变量保持在内存中不被销毁，通过这个特性可以就可以避免污染全局变量，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SingleWs = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> ws = <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">// const initWs = ....</span></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   getWs() &#123;</span><br><span class="line">     <span class="keyword">if</span>(!ws) &#123;</span><br><span class="line">       ws = initWs()</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ws</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wsA = SingleWs.getWs()</span><br><span class="line"><span class="keyword">const</span> wsB = SingleWs.getWs()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(wsA <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsB <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsA === wsB)</span><br></pre></td></tr></table></figure><p>然而上面的写法也有一些缺点，如 getWs 可以被改写。</p><p>写法还可以进一步改写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SingleWs = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> ws = <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">// const initWs = .... </span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!ws) &#123;</span><br><span class="line">      ws = initWs()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 new 可以不写</span></span><br><span class="line"><span class="keyword">const</span> wsA = <span class="keyword">new</span> SingleWs()</span><br><span class="line"><span class="keyword">const</span> wsB = <span class="keyword">new</span> SingleWs()</span><br><span class="line"></span><br><span class="line">wsA <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsB <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsA === wsB</span><br></pre></td></tr></table></figure><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>通过模块化也能实现上述的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ws.js</span></span><br><span class="line"><span class="keyword">let</span> ws = <span class="literal">null</span></span><br><span class="line"><span class="comment">// const initWs = ....</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SingleWs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ws) &#123;</span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line">  &#125;</span><br><span class="line">  ws = initWs()</span><br><span class="line">  <span class="keyword">return</span> ws</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> SingleWs</span><br></pre></td></tr></table></figure><h4 id="通过-class-的静态属性来实现"><a href="#通过-class-的静态属性来实现" class="headerlink" title="通过 class 的静态属性来实现"></a>通过 class 的静态属性来实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleWs</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SingleWs.instance) &#123;</span><br><span class="line">      SingleWs.instance = <span class="keyword">this</span>.initWs()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SingleWs.instance</span><br><span class="line">  &#125;</span><br><span class="line">  initWs() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wsA = <span class="keyword">new</span> SingleWs()</span><br><span class="line"><span class="keyword">const</span> wsB = <span class="keyword">new</span> SingleWs()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(wsA <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsB <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsA === wsB)</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>JS 中的单例模式：</p><ol><li>实例化时，判断是否已经存在实例。</li><li>如果不存在，则初始化，并将生成的实例存储起来。</li><li>存储的方法可以是全局变量，闭包，模块以及类的静态属性。</li><li>如果已经存在实例，那么就直接返回该实例。</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】ReactHooks-并非黑魔法，本质是数组</title>
      <link href="/2020/07/26/%E3%80%90%E8%AF%91%E3%80%91ReactHooks-%E5%B9%B6%E9%9D%9E%E9%BB%91%E9%AD%94%E6%B3%95%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B0%E7%BB%84/"/>
      <url>/2020/07/26/%E3%80%90%E8%AF%91%E3%80%91ReactHooks-%E5%B9%B6%E9%9D%9E%E9%BB%91%E9%AD%94%E6%B3%95%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本文翻译自 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a>，该文章很好的阐释了 react hooks 原理，我将保持原文的意思进行翻译，如有自己感觉不清楚的地方将会在括号中注明。以下为翻译内容。</p><p>我是 hooks api 的忠实粉丝。然而 hooks 在使用时却有一些<a href="https://reactjs.org/docs/hooks-rules.html" target="_blank" rel="noopener">奇怪的约束</a>。在这里，我给尝试去理解这些规则由来的人提供一个了模型，用于思考如何去使用这些新 api。</p><a id="more"></a><h4 id="hooks-的规则"><a href="#hooks-的规则" class="headerlink" title="hooks 的规则"></a>hooks 的规则</h4><p>在 <a href="https://reactjs.org/docs/hooks-rules.html" target="_blank" rel="noopener">hooks proposal documentation</a>  的提纲中，React 核心团队规定了两条开发者在使用 hooks 时需要遵守的主要规则：</p><ul><li>不要在循环，条件或者是嵌套函数中使用 hooks</li><li>只能在 React Functions 中才能使用 hooks</li></ul><p>后者我认为是显而易见的。要将行为附加到函数式组件上，你需要能够以某种方式将该行为与组件关联起来。（原文为： To attach behaviour to a functional component you need to be able to associate that behaviour with the component somehow. 不太理解作者想表达的意思）</p><p>前者我认为会比较让人困惑，因为像这样使用 api 可能看起来不太自然。而这正是我今天想要探讨的内容。</p><h4 id="hooks-的状态管理都是基于数组"><a href="#hooks-的状态管理都是基于数组" class="headerlink" title="hooks 的状态管理都是基于数组"></a>hooks 的状态管理都是基于数组</h4><p>为了更清晰地理解心智模型，让我们来看一下如何实现一个简单的 hooks api。</p><p><strong>注意这只是 API 的一种可能的实现方式及猜想，用于让你理解，而非 API 真正的内部实现方式</strong></p><h4 id="我们如何实现-useState"><a href="#我们如何实现-useState" class="headerlink" title="我们如何实现 useState?"></a>我们如何实现 <code>useState</code>?</h4><p>让我们打开一个实例来演示如何实现一个 state hook。</p><p>首先，我们定义一个组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function RenderFunctionComponent() &#123;</span><br><span class="line">  const [firstName, setFirstName] &#x3D; useState(&quot;Rudi&quot;);</span><br><span class="line">  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Hooks api 背后的思想是，你可以用 hook 函数返回的数组的第二个元素作为 setter 方法，这个 setter 方法可以控制被 hook 管理的状态。</p><h4 id="那么-React-是如何做到这个的呢？"><a href="#那么-React-是如何做到这个的呢？" class="headerlink" title="那么 React 是如何做到这个的呢？"></a>那么 React 是如何做到这个的呢？</h4><p>让我们看看这个在 React 内部是如何运作的。以下内容将在特定组件的上下文中运行。这就是说数据存储在要渲染的组件的上一层。这个 state 不与其他组件共享，但是维护在一个可以用于该组件后续渲染的作用域内。（原文：The following would work within the execution context for rendering a particular component. That means that the data stored here lives one level outside of the component being rendered. This state is not shared with other components but it is maintained in a scope that is accessible to subsequent rendering of the specific component）</p><ol><li><p>初始化</p><p>创建两个空数组：<code>setter</code> 和 <code>state</code></p><p>将指针设置为 0</p><p><img src="https://miro.medium.com/max/1280/1*LAZDuAEm7nbcx0vWVKJJ2w.png" alt="Image for post"></p></li></ol><ol start="2"><li><p>首次渲染</p><p>首次运行该组件。</p><p>每次调用 <code>useState</code> ，如果是首次运行，则 push 一个 setter 方法（绑定到指针的位置）到 setters 数组中，并且 push 一些 state 到 state 数组中。</p><p><img src="https://miro.medium.com/max/1260/1*8TpWnrL-Jqh7PymLWKXbWg.png" alt="Image for post"></p></li><li><p>后续渲染</p><p>每次后续渲染，指针将被重置，然后从各个数组中读取对应的值。</p><p><img src="https://miro.medium.com/max/1254/1*qtwvPWj-K3PkLQ6SzE2u8w.png" alt="Image for post"></p></li><li><p>事件处理</p><p>每一个 setter 都保存一个对应的指针位置的引用，因此触发任意一个 <code>setter</code> 都可以修改 state 数组中对应指针位置的 state。</p><p><img src="https://miro.medium.com/max/1260/1*3L8YJnn5eV5ev1FuN6rKSQ.png" alt="Image for post"></p></li></ol><h4 id="简单的实现-And-the-naive-implementation"><a href="#简单的实现-And-the-naive-implementation" class="headerlink" title="简单的实现(And the naive implementation)"></a>简单的实现(And the naive implementation)</h4><p>下面是简单的代码演示：</p><p><strong>注意：这不代表 hooks 的实际实现，但是应该能给你一个理解 hooks 工作原理的思路。这就是我为什么使用块级变量的原因（原文： That is why we are using module level vars etc）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">let state &#x3D; [];</span><br><span class="line">let setters &#x3D; [];</span><br><span class="line">let firstRun &#x3D; true;</span><br><span class="line">let cursor &#x3D; 0;</span><br><span class="line"></span><br><span class="line">function createSetter(cursor) &#123;</span><br><span class="line">  return function setterWithCursor(newVal) &#123;</span><br><span class="line">    state[cursor] &#x3D; newVal;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; This is the pseudocode for the useState helper</span><br><span class="line">export function useState(initVal) &#123;</span><br><span class="line">  if (firstRun) &#123;</span><br><span class="line">    state.push(initVal);</span><br><span class="line">    setters.push(createSetter(cursor));</span><br><span class="line">    firstRun &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const setter &#x3D; setters[cursor];</span><br><span class="line">  const value &#x3D; state[cursor];</span><br><span class="line"></span><br><span class="line">  cursor++;</span><br><span class="line">  return [value, setter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Our component code that uses hooks</span><br><span class="line">function RenderFunctionComponent() &#123;</span><br><span class="line">  const [firstName, setFirstName] &#x3D; useState(&quot;Rudi&quot;); &#x2F;&#x2F; cursor: 0</span><br><span class="line">  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;); &#x2F;&#x2F; cursor: 1</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Richard&quot;)&#125;&gt;Richard&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; This is sort of simulating Reacts rendering cycle</span><br><span class="line">function MyComponent() &#123;</span><br><span class="line">  cursor &#x3D; 0; &#x2F;&#x2F; resetting the cursor</span><br><span class="line">  return &lt;RenderFunctionComponent &#x2F;&gt;; &#x2F;&#x2F; render</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(state); &#x2F;&#x2F; Pre-render: []</span><br><span class="line">MyComponent();</span><br><span class="line">console.log(state); &#x2F;&#x2F; First-render: [&#39;Rudi&#39;, &#39;Yardley&#39;]</span><br><span class="line">MyComponent();</span><br><span class="line">console.log(state); &#x2F;&#x2F; Subsequent-render: [&#39;Rudi&#39;, &#39;Yardley&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; click the &#39;Fred&#39; button</span><br><span class="line"></span><br><span class="line">console.log(state); &#x2F;&#x2F; After-click: [&#39;Fred&#39;, &#39;Yardley&#39;]</span><br></pre></td></tr></table></figure><h4 id="为什么顺序很重要？"><a href="#为什么顺序很重要？" class="headerlink" title="为什么顺序很重要？"></a>为什么顺序很重要？</h4><p>现在如果在一个生命周期里，我们基于外部的因素或者组件状态改变了 hooks 的顺序，将会发生什么事情？</p><p>让我们试试看 react 不建议我们做的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let firstRender &#x3D; true;</span><br><span class="line"></span><br><span class="line">function RenderFunctionComponent() &#123;</span><br><span class="line">  let initName;</span><br><span class="line">  </span><br><span class="line">  if(firstRender)&#123;</span><br><span class="line">    [initName] &#x3D; useState(&quot;Rudi&quot;);</span><br><span class="line">    firstRender &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line">  const [firstName, setFirstName] &#x3D; useState(initName);</span><br><span class="line">  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在一个条件语句中使用了 <code>useState</code>，让我们看看造成了什么样的破坏：</p><h4 id="坏组件的第一次渲染"><a href="#坏组件的第一次渲染" class="headerlink" title="坏组件的第一次渲染"></a>坏组件的第一次渲染</h4><p><img src="https://miro.medium.com/max/1270/1*C4IA_Y7v6eoptZTBspRszQ.png" alt="Image for post"></p><p>在这个时候，我们的实例变量 <code>firstName</code> 和 <code>lastName</code> 指向的正确的数据，但是我们看看第二次渲染发生了什么：</p><h4 id="坏组件的第二次渲染"><a href="#坏组件的第二次渲染" class="headerlink" title="坏组件的第二次渲染"></a>坏组件的第二次渲染</h4><p><img src="https://miro.medium.com/max/1274/1*aK7jIm6oOeHJqgWnNXt8Ig.png" alt="Image for post"></p><p>现在我们的 state 存储出现异常， <code>firstName</code> 和 <code>lastName</code> 都指向 “Rudi”。上述明显错误的操作给了我们一个思路：为什么 hooks 要如此规定。</p><blockquote><p>The React team are stipulating the usage rules because not following them will lead to inconsistent data</p></blockquote><h4 id="想想-hooks-操作一系列的数组，那么你就不会打破规则了（Think-about-hooks-manipulating-a-set-of-arrays-and-you-wont-break-the-rules）"><a href="#想想-hooks-操作一系列的数组，那么你就不会打破规则了（Think-about-hooks-manipulating-a-set-of-arrays-and-you-wont-break-the-rules）" class="headerlink" title="想想 hooks 操作一系列的数组，那么你就不会打破规则了（Think about hooks manipulating a set of arrays and you wont break the rules）"></a>想想 hooks 操作一系列的数组，那么你就不会打破规则了（Think about hooks manipulating a set of arrays and you wont break the rules）</h4><p>现在应该能很清晰理解为什么不能在条件或者循环语句中使用 <code>use</code> hook 了：因为我们使用了指针指向了数组，如果在 render 的时候改变了顺序，那么指针就不能对应正确的数据，所以调用 use 也不会指向正确的数据和 setter。</p><p>因此，诀窍就是将 hooks 想像成用恒定的指针来管理一系列数组。如果能做到这个，那么一切就能按预期进行。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>希望我已经就如何思考 hooks api 的工作原理指出了一个清晰的心智模型。（后面就偷个懒不翻译了，基本是上述观点的重复强调。）</p><p>Hopefully I have laid out a clearer mental model for how to think about what is going on under the hood with the new hooks API. Remember the true value here is being able to group concerns together so being careful about order and using the hooks API will have a high payoff.</p><p>Hooks is an effective plugin API for React Components. There is a reason why people are excited about this and if you think about this kind of model where state exists as a set of arrays then you should not find yourselves breaking the rules around their usage.</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端入坑flutter</title>
      <link href="/2020/07/24/%E5%89%8D%E7%AB%AF%E5%85%A5%E5%9D%91flutter/"/>
      <url>/2020/07/24/%E5%89%8D%E7%AB%AF%E5%85%A5%E5%9D%91flutter/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>踩过 RN 的坑之后越发想尝试学习下 flutter 的开发，本文用于记录下开发过程中的问题与思考，本来是写在 notion 里的，最近 notion 无法打开，故记录于此。</p><a id="more"></a><h4 id="Flutter为什么选择了-Dart而不是-JavaScript"><a href="#Flutter为什么选择了-Dart而不是-JavaScript" class="headerlink" title="Flutter为什么选择了 Dart而不是 JavaScript"></a>Flutter为什么选择了 Dart而不是 JavaScript</h4><p>以下内容引用自 <a href="https://book.flutterchina.club/chapter1/flutter_intro.html" target="_blank" rel="noopener">flutter 开发实战</a>。</p><p>首先要了解两个概念：JIT和AOT。<br>目前，程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为<strong>AOT</strong> （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为<strong>JIT</strong>（Just-in-time）即“即时编译”。AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。在此，读者不必纠结于概念，概念就是为了传达精神而发明的，只要读者能够理解其原理即可，得其神忘其形。<br>JavaScript为脚本语言，执行时需要JIT(Just In Time)，执行效率和AOT(Ahead Of Time)代码仍有差距。<br>Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。<br>但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。</p><h4 id="网页开发"><a href="#网页开发" class="headerlink" title="网页开发"></a>网页开发</h4><p>现在 flutter 已经支持 web 了，切换到 beta ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 切换 channel</span><br><span class="line">flutter channel beta</span><br><span class="line">// 更新 sdk</span><br><span class="line">flutter upgrade</span><br><span class="line">// 安装依赖</span><br><span class="line">flutter packages get</span><br><span class="line">// 启动开发模式</span><br><span class="line">flutter run -d chrome</span><br></pre></td></tr></table></figure><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><p>过程不提，文档讲的比较清晰了，注意配置国内的源即可。</p><h4 id="项目结构与命名规范"><a href="#项目结构与命名规范" class="headerlink" title="项目结构与命名规范"></a>项目结构与命名规范</h4><p>dart 的文件名是用下划线连接的，源文件在 lib 目录下，main.dart 为入口文件, 从 main 函数开始执行，下划线开头的变量为私有变量</p><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>dart 里如何导入本地文件的呢？和引用第三方的库的用法一样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:&#123;项目名&#125;/&#123;文件名&#125;'</span>;</span><br></pre></td></tr></table></figure><p>其中成员变量自动导出，那么如何防止命名冲突？:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:&#123;项目名&#125;/&#123;文件名&#125;'</span> <span class="keyword">as</span> MyModule;</span><br></pre></td></tr></table></figure><p>通过 as 来指定包名，此时要使用内部成员就需要 MyModule.xxx。</p><p>也可以屏蔽某些变量导出：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:&#123;项目名&#125;/&#123;文件名&#125;'</span> <span class="keyword">hide</span> MyVar;</span><br></pre></td></tr></table></figure><h4 id="Material-组件库"><a href="#Material-组件库" class="headerlink" title="Material 组件库"></a>Material 组件库</h4><p><a href="https://flutterchina.club/widgets/material/" target="_blank" rel="noopener">https://flutterchina.club/widgets/material/</a></p><h4 id="💀-Divider-在-web-需要传-thickness"><a href="#💀-Divider-在-web-需要传-thickness" class="headerlink" title="💀 Divider 在 web 需要传 thickness"></a>💀 Divider 在 web 需要传 thickness</h4><p>否则不渲染， issue 如下： <a href="https://github.com/flutter/flutter/issues/46339" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/46339</a></p><h4 id="💀-BottomNavigationBar"><a href="#💀-BottomNavigationBar" class="headerlink" title="💀 BottomNavigationBar"></a>💀 BottomNavigationBar</h4><p>如果超过 3 个 items，背景会变白，原因是超过 3 个 BottomNavigationBar 的 type 会变成 BottomNavigationBarType.shifting 类型，详情见： <a href="https://github.com/flutter/flutter/issues/13642#issuecomment-371875044" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/13642#issuecomment-371875044</a></p><p>解决的办法是设置 type 属性为 fixed。</p><h4 id="进程锁死"><a href="#进程锁死" class="headerlink" title="进程锁死"></a>进程锁死</h4><p>遇到控制台提示，Waiting for another flutter command to release the startup lock… 可以简单粗暴杀进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -9 dart</span><br></pre></td></tr></table></figure><h4 id="运行所有的-flutter-命令都被挂起时"><a href="#运行所有的-flutter-命令都被挂起时" class="headerlink" title="运行所有的 flutter 命令都被挂起时"></a>运行所有的 flutter 命令都被挂起时</h4><p>删除 <code>flutter/bin/cache</code>，然后重新运行 <code>flutter doctor -v</code></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见的安全问题汇总</title>
      <link href="/2020/07/23/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/23/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近安全部门的小伙伴提了一个前端安全的漏洞，想到前端开发过程中有时候往往追求开发效率，忽略掉一些安全问题，以下简单总结一些自己遇到过的以及一些常见的攻击手段，以自查自省。</p><a id="more"></a><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>回到安全部门提出的漏洞，场景还原如下：<br>这是一个老项目，展示文章用，页面路由为 <a href="http://xxx/article/:id?these-are-queries，node" target="_blank" rel="noopener">http://xxx/article/:id?these-are-queries，node</a> 层收到这个 url 后，返回返回该文章 html，内容则包括了【推荐文章】， 而推荐文章的链接则是根据 url 的值来的，仅变化 id。此时如果在 url 上的 query 上构造一段恶意脚本，然后引导用户打开，那么用户打开页面后就会运行该恶意脚本。<br>上述正是一个典型的 XSS 攻击，定义如下：</p><blockquote><p>XSS是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p></blockquote><p>XSS 的本质是信任了某些不安全的输入，导致恶意代码混入正常代码，进而发生的攻击行为。常见的不安全输入有：</p><ol><li>上面提到的 url 参数，这种需要诱导用户取点击</li><li>用户输入的内容，比如用户发表评论</li><li>第三方的链接等</li></ol><p>防范的方法通常是：对用户输入内容和服务端返回内容进行过滤和转译。</p><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>CSRF 攻击常见的过程如下：</p><ol><li>用户登录你的网站，产生登录凭证，如 cookie</li><li>用户被<strong>诱导</strong>登录到恶意网站</li><li>恶意网站携带刚刚在浏览器产生的凭证向你的服务器发送一个恶意请求</li><li>你的服务器无法识别是否恶意请求，请求完成，用户受害。</li></ol><p>与上面提到的 XSS 攻击有个明显的区别在于：CSRF 攻击发生在恶意网站，而不是被攻击的网站。而这也使得攻击者并不能获取到受害者的登录凭证，仅仅只能使用。<br>防范的方法通常是：</p><ol><li>请求 url 添加 token 或者是在 http 请求头自定义属性进行验证</li><li>同源检测，通过解析 请求头中的 referer 判断请求来源</li><li>Samesite，Google 起草了一份草案来改进 HTTP 协议，为 Set-Cookie 响应头新增 Samesite 属性，用于标明 Cookie 是否能作用于其他网站，目前兼容性还不是很好。</li></ol><h4 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h4><p>当我们使用 iframe 加载第三方网站时，第三方网站可以对我们的网站执行恶意操作，如操作DOM，加载 js 等。<br>防范的方法是通过设置 sandbox 属性控制 iframe 的操作权限。</p><h4 id="opener"><a href="#opener" class="headerlink" title="opener"></a>opener</h4><p>我们在通常通过以下写法在 新 tab 下打开链接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;a target=<span class="string">'_blank'</span> href=<span class="string">'new-site.com'</span>&gt;</span><br><span class="line"><span class="number">2.</span> <span class="built_in">window</span>.open(<span class="string">'new-site.com'</span>)</span><br></pre></td></tr></table></figure><p>上述两种写法的问题在于， <code>new-site.com</code> 是可以通过 <code>window.opener</code> 来拿到源页面的 <code>window</code> 对象，进而进行恶意操作。<br>防范的方法通常是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;a target=<span class="string">"_blank"</span> href=<span class="string">"new-site.com"</span> rel=<span class="string">"noopener noreferrer nofollow"</span>&gt;a标签跳转url&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">2. function openurl(url) &#123;</span></span><br><span class="line"><span class="regexp">    var newTab = window.open();</span></span><br><span class="line"><span class="regexp">    newTab.opener = null;</span></span><br><span class="line"><span class="regexp">    newTab.location = url;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul><li><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener">前端安全系列（一）：如何防止XSS攻击？</a></p></li><li><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener">前端安全系列（二）：如何防止CSRF攻击？</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN 避坑指北</title>
      <link href="/2020/07/21/RN%20%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97/"/>
      <url>/2020/07/21/RN%20%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p>记录平时开发 rn 时遇到的问题，特指 0.59 版本，不同版本可能情况不同，仅供参考。</p><a id="more"></a><h5 id="一像素问题"><a href="#一像素问题" class="headerlink" title="一像素问题"></a>一像素问题</h5><p>rn 解决一像素很简单，只需要  <code>StyleSheet.hairlineWidth</code> 即可解决。</p><h5 id="TextInput-组件"><a href="#TextInput-组件" class="headerlink" title="TextInput  组件"></a>TextInput  组件</h5><p>自带内边距，多行文字时文字居中展示，想要消除需要设置样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 文字向上对齐</span><br><span class="line">textAlignVertical: 'top'</span><br><span class="line">// 消除内边距</span><br><span class="line"><span class="selector-tag">padding</span>: 0</span><br></pre></td></tr></table></figure><p>Placeholder 在 ios 和 android 下默认颜色表现不一致，可以通过 <code>placeholderTextColor</code>  属性进行设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">placeholderTextColor=<span class="string">"#CCCCCC"</span></span><br></pre></td></tr></table></figure><h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><p>因为设计理念的问题，android 下几乎无法实现和 ios 一致的阴影效果。而 flutter 基于 skia 引擎渲染，应该会有比较好的表现？有空尝试下。 🤔</p><h5 id="border-虚线"><a href="#border-虚线" class="headerlink" title="border 虚线"></a>border 虚线</h5><p>border 虚线也是一个比较棘手的问题, android 上实测无效，详情看 <a href="https://github.com/facebook/react-native/issues/17251" target="_blank" rel="noopener">issue</a>。解决方案是循环一个 pattern 然后 overhidden 掉，又多了一个让我想尝试 flutter 的理由 😂</p><h5 id="多行文字"><a href="#多行文字" class="headerlink" title="多行文字"></a>多行文字</h5><p>多行文字在 android 机型下有可能会出现高度不够导致文字被截掉的问题，解决方法：设置  <code>lineHeight</code></p><h5 id="实现不同字号的文字底部对齐"><a href="#实现不同字号的文字底部对齐" class="headerlink" title="实现不同字号的文字底部对齐"></a>实现不同字号的文字底部对齐</h5><p>例如 ¥500 想要 ¥ 字号小一点，而 500 字号大一点，但是需要底部对齐，则可以用 Text 包裹起来，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text&gt;</span><br><span class="line">  &lt;Text style&#x3D;&#123;&#123; fontSize: 12 &#125;&#125;&gt;¥&lt;&#x2F;Text&gt;</span><br><span class="line">  &lt;Text style&#x3D;&#123;&#123; fontSize: 20 &#125;&#125;&gt;500&lt;&#x2F;Text&gt;</span><br><span class="line">&lt;&#x2F;Text&gt;</span><br></pre></td></tr></table></figure><h5 id="Text-组件样式继承"><a href="#Text-组件样式继承" class="headerlink" title="Text 组件样式继承"></a>Text 组件样式继承</h5><p>众所周知，css 如果想设置默认的全局样式相当简单，比如字体颜色默认为 ‘#323232’ , 只要在 body 上设置一下 <code>color: #323232</code> 即可 ，然而对于 RN 来说则有两种解决方案：</p><ol><li><p>将原生 Text 替换成自定义 Text 组件（官方推荐）</p><blockquote><p>The recommended way to use consistent fonts and sizes across your application is to create a component <code>MyAppText</code> that includes them and use this component across your app</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123; TextProps, StyleSheet, Text &#125; from &#39;react-native&#39;;</span><br><span class="line"></span><br><span class="line">const styles &#x3D; StyleSheet.create(&#123;</span><br><span class="line">  defaultStyle: &#123;</span><br><span class="line">    color: &#39;#323232&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default function CustomText(props: TextProps &amp; &#123; children?: any &#125;) &#123;</span><br><span class="line">  const &#123; style, ...restProps &#125; &#x3D; props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Text style&#x3D;&#123;[styles.defaultStyle, style]&#125; &#123;...restProps&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;&#x2F;Text&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参考 <a href="https://github.com/Ajackster" target="_blank" rel="noopener">Ajackster</a>/<strong><a href="https://github.com/Ajackster/react-native-global-props" target="_blank" rel="noopener">react-native-global-props</a></strong> 的实现，在项目入口位置，修改组件的 render 方法。</p></li></ol><p>方案二虽然方便，但不是官方解法，万一有坑就 GG 了。而方案一如果是已有项目，则需要批量修改代码。<br>这里顺便提一下在 vscode 里批量替换的方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 将正则，大小写，全匹配 三个按钮点亮</span><br><span class="line">find: Text(,|\s)(.*react-nativ<span class="string">e';)</span></span><br><span class="line"><span class="string">replace: $2\nimport Text from '</span>Your/<span class="type">Text</span><span class="string">';</span></span><br></pre></td></tr></table></figure><p>一开始我是这么写的，只考虑到了单行，结果下面这种情况没有替换掉：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line"><span class="built_in">  StyleSheet,</span></span><br><span class="line"><span class="built_in">  ViewStyle,</span></span><br><span class="line"><span class="built_in">  View,</span></span><br><span class="line"><span class="built_in">  Text,</span></span><br><span class="line"><span class="built_in">  Image,</span></span><br><span class="line"><span class="built_in">  TouchableOpacity,</span></span><br><span class="line">&#125; from 'react-native'<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>后面换成 <code>\sText[,|\s]\n?([\s\S]*&#39;react-native&#39;;)</code> 在浏览器里可以匹配上，但是 vscode 无法匹配 🤔。 最后简单写个脚本补全上面的漏网之鱼:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> replace = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    glob(<span class="string">'src/**/*.tsx'</span>, &#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> reg = <span class="regexp">/\sText[,|\s]\n?([\s\S]*'react-native';)/</span>;</span><br><span class="line">      files.forEach(<span class="keyword">async</span> (file) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> content = <span class="keyword">await</span> util.promisify(fs.readFile)(file, <span class="string">'utf8'</span>);</span><br><span class="line">        <span class="keyword">const</span> newContent = content.replace(reg, (m, p1) =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">` <span class="subst">$&#123;p1.trim()&#125;</span></span></span><br><span class="line"><span class="string">import Text from '@/components/Text';`</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">await</span> util.promisify(fs.writeFile)(file, newContent, <span class="string">'utf8'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">replace();</span><br></pre></td></tr></table></figure><p>🤔 上面 CustomText 的写法有一个问题，即嵌套 Text 的样式如果是自定义组件中默认的样式，将不会被继承:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;&#123; color: &#39;red&#39; &#125;&#125;&gt;</span><br><span class="line">  &lt;Text&gt;red&lt;&#x2F;Text&gt;</span><br><span class="line">  &lt;Text&gt;red&lt;&#x2F;Text&gt;</span><br><span class="line">&lt;&#x2F;Text&gt;</span><br><span class="line"></span><br><span class="line">&lt;CustomText style&#x3D;&#123;&#123; color: &#39;red&#39; &#125;&#125;&gt;</span><br><span class="line">  &lt;CustomText&gt;not red&lt;&#x2F;Text&gt;</span><br><span class="line">  &lt;CustomText&gt;not red&lt;&#x2F;Text&gt;</span><br><span class="line">&lt;&#x2F;CustomText&gt;</span><br></pre></td></tr></table></figure><p>改良版： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Children, isValidElement, cloneElement &#125; from &#39;react&#39;;</span><br><span class="line">import &#123; TextProps, StyleSheet, Text &#125; from &#39;react-native&#39;;</span><br><span class="line"></span><br><span class="line">const styles &#x3D; StyleSheet.create(&#123;</span><br><span class="line">  defaultStyle: &#123;</span><br><span class="line">    color: &#39;#323232&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default function CustomText(</span><br><span class="line">  props: TextProps &amp; &#123; children?: any; useDefaultStyle?: boolean &#125;,</span><br><span class="line">) &#123;</span><br><span class="line">  const &#123; style, useDefaultStyle &#x3D; true, ...restProps &#125; &#x3D; props;</span><br><span class="line">  const newStyle &#x3D; useDefaultStyle ? [styles.defaultStyle, style] : style;</span><br><span class="line"></span><br><span class="line">  const childrenWithProps &#x3D; Children.map(props.children, (child) &#x3D;&gt; &#123; </span><br><span class="line">   if (isValidElement(child)) &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果子元素是个组件，则子组件不使用默认 style</span><br><span class="line">      return cloneElement(child as React.ReactElement&lt;any&gt;, &#123;</span><br><span class="line">        useDefaultStyle: false,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return child;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Text style&#x3D;&#123;newStyle&#125; &#123;...restProps&#125;&gt;</span><br><span class="line">      &#123;childrenWithProps&#125;</span><br><span class="line">    &lt;&#x2F;Text&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view" target="_blank" rel="noopener">react-native-scrollable-tab-view</a></p><p><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view" target="_blank" rel="noopener">react-native-scrollable-tab-view</a> 组件作为 ScrollView 的子组件时不可用，会出现 tab 选中不一致，tab content 无法撑开的现象，详情看：<a href="https://github.com/ptomasroos/react-native-scrollable-tab-view/issues/982" target="_blank" rel="noopener">https://github.com/ptomasroos/react-native-scrollable-tab-view/issues/982</a></p></li></ul><p>未完待续～</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次搭建 react 项目遇到的坑</title>
      <link href="/2020/07/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%20react%20%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2020/07/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%20react%20%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>电商项目需要搭建一个 h5 项目。这里简单记录一下搭建过程遇到的坑，作为总结。</p><a id="more"></a><p>ui 框架：为了统一 ui 框架，因此选择使用 antd-mobile。<br>打包：parceljs 在此前的项目中已经使用过很多次了，打包速度较 cra 快，且配置简单，因此拟用 parcel。<br>ts：多人项目还是上 ts，没什么好说的。<br>很快就搭建好 demo，接着就开始遇到一些问题。</p><h5 id="antd-mobile-按需加载"><a href="#antd-mobile-按需加载" class="headerlink" title="antd-mobile 按需加载"></a>antd-mobile 按需加载</h5><p>antd-mobile 按需加载推荐使用 <a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .babelrc or babel-loader option</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"import"</span>, &#123; <span class="attr">"libraryName"</span>: <span class="string">"antd-mobile"</span>, <span class="attr">"style"</span>: <span class="string">"css"</span> &#125;] <span class="comment">// `style: true` 会加载 less 文件</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此前 parcel 实际上内置支持了 ts，直接转成 es5 了，因此此前没有额外再配置 babel。<br>🤔 babel-plugin-import 只支持 es6 module 写法的代码，看来需要先把 ts 转成 es6 然后在通过 babel 转成 es5， 没问题，安排～ 于是：</p><ol><li><p>新增 .babelrc</p></li><li><p>修改 tsconfig 的 module 为 <code>es6</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"ES6"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目启动，没问题。但是 vscode 开始报错：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">&#x2F;&#x2F; Module &#39;&quot;&#x2F;node_modules&#x2F;@types&#x2F;react&#x2F;index&quot;&#39; can only be default-imported using the &#39;allowSyntheticDefaultImports&#39; flag</span><br></pre></td></tr></table></figure><p>根本原因是由于 react 导出如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'react.development.js'</span>)</span><br></pre></td></tr></table></figure><p>而非</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.default = <span class="built_in">require</span>(<span class="string">'react.development.js'</span>)</span><br></pre></td></tr></table></figure><p>Babel 会在 commonjs 格式添加 default 导出，那我们要做的就是让 ts 不要提示这种类型的报错：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🤔 不过为什么一开始 parcel 不会报错呢？</p><p>接下来路由动态引入组件开始报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Suspense, lazy &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">const List &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;modules&#x2F;List&#39;))</span><br><span class="line">&#x2F;&#x2F; Dynamic imports are only supported when the &#39;--module&#39; flag is set to &#39;es2020&#39;, &#39;esnext&#39;, &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, or &#39;umd&#39;.</span><br></pre></td></tr></table></figure><p>看来 <code>es6</code> 是不支持 import() 语法, 那好办，将 module 改成 <code>esnext</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"ESNext"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来引入 anti-mobile 组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; List &#125; <span class="keyword">from</span> <span class="string">'antd-mobile'</span></span><br><span class="line"><span class="comment">// Cannot find module 'antd-mobile' or its corresponding type declarations.</span></span><br></pre></td></tr></table></figure><p>此时提示找不到对应的模块声明， 此时我的内心是崩溃的，看起来应该是模块解析路径不对，因此在 tsconfig 中显式配置 <code>moduleResolution</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"moduleResolution"</span>: <span class="string">"Node"</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不再报错了，看看 ts 文档的解释吧，ts 共有两种可用的模块解析策略：<a href="https://www.tslang.cn/docs/handbook/module-resolution.html#node" target="_blank" rel="noopener">Node</a>和<a href="https://www.tslang.cn/docs/handbook/module-resolution.html#classic" target="_blank" rel="noopener">Classic</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> === <span class="string">"AMD"</span> or <span class="string">"System"</span> or <span class="string">"ES6"</span> ? <span class="string">"Classic"</span> : <span class="string">"Node"</span></span><br></pre></td></tr></table></figure><p>🤔 按理说 module 为 esnext 的话岂不是应该按 node 策略解析？但是目前看来似乎不是这样的？</p><h5 id="配置-antd-mobile-主题"><a href="#配置-antd-mobile-主题" class="headerlink" title="配置 antd-mobile 主题"></a>配置 antd-mobile 主题</h5><p>接下来需要配置主题，anti-mobile 推荐使用 <a href="http://lesscss.org/usage/#using-less-in-the-browser-modify-variables" target="_blank" rel="noopener">modifyVars</a> 来配置主题。<br>将 .babelrc 改成做一下调整：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [<span class="string">"import"</span>, &#123;<span class="string">"libraryName"</span>: <span class="string">"antd-mobile"</span>, <span class="string">"style"</span>: <span class="literal">true</span>&#125;],</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照 webpack 的经验，此时需要开启 <code>javascriptEnabled: true</code>问题来了 parcel 内置支持 less ，那我们要在哪里去配置 less 呢？根据 <a href="https://github.com/parcel-bundler/parcel/issues/907" target="_blank" rel="noopener">issue</a> 提到可以用 .lessrc 文件来配置，但是我经过尝试发现其实是无效的。。<br>至此基本放弃 parcel。parcel 在快速搭建实验性项目时确实有一定的优势，不过生态确实不如 webpack，由此转向使用 create-react-app</p><h5 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h5><p>使用 cra 很快也建好 demo，解决如何让 cra 创建的项目支持 less ，这个简单：<br>通过 <code>customize-cra</code> 提供的 <code>addLessLoader</code> 方法即可，同时也提供了 <code>fixBabelImports</code> 可以很方便的添加 babel-plugin-import 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; override, fixBabelImports, addLessLoader &#125; = <span class="built_in">require</span>(<span class="string">'customize-cra'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = override(</span><br><span class="line">  fixBabelImports(<span class="string">'import'</span>, &#123;</span><br><span class="line">    libraryName: <span class="string">'antd-mobile'</span>,</span><br><span class="line">    style: <span class="literal">true</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  addLessLoader(&#123;</span><br><span class="line">    lessOptions: &#123;</span><br><span class="line">      javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">      modifyVars: &#123;</span><br><span class="line">        <span class="string">'@brand-primary'</span>: <span class="string">'#ff74b9'</span>,</span><br><span class="line">        <span class="string">'brand-primary-tap'</span>: <span class="string">'#ff9cca'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><p>接着是配置路径别名遇到的问题，通过 <code>customize-cra</code> 提供的 <code>addWebpackAlias</code> 可以配置别名，但是 typescript 一直无法解析对应别名，那么应该只需要配置好 ts 的 paths 就行了吧：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"baseUrl"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="attr">"paths"</span>: &#123;</span><br><span class="line">      <span class="attr">"@/*"</span>: [<span class="string">"./src/*"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vscode 不再报错了,接下来就是见证奇迹的时刻了<code>npm run start</code>：<br>控制台显示 <code>- compilerOptions.paths must not be set (aliased imports are not supported)</code> 并且 cra 会自动把 tscongfig 中的 paths 移除掉 😂<br>根据 <a href="https://github.com/timarney/react-app-rewired/issues/375" target="_blank" rel="noopener">issue</a>，使用将 baseUrl 和 paths 的配置移动到单独的文件后，在 tsconfig 里通过 extends 的方式继承，虽然控制台依然提示错误，但是别名可以生效。</p><h5 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h5><p>在 build 时，mini-css-extract-plugin 提示 Conflicting order， 错误位置在 antd-mobile 的样式文件。根据 <a href="https://github.com/ant-design/ant-design/issues/14895" target="_blank" rel="noopener">issue</a> 以及 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250" target="_blank" rel="noopener"> issue </a>看来这个问题主要是由于懒加载加上 antd 组件导入顺序不一致导致的，目前看来无需解决。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学 Generator《一》</title>
      <link href="/2020/07/15/%E9%87%8D%E5%AD%A6%20Generator%E3%80%8A%E4%B8%80%E3%80%8B/"/>
      <url>/2020/07/15/%E9%87%8D%E5%AD%A6%20Generator%E3%80%8A%E4%B8%80%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>在实际工作的业务开发中，使用到 Generator 比较少。近期有个项目状态管理使用的是 redux-saga，而 redux-saga 又是基于 Generator，借此机会重新学了下 Generator。</p><p>本文主要是记录 generator 的要点，以防将来遗忘。</p><a id="more"></a><h5 id="调用-generator-将会返回一个迭代器"><a href="#调用-generator-将会返回一个迭代器" class="headerlink" title="调用 generator 将会返回一个迭代器"></a>调用 generator 将会返回一个迭代器</h5><p>所谓 generator 实际上就是带有 * 的函数，调用后不会执行 generator 内部代码，而是返回一个 iterator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'generator'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction()</span><br><span class="line"><span class="built_in">console</span>.log(iterator[<span class="built_in">Symbol</span>.iterator])</span><br><span class="line"></span><br><span class="line"><span class="comment">// function [Symbol.iterator]()</span></span><br></pre></td></tr></table></figure><h5 id="执行-generator"><a href="#执行-generator" class="headerlink" title="执行 generator"></a>执行 generator</h5><p>每次调用返回的迭代器的 next 方法可以执行 generator 中的代码，直到执行完遇到的第一个 yield 或者 return 后并交出执行权</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">  <span class="keyword">yield</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction()</span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h5 id="return-与-yield-的异同"><a href="#return-与-yield-的异同" class="headerlink" title="return 与 yield 的异同"></a>return 与 yield 的异同</h5><p>执行 iterator.next 返回的是一个包括 value 和 done 两个属性的对象，这个对象的 value 就是 <code>yield</code> 或 <code>return</code> 后面表达式的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction()</span><br><span class="line"><span class="keyword">var</span> a = iterator.next()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="keyword">var</span> b = iterator.next()</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>yield 与 return 类似，但 yield 是暂停的意思，而 return 则代表结束, return 之后的代码将不会被执行到。</p><p>done 为 true 表示遍历结束，但是此时依然可以可以继续调用 iterator.next()，只不过返回值将是 { value: undefined, done: true }。</p><p><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，直到 done 变为 true。</p><p>⚠️ done 为 true 的运行结果会被抛弃掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h5 id="next-的参数"><a href="#next-的参数" class="headerlink" title="next 的参数"></a>next 的参数</h5><p>next 的参数可以最为 yield 语句的返回值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">yield</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// a 1</span></span><br></pre></td></tr></table></figure><h5 id="yield"><a href="#yield" class="headerlink" title="yield *"></a>yield *</h5><p>通过 yield * 可以进入到另一个 generator 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'foo'</span>;</span><br><span class="line">    <span class="keyword">yield</span> * bar();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'bar'</span>;</span><br><span class="line">    <span class="keyword">yield</span> * baz();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'baz'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure><h5 id="向-generaotr-内部抛异常"><a href="#向-generaotr-内部抛异常" class="headerlink" title="向 generaotr 内部抛异常"></a>向 generaotr 内部抛异常</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="string">'a'</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Generator caught'</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction();</span><br><span class="line">iterator.next();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    iterator.throw(<span class="string">'a'</span>);</span><br><span class="line">    iterator.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Uncaught'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Generator caught a</span></span><br><span class="line"><span class="comment">// Uncaught b</span></span><br></pre></td></tr></table></figure><p>资料主要参考自  <a href="https://github.com/gajus/gajus.com-blog/blob/master/posts/the-definitive-guide-to-the-javascript-generators/index.md" target="_blank" rel="noopener">generator 权威指南</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
