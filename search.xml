<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RN瀑布流</title>
      <link href="/2020/10/20/RN%E7%80%91%E5%B8%83%E6%B5%81/"/>
      <url>/2020/10/20/RN%E7%80%91%E5%B8%83%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>电商以及图片网站经常可以看到瀑布流的列表，即多列等宽的列表，但是每一列中的元素高度不一定一致。这在 web 是一个很常见的设计且有很多组件可供使用，而在 ReactNative 中，少有成熟的瀑布流组件，大多数组件要么是多年前维护的，要么 star 数较少，或者干脆有一些不维护了，总之就是用着不放心。因此在产品同学的要求下，尝试来实现一个 RN 瀑布流组件。</p><a id="more"></a><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ol><li><p>支持上拉加载，下拉刷新</p></li><li><p>支持多列可定制</p></li><li><p>性能尽量好</p></li><li><p>自定义元素</p></li><li><p>效果大概如图 ，原设计稿就不贴了，从花瓣截个图</p><img src="https://i.loli.net/2020/10/20/8gxisTetz1qOYG4.png" alt="image.png"></li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>整个瀑布流通过 FlatList 来实现，通过设置 columnsNum 与 renderItem，将每一列又分别渲染成一个 FlatList。内层并列的 FlatList 不会产生多余的滚动条，即他们的高度会被最长的列撑开，滚动时是外层的 FlatList。</li><li>判断每一项应该属于哪一列， 如果项的高度不能提前获得，那么要在项的 onLayout 时获取高度，之后判断下一项</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-native 通讯录字母列表</title>
      <link href="/2020/09/22/react-native-%E9%80%9A%E8%AE%AF%E5%BD%95%E5%AD%97%E6%AF%8D%E5%88%97%E8%A1%A8/"/>
      <url>/2020/09/22/react-native-%E9%80%9A%E8%AE%AF%E5%BD%95%E5%AD%97%E6%AF%8D%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>需求：实现一个选择快递的页面，操作类似于通讯录，设计图如下</p><img src="https://i.loli.net/2020/10/20/OwH5A3bRgSuiBKt.png" alt="image.png" style="zoom: 50%"><p>上半部分的搜索交互及实现这里就不赘述，重点探讨字母列表的实现。</p><a id="more"></a><p>需要实现的点：</p><ol><li>主列表分组，头部不吸顶</li><li>字母列表可以滑动或点击，变更当前选中的字母，且主列表跟随滑动定位</li><li>主列表滚动时，字母列表当前选中的字母对应变化</li></ol><p>搜索了目前已有的开源组件，要么最后一次更新的时间也比较久远，要么不适用于我们的场景，要么 star 数量不多 😂。因此打算重新造个轮子，即使将来有什么问题，也能自行维护。</p><h4 id="AlphabetList"><a href="#AlphabetList" class="headerlink" title="AlphabetList"></a>AlphabetList</h4><p>将我们的组件命名为 AlphabetList，它将接收一个 dataSource ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;AlphabetList dataSource&#x3D;&#123;dataSource&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>dataSource 的结构如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IListItem &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  value: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> ISectionItem &#123;</span><br><span class="line">sectionKey: <span class="built_in">string</span>;</span><br><span class="line">data: &#123;</span><br><span class="line">name: <span class="built_in">string</span>;</span><br><span class="line">value: <span class="built_in">string</span></span><br><span class="line">&#125;[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> DataSource: SectionItem[]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    sectionKey: <span class="string">'常'</span>,</span><br><span class="line">    data: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'顺丰物流'</span>,</span><br><span class="line">        value: <span class="string">'1'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'京东快递'</span>,</span><br><span class="line">        value: <span class="string">'2'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    sectionKey: <span class="string">'A'</span>,</span><br><span class="line">    data: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'安能物流'</span>,</span><br><span class="line">        value: <span class="string">'3'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'澳大利亚邮政'</span>,</span><br><span class="line">        value: <span class="string">'4'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>AlphabetList 的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;View&gt;</span><br><span class="line">  &#123;&#x2F;* 主列表 *&#x2F;&#125;</span><br><span class="line">  &lt;MainList &#x2F;&gt;</span><br><span class="line">  &#123;&#x2F;* 右侧字母列表 *&#x2F;&#125;</span><br><span class="line">  &lt;SideBar &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure><h4 id="MainList"><a href="#MainList" class="headerlink" title="MainList"></a>MainList</h4><p>主列表分组 Main，那么使用 SectionList 是一个不错的选择（当然也可以用 FlatList 来实现）</p><p>当滚动 MainList 时，通过 <code>onListViewableItemsChanged</code> 的回调可以得到当前窗口可视的分组，从而改变当前选中的字母</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const MainList &#x3D; (&#123;</span><br><span class="line">    dataSource,</span><br><span class="line">    onMainListViewableItemsChanged,</span><br><span class="line">  &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;SectionList</span><br><span class="line">      renderItem&#x3D;&#123;(&#123; item &#125;) &#x3D;&gt; (&lt;ListItem item&#x3D;&#123;item&#125; &#x2F;&gt;)&#125;</span><br><span class="line">      renderSectionHeader&#x3D;&#123;(&#123; section &#125;) &#x3D;&gt; &lt;SectionHeader section&#x3D;&#123;section&#125; &#x2F;&gt;&#125;</span><br><span class="line">      keyExtractor&#x3D;&#123;(item) &#x3D;&gt; &#96;$&#123;item.value&#125;&#96;&#125;</span><br><span class="line">      sections&#x3D;&#123;dataSource&#125;</span><br><span class="line">      stickySectionHeadersEnabled&#x3D;&#123;false&#125;</span><br><span class="line">      onViewableItemsChanged&#x3D;&#123;onMainListViewableItemsChanged&#125;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default MainList;</span><br></pre></td></tr></table></figure><p>在 AlphabetList 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const AlphabetList &#x3D; (&#123; dataSource &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 右侧字母表列表</span><br><span class="line">  const letterlist &#x3D; dataSource.map((item) &#x3D;&gt; &#123;</span><br><span class="line">    return item.sectionKey;</span><br><span class="line">  &#125;);</span><br><span class="line">  const [currentSectionKey, setCurrentSectionKey] &#x3D; useState(letterlist);</span><br><span class="line">  const onMainListViewableItemsChanged &#x3D; (info: &#123;</span><br><span class="line">    viewableItems: ViewToken[];</span><br><span class="line">  &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 将选中的字母设置为当前第一个可见 section 的 sectionKey</span><br><span class="line">    setCurrentSectionKey(info.viewableItems[0].section.sectionKey);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;View style&#x3D;&#123;styles.container&#125;&gt;</span><br><span class="line">      &#123;&#x2F;* 主列表 start *&#x2F;&#125;</span><br><span class="line">      &lt;MainList</span><br><span class="line">        dataSource&#x3D;&#123;dataSource&#125;</span><br><span class="line">        onMainListTouchStart&#x3D;&#123;() &#x3D;&gt; setCurrentResponder(&#39;mainList&#39;)&#125;</span><br><span class="line">        onMainListViewableItemsChanged&#x3D;&#123;onMainListViewableItemsChanged&#125;</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">      &#123;&#x2F;* 主列表 end *&#x2F;&#125;</span><br><span class="line">      &#123;&#x2F;* 右侧字母列表 start *&#x2F;&#125;</span><br><span class="line">      &lt;SideBar &#x2F;&gt;</span><br><span class="line">      &#123;&#x2F;* 右侧字母列表 end *&#x2F;&#125;</span><br><span class="line">    &lt;&#x2F;View&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default AlphabetList;</span><br></pre></td></tr></table></figure><h4 id="SideBar"><a href="#SideBar" class="headerlink" title="SideBar"></a>SideBar</h4><p>侧边栏的实现比起来则要复杂一些，这里使用一个绝对定位的 FlatList，实际上简单使用 View 去实现也是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const SideBar &#x3D; (&#123;</span><br><span class="line">  letterlist,</span><br><span class="line">  &#x2F;&#x2F; 回调</span><br><span class="line">  handleSideBarItemRespond,</span><br><span class="line">  currentSectionKey</span><br><span class="line">&#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FlatList</span><br><span class="line">      style&#x3D;&#123;styles.wrap&#125;</span><br><span class="line">      scrollEnabled&#x3D;&#123;false&#125;</span><br><span class="line">      data&#x3D;&#123;letterlist&#125;</span><br><span class="line">      renderItem&#x3D;&#123;(&#123; item, index &#125;) &#x3D;&gt; (</span><br><span class="line">        &lt;Item</span><br><span class="line">          item&#x3D;&#123;item&#125;</span><br><span class="line">          handleSideBarItemRespond&#x3D;&#123;handleSideBarItemRespond&#125;</span><br><span class="line">          letterlist&#x3D;&#123;letterlist&#125;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">      keyExtractor&#x3D;&#123;item &#x3D;&gt; item&#125;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一开始我的想法是通过监听 Item 的 onPress | onPressIn ，从一项滑动到另一项的时候，依次触发事件，实验后发现，在释放手势之前，仅会有一个响应的元素。</p><p>这里就得提一下 RN 的手势系统了。</p><h5 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h5><p>在 React Native 中，响应手势的基本单位是<code>responder</code>，并且仅有一个 <code>responder</code> 拥有控制权。在 View 上有这些属性：</p><ol><li>onStartShouldSetResponder：点击时是否变成一个 responder</li><li>onMoveShouldSetResponder：滑动时是否变成一个 responder</li><li>onResponderGrant： 点击时的回调</li><li>onResponderMove：移动时的回调</li><li>onResponderTerminationRequest：当别的元素希望成为 responder 时，是否要释放当前的 responder？</li><li>onResponderRelease：当 reponder 释放时的回调</li><li>等等</li></ol><p>通过上述这些 API 我们就能很容易的实现一些手势。初次之外，RN 还提供了更高级的抽象 PanResponder，它可以给我们提供更多手势信息，这里不展开解释。</p><p>不过当我尝试在每个 Item 上设置手势响应，并且设置  onResponderTerminationRequest 为 <code>() =&gt; true</code>，手势依然没有在切换 Item 时释放原 responder。</p><p>因此只能通过计算高度来获取滑动时当前的字母</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evt.nativeEvent.pageY: 触摸事件的 pageY</span></span><br><span class="line"><span class="comment">// sideBarTop: SideBar 的 pageY</span></span><br><span class="line"><span class="comment">// letterHeight：每个字母的高度</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="built_in">Math</span>.floor((evt.nativeEvent.pageY - sideBarTop) / letterHeight);</span><br></pre></td></tr></table></figure><p>要获取元素距离屏幕的高度，可以在 onLayout 的时候，调用 measure 来获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const SideBar &#x3D; (&#123;</span><br><span class="line">  letterlist,</span><br><span class="line">  handleSideBarItemRespond,</span><br><span class="line">  currentSectionKey,</span><br><span class="line">  letterHeight,</span><br><span class="line">&#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  const [sideBarTop, setSideBarTop] &#x3D; useState(0);</span><br><span class="line">  const sideBarRef &#x3D; useRef&lt;View&gt;(null);</span><br><span class="line">  const measure &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    if (sideBarRef.current) &#123;</span><br><span class="line">      sideBarRef.current.measure((x, y, width, height, pageX, pageY) &#x3D;&gt; &#123;</span><br><span class="line">        setSideBarTop(pageY);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;View onLayout&#x3D;&#123;measure&#125; ref&#x3D;&#123;sideBarRef&#125;&gt;</span><br><span class="line">      &lt;FlatList&lt;string&gt;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;View&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就是 Item 的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const Item &#x3D; (&#123;</span><br><span class="line">  item,</span><br><span class="line">  handleSideBarItemRespond,</span><br><span class="line">  isCurrentSectionKey,</span><br><span class="line">  letterlist,</span><br><span class="line">  letterHeight,</span><br><span class="line">  sideBarTop,</span><br><span class="line">&#125;: &#123;</span><br><span class="line">  item: string;</span><br><span class="line">  isFirst: boolean;</span><br><span class="line">  handleSideBarItemRespond: (item: string) &#x3D;&gt; void;</span><br><span class="line">  letterlist: string[];</span><br><span class="line">  letterHeight: number;</span><br><span class="line">  sideBarTop?: number;</span><br><span class="line">&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  const panResponder &#x3D; PanResponder.create(&#123;</span><br><span class="line">    onStartShouldSetPanResponderCapture: () &#x3D;&gt; true,</span><br><span class="line">    onStartShouldSetPanResponder: () &#x3D;&gt; true,</span><br><span class="line">    &#x2F;&#x2F; 尝试通过 onResponderTerminationRequest 来终止手势，发现不生效，只能通过计算偏移量来获取当前选中</span><br><span class="line">    onPanResponderTerminationRequest: () &#x3D;&gt; true,</span><br><span class="line">    onPanResponderGrant: () &#x3D;&gt; &#123;</span><br><span class="line">      handleSideBarItemRespond(item);</span><br><span class="line">    &#125;,</span><br><span class="line">    onPanResponderMove: (evt, gs) &#x3D;&gt; &#123;</span><br><span class="line">      if (!sideBarTop) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      const index &#x3D; Math.floor(</span><br><span class="line">        (evt.nativeEvent.pageY - sideBarTop) &#x2F; letterHeight,</span><br><span class="line">      );</span><br><span class="line">      if (index &gt;&#x3D; 0 &amp;&amp; index &lt; letterlist.length) &#123;</span><br><span class="line">        &#x2F;&#x2F; 触发侧边字母选中的回调</span><br><span class="line">        handleSideBarItemRespond(letterlist[index]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;View &#123;...panResponder.panHandlers&#125;&gt;</span><br><span class="line">      &lt;Text&gt;</span><br><span class="line">        &#123;item&#125;</span><br><span class="line">      &lt;&#x2F;Text&gt;</span><br><span class="line">    &lt;&#x2F;View&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到此为止，侧边栏的逻辑已经完成。现在处理侧边栏事件的回调逻辑, 主要通过 scrollToLocation 来实现列表滚动到对应的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const AlphabetList &#x3D; (&#123; dataSource, companyList, onCompanySelect &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  const mainListRef &#x3D; useRef&lt;SectionList&lt;IListItem&gt;&gt;(null);</span><br><span class="line">  const handleSideBarItemRespond &#x3D; (item: string) &#x3D;&gt; &#123;</span><br><span class="line">    if (!mainListRef.current) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F; 记录当前选中的字母</span><br><span class="line">    setCurrentSectionKey(item);</span><br><span class="line">    mainListRef.current.scrollToLocation(&#123;</span><br><span class="line">      sectionIndex: dataSource.findIndex((data) &#x3D;&gt; data.sectionKey &#x3D;&#x3D;&#x3D; item),</span><br><span class="line">      itemIndex: 0,</span><br><span class="line">      animated: false,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;View style&#x3D;&#123;styles.container&#125;&gt;</span><br><span class="line">      &#123;&#x2F;* 主列表 start *&#x2F;&#125;</span><br><span class="line">      &lt;MainList</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">        ref&#x3D;&#123;mainListRef&#125;</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    &lt;&#x2F;View&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里需要通过 React.forwardRef 获取到 MainList 的 ref</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const MainList: React.ForwardRefRenderFunction&lt;</span><br><span class="line">  SectionList&lt;IListItem&gt;,</span><br><span class="line">  IProps</span><br><span class="line">&gt; &#x3D; (</span><br><span class="line">  &#123;</span><br><span class="line">    dataSource,</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ref,</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line"> &#x2F;&#x2F; ...</span><br><span class="line">  return (</span><br><span class="line">    &lt;SectionList</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">      ref&#x3D;&#123;ref&#125;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">export default React.forwardRef(MainList)</span><br></pre></td></tr></table></figure><p>到这一步，已经基本完成了一个通讯录字母列表。</p><h4 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h4><p>在完成上述功能后，由于点击侧边栏会滚动主列表，此时也会触发 MainList 的 onViewableItemsChanged，因此需要一个标识来区分是什么动作触发的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const AlphabetList &#x3D; (&#123; dataSource, companyList, onCompanySelect &#125;: IProps) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 标识位：用于区分当前的操作是由什么触发的</span><br><span class="line">  const [currentResponder, setCurrentResponder] &#x3D; useState(&#39;&#39;);</span><br><span class="line">  const mainListRef &#x3D; useRef&lt;SectionList&lt;IListItem&gt;&gt;(null);</span><br><span class="line">  &#x2F;&#x2F; 右侧字母表列表</span><br><span class="line">  const letterlist &#x3D; dataSource.map((item) &#x3D;&gt; &#123;</span><br><span class="line">    return item.sectionKey;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const [currentSectionKey, setCurrentSectionKey] &#x3D; useState(letterlist[0]);</span><br><span class="line"></span><br><span class="line">  const handleSideBarItemRespond &#x3D; (item: string) &#x3D;&gt; &#123;</span><br><span class="line">    if (!mainListRef.current) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    setCurrentResponder(&#39;sideBar&#39;);</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const onMainListViewableItemsChanged &#x3D; (info: &#123;</span><br><span class="line">    viewableItems: ViewToken[];</span><br><span class="line">  &#125;) &#x3D;&gt; &#123;</span><br><span class="line">    if (</span><br><span class="line">      &#x2F;&#x2F; 侧边栏触发的滚动则不触发</span><br><span class="line">      currentResponder &#x3D;&#x3D;&#x3D; &#39;sideBar&#39; ||</span><br><span class="line">      !info.viewableItems[0].section.sectionKey</span><br><span class="line">    ) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    setCurrentSectionKey(info.viewableItems[0].section.sectionKey);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;View style&#x3D;&#123;styles.container&#125;&gt;</span><br><span class="line">      &#123;&#x2F;* 主列表 start *&#x2F;&#125;</span><br><span class="line">      &lt;MainList</span><br><span class="line">       &#x2F;&#x2F; ...</span><br><span class="line">        onMainListTouchStart&#x3D;&#123;() &#x3D;&gt; setCurrentResponder(&#39;mainList&#39;)&#125;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">      &#123;&#x2F;* 主列表 end *&#x2F;&#125;</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">    &lt;&#x2F;View&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><p>功能是基本上完成了，然而由于这里的数据量比较多，大概有 600 条数据，且由于 SectionList 也是基于 VirtualList，因此导致了以下长列表固有的几个问题：</p><ol><li>快速滚动 MainList，当 SectionList 来不及渲染时，会导致屏幕空白</li><li>当使用 scrollToLocation 时，如果定位到来不及渲染的区域，将会报错，提示需要设置 getItemLayout 属性，这个属性是用于计算主列表每一项高度以及偏移量的</li></ol><p>在尝试了一些优化的手段后，如 React.memo, initialNumToRender，getItemLayout 等属性依然无法有效解决上述问题。。</p><p>RN 的 list 真的是让人一言难尽。。不知道是否原生组件或者 flutter 对长列表的支持会更好一点呢 😂</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> TypeScript 的 enum 类型收窄问题</title>
      <link href="/2020/09/21/TypeScript-%E7%9A%84-enum-%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/09/21/TypeScript-%E7%9A%84-enum-%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在项目中看到一段小伙伴写的代码，简化后大概如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> A &#123;</span><br><span class="line">  <span class="string">"ONE"</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="string">"TWO"</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? A.ONE : A.TWO</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? a : <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(b === <span class="number">1</span> || b === <span class="number">2</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，b === 2 处 ts 会提示:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This condition will <span class="keyword">always</span> <span class="keyword">return</span> <span class="string">'false'</span> since the <span class="keyword">types</span> <span class="string">'0'</span> <span class="keyword">and</span> <span class="string">'2'</span> have <span class="keyword">no</span> overlap.ts(<span class="number">2367</span>)</span><br></pre></td></tr></table></figure><p>为何 TypeScript 会提示 0 与 2 没有重合的地方呢？</p><a id="more"></a><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>鼠标悬浮在 b === 1 时，提示 b 的类型为 A ｜ 0 的联合类型，而到了 b === 2 时，却变成了 <code>b: 0</code>。那么也就是说 TypeScript 在判断 b !== 1 时，就判定 b 不可能为类型 A，此时将类型收窄为 0。而 0 不可能 assgin 给 2，因此报错。上网搜索似乎也没有得到为何时这种收窄策略的原因，仅有一个可能有关联的 <a href="https://github.com/Microsoft/TypeScript/issues/9998" target="_blank" rel="noopener">https://github.com/Microsoft/TypeScript/issues/9998</a> , 然而至今还是 open 的。</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>那我们要怎么解决这个报错呢？实际上我们将判断的右值改成 enum 即可，且逻辑更清晰，维护更简单：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(b === A.ONE || b === A.TWO) &#123;</span><br><span class="line"><span class="comment">// no error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者下面这种也可以（不是很推荐，没有发挥出 enum 应有的作用）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(b <span class="keyword">as</span> A === <span class="number">1</span> || b === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// no error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 cookie</title>
      <link href="/2020/09/21/%E5%85%B3%E4%BA%8E-cookie/"/>
      <url>/2020/09/21/%E5%85%B3%E4%BA%8E-cookie/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>目前在我们的后台项目中，用户的登录信息主要是存放在 cookie 中。读写 cookie 的过程主要是服务端的工作，所以前端负责业务的同学有可能接触不到，但是 cookie 又与网络完全，跨域，代理等等诸多概念有关联，因此于本文记录我所了解的 cookie。</p><h4 id="本地开发代理"><a href="#本地开发代理" class="headerlink" title="本地开发代理"></a>本地开发代理</h4><p>本地开发时通常会将接口代理到测试环境</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次bug排查</title>
      <link href="/2020/09/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1bug%E6%8E%92%E6%9F%A5/"/>
      <url>/2020/09/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1bug%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>测试同学提了一个测试环境表格无法切换每页条数的 bug。</p><h4 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h4><p>在测试环境操作后发现，确实存在该问题，但是切换到对应测试分支，本地运行，未能重现。</p><a id="more"></a><p>在测试环境的操作发现实际上切换每页条数的回调 onShowSizeChange 确实会触发，但是此后又变回原每页条数。</p><p>对于测试环境与本地开发的表现不一致，在排除了各种可能性之后，猜测是依赖版本不一致导致的。</p><p>版本不一致出现问题此前已经出现过一次：我本地的有段代码提示了一个 eslint 的 no-throw-literal，但是别的同事都没有报错， eslintrc 的配置是一样的。最终发现是我的 umi 版本比较高，其中依赖的 @typescript-eslint/eslint-plugin 在 2.13.0 新增了 no-throw-literal 这个配置，而别的小伙伴们的版本低于此，故不会报错。</p><p>因此执行命令 <code>npm ci</code> ，该命令会按照 packge-lock.json 中记录的版本进行安装,下面是这个命令的说明</p><blockquote><p>This command is similar to <code>npm-install</code>, except it’s meant to be used in automated environments such as test platforms, continuous integration, and deployment – or any situation where you want to make sure you’re doing a clean install of your dependencies. It can be significantly faster than a regular npm install by skipping certain user-oriented features. It is also more strict than a regular install, which can help catch errors or inconsistencies caused by the incrementally-installed local environments of most npm users.</p></blockquote><p>重新安装依赖之后果然本地可以重现该问题。</p><p>此后经过 debug 发现，切换 pageSize 会先后触发 onShowSizeChange 和表格的 onChange，表格的 onChange 重新将 pageSize 设置回去。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最终如何解决上述 bug 就不赘述了。</p><p>主要想总结的是：遇到 bug，如果出现代码和运行环境之类的各种条件都一致，但是表现就是不一致的情况，那么很有可能是依赖包的版本不一致导致的 👻</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易 redux</title>
      <link href="/2020/09/14/%E7%AE%80%E6%98%93-redux/"/>
      <url>/2020/09/14/%E7%AE%80%E6%98%93-redux/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Redux 常常配合 react-redux 作为状态管理应用在 React 的项目中，并且基于 redux 发展出了 dva 之类的诸多状态管理工具。</p><p>说来惭愧，虽然在项目中常常使用到，但是并未阅读过 redux 的源码，了解其原理。本文作为学习笔记，并根据 redux 的比较核心的 createStore 这部分代码实现一个简易版本的 redux，以便将来回顾。</p><a id="more"></a><h4 id="redux-demo"><a href="#redux-demo" class="headerlink" title="redux demo"></a>redux demo</h4><p>redux 提供了使用 demo 如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是个 reducer，纯函数，用于描述状态是如何转变的</span></span><br><span class="line"><span class="comment"> * reducer 接收 state 和 action 作为参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">state = <span class="number">0</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createStore：接收 reducer 作为参数，以此构建一个 store</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(counter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅 store, 每次 dispatch 的时候，都将触发回调</span></span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.getState()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispath 一个 action</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br></pre></td></tr></table></figure><h4 id="简化的数据流"><a href="#简化的数据流" class="headerlink" title="简化的数据流"></a>简化的数据流</h4><img src="https://images.gitee.com/uploads/images/2020/0914/154038_ccc93a28_1748283.png" alt="fiber" style="zoom:50%;" /><p>以上的数据流简化了 combineReducers 等过程</p><h4 id="简易-redux"><a href="#简易-redux" class="headerlink" title="简易 redux"></a>简易 redux</h4><p>可以看出 redux 实际上就是一个发布订阅模式，简易版实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> state</span><br><span class="line">  <span class="comment">// 订阅的回调</span></span><br><span class="line">  <span class="keyword">let</span> listeners = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 state</span></span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 更新 state</span></span><br><span class="line">    state = reducer(state, action)</span><br><span class="line">    <span class="comment">// 一旦 dispatch 就执行所有订阅的回调</span></span><br><span class="line">    listeners.forEach(<span class="function">(<span class="params">listener</span>) =&gt;</span> listener())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 收集回调</span></span><br><span class="line">    listeners.push(listener)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 取消订阅</span></span><br><span class="line">      listeners = listeners.filter(<span class="function">(<span class="params">l</span>) =&gt;</span> l !== listener)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getState,</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>告别魔法数字</title>
      <link href="/2020/09/12/%E5%91%8A%E5%88%AB%E9%AD%94%E6%B3%95%E6%95%B0%E5%AD%97/"/>
      <url>/2020/09/12/%E5%91%8A%E5%88%AB%E9%AD%94%E6%B3%95%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>在以往的开发中往往会出现类似以下的代码</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(status === <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(status === <span class="number">2</span>) &#123;</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的 <code>1</code>，<code>2</code>，<code>3</code>就是所谓的魔法数字，即没有注释的情况下我们很难知道 1，2，3 代表的到底是什么 status。</p><a id="more"></a><h4 id="常量对象"><a href="#常量对象" class="headerlink" title="常量对象"></a>常量对象</h4><p>在 javascript 中，我们可以将这些数字维护在一个常量对象中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  ERROR: <span class="number">1</span>,</span><br><span class="line">  NORMAL: <span class="number">2</span>,</span><br><span class="line">  SUCCESS: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时就可以使用 STATUS.ERROR 来替换掉 1。</p><p>这样可以很清晰就分清楚 1，2，3 这些数值对应的是什么含义。同时如果将来 ERROR 不再是 1，我们也只需要维护 STATUS 即可。</p><h4 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h4><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>而在 TypeScript 中，我们则可以使用枚举类型来维护这些数值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> STATUS &#123;</span><br><span class="line">  ERROR = <span class="number">1</span>,</span><br><span class="line">  NORMAL,</span><br><span class="line">  SUCCESS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时同样是 STATUS.ERROR 替换掉 1 即可。</p><p>关于 enums 的使用<a href="https://www.tslang.cn/docs/handbook/enums.html" target="_blank" rel="noopener">文档</a>里描述的已经很清楚，这里不再赘述。</p><h4 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h4><p>值得一提的是 enums 提供了常量对象不具备的反向映射（value<code>-&gt;</code>name ）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  ERROR: <span class="number">1</span>,</span><br><span class="line">  NORMAL: <span class="number">2</span>,</span><br><span class="line">  SUCCESS: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出："ERROR"</span></span><br><span class="line">STATUS[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>这是因为 ts 将上述的 enums 编译成以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> STATUS;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">STATUS</span>) </span>&#123;</span><br><span class="line">  STATUS[STATUS[<span class="string">"ERROR"</span>] = <span class="number">1</span>] = <span class="string">"ERROR"</span>;</span><br><span class="line">  STATUS[STATUS[<span class="string">"NORMAL"</span>] = <span class="number">2</span>] = <span class="string">"NORMAL"</span>;</span><br><span class="line">  STATUS[STATUS[<span class="string">"SUCCESS"</span>] = <span class="number">3</span>] = <span class="string">"SUCCESS"</span>;</span><br><span class="line">&#125;)(STATUS || (STATUS = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>⚠️ 但如果是字符串枚举成员则不会生成反向映射。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> STATUS &#123;</span><br><span class="line">  ERROR = <span class="string">"1"</span>,</span><br><span class="line">  NORMAL = <span class="string">"2"</span>,</span><br><span class="line">  SUCCESS = <span class="string">"3"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">var</span> STATUS;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">STATUS</span>) </span>&#123;</span><br><span class="line">  STATUS[<span class="string">"ERROR2"</span>] = <span class="string">"1"</span>;</span><br><span class="line">  STATUS[<span class="string">"NORMAL"</span>] = <span class="string">"2"</span>;</span><br><span class="line">  sSTATUS[<span class="string">"SUCCESS"</span>] = <span class="string">"3"</span>;</span><br><span class="line">&#125;)(STATUS || (STATUS = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>并且对于重复定义的枚举类型，将会合并成员：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> STATUS &#123;</span><br><span class="line">  ERROR = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> STATUS &#123;</span><br><span class="line">  NORMAL = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">enum</span> STATUS &#123;</span><br><span class="line">  ERROR = <span class="number">1</span>,</span><br><span class="line">  NORMAL = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const-枚举"><a href="#const-枚举" class="headerlink" title="const 枚举"></a>const 枚举</h4><p>关于枚举，还有一种不是常见的写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> STATUS &#123;</span><br><span class="line">  ERROR = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即声明前有个关键字 const。</p><p>与常规枚举不同的地方在于</p><ol><li>const 枚举不会编译出额外的代码</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> STATUS &#123;</span><br><span class="line">  ERROR = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(STATUS.ERROR)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终的编译出的代码不包含 STATUS</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="comment">/* ERROR */</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>也正因为编译阶段就会确定下枚举的成员，const 枚举不可以包含计算成员</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geterror = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> STATUS &#123;</span><br><span class="line">  <span class="comment">// In 'const' enum declarations member initializer must be constant expression.</span></span><br><span class="line">  ERROR = geterror()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于图片</title>
      <link href="/2020/09/11/%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87/"/>
      <url>/2020/09/11/%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React 泛型组件</title>
      <link href="/2020/09/08/React%20%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/09/08/React%20%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>场景：封装一个 antd 的 Radio 组件时，需要从父组件获取到 value 的类型。其 props 接口定义如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CustomRadioProps&lt;ValueType&gt; &#123;</span><br><span class="line">  options: Option&lt;ValueType&gt;[];</span><br><span class="line">  value: ValueType;</span><br><span class="line">  onChange: <span class="function">(<span class="params">value: ValueType</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时这里假设传进去的是个 number 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomRadio&lt;number&gt;</span><br><span class="line">  onChange&#x3D;&#123;handleTypeChange&#125;</span><br><span class="line">  options&#x3D;&#123;[</span><br><span class="line">    &#123;</span><br><span class="line">      label: &#39;1&#39;,</span><br><span class="line">      value: 1,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      label: &#39;1&#39;,</span><br><span class="line">      value: 2,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]&#125;</span><br><span class="line">  value&#x3D;&#123;1&#125;</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>那么这个 CustomRadioProps 称为泛型组件。</p><p>那么如何定义一个泛型组件？</p><a id="more"></a><h4 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class CustomRadio&lt;T&gt; extends React.Component&lt;Props&lt;T&gt;&gt; &#123; </span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h4><p>对于用 function 声明的函数式组件实际上于泛型函数是一样的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomRadio</span>&lt;<span class="title">T</span>&gt;(<span class="params">props: IProps&lt;T&gt;</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而对于用箭头函数不可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const CustomRadio: React.FunctionComponent&lt;IProps&lt;T&gt;&gt; &#x3D; props &#x3D;&gt; &#123; &#x2F;*...*&#x2F; &#125;</span><br></pre></td></tr></table></figure><p>箭头函数组件正确的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const IconRadioGroup &#x3D; &lt;T extends any&gt;(props: IProps&lt;T&gt;) &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 T 必须要使用 extends, 用 <code>T extends any</code> 来表明接收任意类型，如果只能 number 或者 string类型，则改成  <code>T extends number｜string</code> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js获取后缀名</title>
      <link href="/2020/09/02/js%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/"/>
      <url>/2020/09/02/js%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Code Review 的时候看到小伙伴提交了一段用于提取文件拓展名的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 截取图片后缀信息</span></span><br><span class="line"><span class="comment">// example: 'www.baidu.com/somepic.jpg?h/w/'</span></span><br><span class="line"><span class="comment">// return: '.jpg'</span></span><br><span class="line"><span class="keyword">const</span> getExtension = <span class="function">(<span class="params">url = <span class="string">''</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> end = url.indexOf(<span class="string">'?'</span>) || <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">const</span> start = url.lastIndexOf(<span class="string">'.'</span>, end);</span><br><span class="line">  <span class="keyword">return</span> url.substring(start, end);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种写法固然没错，那么是否有别的写法嘞?</p><a id="more"></a><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getExtension = <span class="function">(<span class="params">url = <span class="string">''</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> extensionName = url.split(<span class="string">'.'</span>).pop()</span><br><span class="line">  <span class="keyword">return</span> extensionName ? <span class="string">`.<span class="subst">$&#123;extensionName&#125;</span>`</span> : <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>正则表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getExtension = <span class="function">(<span class="params">url = <span class="string">''</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matches = url.match(<span class="regexp">/.*(\.[^?]+)/</span>)</span><br><span class="line">  <span class="keyword">return</span> matches ? matches[<span class="number">1</span>] : <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有些同学对正则不太熟悉，以下对这个正则做一下解释：</p><ol><li><code>.*</code>： . 表示非换行符号， * 用于消耗尽可能多的字符</li><li><code>()</code> 括号表示捕获组，这里 <code>()</code> 中的表达式就是用于捕获后缀名。</li><li><code>\.</code> 表示 . 的转义</li><li><code>[^\?+]</code>: ^ 表示非， + 表示一个或者多个。因此 <code>[^?+]</code> 即表示非 ？的多个字符</li></ol><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>如果是在 node 的环境，本地的文件名可以通过 path 模块提供的 extname 获取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; extname &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(extname(<span class="string">'some-pic.jpg'</span>))</span><br><span class="line"><span class="comment">// .jpg</span></span><br></pre></td></tr></table></figure><p>那如果是远程地址呢？可以通过 url 模块得到 pathname 之后再用 extname 来获取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; extname &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; parse &#125; = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getExtension = <span class="function">(<span class="params">url = <span class="string">''</span></span>) =&gt;</span> extname(parse(url).pathname)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript中的const断言</title>
      <link href="/2020/08/26/TypeScript%E4%B8%AD%E7%9A%84const%E6%96%AD%E8%A8%80/"/>
      <url>/2020/08/26/TypeScript%E4%B8%AD%E7%9A%84const%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近在使用 ant design 的 Table 组件，遇到一个问题，定义 Table 的 columns 属性如下：</p><a id="more"></a><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> columns: ColumnProps&lt;MyRecord&gt;[] = [&#123;</span><br><span class="line">  title: <span class="string">'ID'</span>,</span><br><span class="line">  dataIndex: <span class="string">'id'</span>,</span><br><span class="line">  align: <span class="string">'center'</span>,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>此时 TS 提示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Types of property <span class="string">'align'</span> are incompatible.</span><br><span class="line">       <span class="built_in"> Type </span><span class="string">'string'</span> is <span class="keyword">not</span> assignable <span class="keyword">to</span><span class="built_in"> type </span><span class="string">'"right" | "left" | "center" | undefined'</span>.  TS2322</span><br></pre></td></tr></table></figure><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>经过查看代码发现， ColumnProps 的 align 属性的实际继承自 ColumnSharedType：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ColumnSharedType&lt;RecordType&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    align?: AlignType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">type</span> AlignType = <span class="string">'left'</span> | <span class="string">'center'</span> | <span class="string">'right'</span>;</span><br></pre></td></tr></table></figure><p>也就是 column 中的 align 的类型为 string，而 string 无法 cast 到 AlignType。即：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AlignType = <span class="string">'left'</span> | <span class="string">'center'</span> | <span class="string">'right'</span>;</span><br><span class="line"><span class="keyword">let</span> align: AlignType | <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> myAlign = <span class="string">"center"</span></span><br><span class="line"><span class="comment">// Type 'string' is not assignable to type '"left" | "right" | "center" | undefined'.ts(2322)</span></span><br><span class="line">align = myAlign</span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>TypeScript 3.4 版本以上提供了 const 断言，可以通过 as const 来消除以上报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> columns: ColumnProps&lt;MyRecord&gt;[] = [&#123;</span><br><span class="line">  title: <span class="string">'ID'</span>,</span><br><span class="line">  dataIndex: <span class="string">'id'</span>,</span><br><span class="line">  align: <span class="string">'center'</span> <span class="keyword">as</span> <span class="keyword">const</span>,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h4 id="const-assertions"><a href="#const-assertions" class="headerlink" title="const assertions"></a>const assertions</h4><p>以下内容翻译自 <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-4-rc/" target="_blank" rel="noopener">https://devblogs.microsoft.com/typescript/announcing-typescript-3-4-rc/</a> 中的 <code>const</code> assertions。(翻译不动的地方会贴上原文)</p><p>当声明一个可变的变量或者属性时，TypeScript 经常拓宽值以确保我们可以在不写明确切的类型的情况下进行赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以给 x 赋值</span></span><br><span class="line">x = <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure><p>严格来说，每一个字面量都有其字面类型。上面的 x 在类型推断时，由 <code>&quot;hello&quot;</code> 类型转为更为 widen 的 <code>string</code> 类型。</p><p>相对而言，如果 x 原始字面量类型为 “hello”， 那么我们就无法将 x 赋值为 “world”:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="string">"hello"</span> = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error!</span></span><br><span class="line">x = <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure><p>上面的情况看起来比较极端，但是在一些情况下比较有用的，例如，我们经常创建一个联合属性的对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape =</span><br><span class="line">    | &#123; kind: <span class="string">"circle"</span>, radius: <span class="built_in">number</span> &#125;</span><br><span class="line">    | &#123; kind: <span class="string">"square"</span>, sideLength: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getShapes</span>(<span class="params"></span>): <span class="title">readonly</span> <span class="title">Shape</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [</span><br><span class="line">        &#123; kind: <span class="string">"circle"</span>, radius: <span class="number">100</span>, &#125;,</span><br><span class="line">        &#123; kind: <span class="string">"square"</span>, sideLength: <span class="number">50</span>, &#125;,</span><br><span class="line">    ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Some terrible error message because TypeScript inferred</span></span><br><span class="line">    <span class="comment">// 'kind' to have the type 'string' instead of</span></span><br><span class="line">    <span class="comment">// either '"circle"' or '"square"'.</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可修改性是 TypeScript 断定什么时候 widen 类型的重要因素，而非分析所有代码。（Mutability is one of the best heuristics of intent which TypeScript can use to determine when to widen (rather than analyzing our entire program).）</p><p>正如上述例子，不幸的是，JavaScript 中的属性默认可修改。这意味着经常会有不必要的 widen 类型，我们需要在特定的地方对类型进行确切的声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getShapes</span>(<span class="params"></span>): <span class="title">readonly</span> <span class="title">Shape</span>[] </span>&#123;</span><br><span class="line">  <span class="comment">// This explicit annotation gives a hint</span></span><br><span class="line">  <span class="comment">// to avoid widening in the first place.</span></span><br><span class="line">  <span class="keyword">let</span> result: readonly Shape[] = [</span><br><span class="line">  &#123; kind: <span class="string">"circle"</span>, radius: <span class="number">100</span>, &#125;,</span><br><span class="line">  &#123; kind: <span class="string">"square"</span>, sideLength: <span class="number">50</span>, &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的方法可以解决问题，但是当数据结构越来越复杂的时候，这种方式将会显的笨重。</p><p>为了解决这个问题，TypeScript 3.4 为字面值引入了 const 断言。它的语法是一种类型断言，例如 <code>123 as const</code>。当我们这么使用的时候，意味着：</p><ol><li>字面量类型不会被 widen，如不会从 “hello” 变成 string</li><li>对象字面量的属性值为只读</li><li>数组字面量变成只读元组</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type '10'</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">10</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'readonly [10, 20]'</span></span><br><span class="line"><span class="keyword">let</span> y = [<span class="number">10</span>, <span class="number">20</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type '&#123; readonly text: "hello" &#125;'</span></span><br><span class="line"><span class="keyword">let</span> z = &#123; text: <span class="string">"hello"</span> &#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>在 tsx 文件以外，还可以这么使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type '10'</span></span><br><span class="line"><span class="keyword">let</span> x = &lt;<span class="keyword">const</span>&gt;<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type 'readonly [10, 20]'</span></span><br><span class="line"><span class="keyword">let</span> y = &lt;<span class="keyword">const</span>&gt;[<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type '&#123; readonly text: "hello" &#125;'</span></span><br><span class="line"><span class="keyword">let</span> z = &lt;<span class="keyword">const</span>&gt;&#123; text: <span class="string">"hello"</span> &#125;;</span><br></pre></td></tr></table></figure><p>This feature often means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Works with no types referenced or declared.</span></span><br><span class="line"><span class="comment">// We only needed a single const assertion.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getShapes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [</span><br><span class="line">        &#123; kind: <span class="string">"circle"</span>, radius: <span class="number">100</span>, &#125;,</span><br><span class="line">        &#123; kind: <span class="string">"square"</span>, sideLength: <span class="number">50</span>, &#125;,</span><br><span class="line">    ] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> shape of getShapes()) &#123;</span><br><span class="line">    <span class="comment">// Narrows perfectly!</span></span><br><span class="line">    <span class="keyword">if</span> (shape.kind === <span class="string">"circle"</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Circle radius"</span>, shape.radius);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Square side length"</span>, shape.sideLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面无需类型声明，const 断言允许 ts 使用最精确的表达式类型。</p><h5 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h5><p>需要注意的是，const 断言只能使用在简单的字面表达式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error!</span></span><br><span class="line"><span class="comment">//   A 'const' assertion can only be applied to a string, number, boolean, array, or object literal.</span></span><br><span class="line"><span class="keyword">let</span> a = (<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ? <span class="number">0</span> : <span class="number">1</span>) <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Works!</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ?</span><br><span class="line">    <span class="number">0</span> <span class="keyword">as</span> <span class="keyword">const</span> :</span><br><span class="line">    <span class="number">1</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>另外需要注意的是，const 不会将表达式转变为完全不可变：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">et arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    name: <span class="string">"foo"</span>,</span><br><span class="line">    contents: arr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.name = <span class="string">"bar"</span>;   <span class="comment">// error!</span></span><br><span class="line">foo.contents = [];  <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line">foo.contents.push(<span class="number">5</span>); <span class="comment">// ...works!</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不变的承诺 Promise</title>
      <link href="/2020/08/25/%E4%B8%8D%E5%8F%98%E7%9A%84%E6%89%BF%E8%AF%BA%20Promise/"/>
      <url>/2020/08/25/%E4%B8%8D%E5%8F%98%E7%9A%84%E6%89%BF%E8%AF%BA%20Promise/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Promise 是异步编程的一种解决方案，可以解决前端的回调地狱。以下根据 <a href="https://es6.ruanyifeng.com/?search=promise&x=0&y=0#docs/promise" target="_blank" rel="noopener">ES6 入门</a> 简单过一下 Promise 的基础及个人的一些见解补充，同时尝试实现一个符合 PromiseA+ 规范的 Promise。</p> <a id="more"></a><h4 id="Promise-基础"><a href="#Promise-基础" class="headerlink" title="Promise 基础"></a>Promise 基础</h4><h5 id="Promise-的状态"><a href="#Promise-的状态" class="headerlink" title="Promise 的状态"></a>Promise 的状态</h5><p>Promise 只有三种状态：<code>pending</code>（进行中），<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。</p><p>Promise 的状态改变只有两种情况：</p><p><code>pending</code> 到 <code>fulfilled</code> 以及 <code>pending</code> 到 <code>rejected</code>。当状态变成  <code>fulfilled</code> 或 <code>rejected</code>时，我们就称这个 Promise  <code>resolved</code>。</p><p>⚠️ 我们通常说的 resolved 仅指代 <code>fulfilled</code>，不包括 <code>rejected</code>。</p><h5 id="构造一个-Promise"><a href="#构造一个-Promise" class="headerlink" title="构造一个 Promise"></a>构造一个 Promise</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="promise-then"><a href="#promise-then" class="headerlink" title="promise.then"></a>promise.then</h5><p>Promise 的实例拥有 then 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>⚠️  Promise 新建后立即执行，而 then 方法则属于微任务的回调，执行时机为宏任务执行之后，具体的事件循环机制后面开新坑总结。</p><h5 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h5><p>构造 Promise 时，第一个参数 resolve 函数所接收的参数，可以是一个普通的值，也可以是一个 promise。如果接收的是一个 promise 实例，那么 promise 的状态取决于 resolve 接收的 promise 的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// 3s 后输出：Error: fail</span></span><br></pre></td></tr></table></figure><p>这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><h5 id="resolve-与-return"><a href="#resolve-与-return" class="headerlink" title="resolve 与 return"></a>resolve 与 return</h5><p>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="catch"><a href="#catch" class="headerlink" title=".catch"></a>.catch</h5><ol><li><p><code>Promise.prototype.catch()</code>方法是<code>.then(null | undefined, rejection)</code>，用于指定发生错误时的回调函数。</p></li><li><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止，即错误总是会被下一个<code>catch</code>语句捕获。</p></li><li><p><code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>与 <code>catch()</code> 方法。</p></li><li><p>promise 内部的错误不会抛到外层，因此 <code>try/catch</code> 无法捕获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'err'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'out'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch you'</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="comment">// 未捕获的异常：Uncaught (in promise) err</span></span><br></pre></td></tr></table></figure><p>因此最好 promise 后都用 catch 来捕获。</p></li></ol><h5 id="finally"><a href="#finally" class="headerlink" title=".finally()"></a>.finally()</h5><ul><li>ES2018 引入，即不管 Promise 对象最后状态如何，都会执行的操作。</li><li><code>finally</code>方法的回调函数不接受任何参数</li></ul><h4 id="手写一个简易的-Promise"><a href="#手写一个简易的-Promise" class="headerlink" title="手写一个简易的 Promise"></a>手写一个简易的 Promise</h4><p>手写一个符合 PromiseA+ 规范的 Promise 并不简单，可以先简单根据上述 promise 的基本功能实现一个<strong>简易版本</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING</span><br><span class="line">    <span class="comment">// 收集 .then 中的 resolve 的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.resolveCallbacks = []</span><br><span class="line">    <span class="comment">// 收集 .then 中的 reject 的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.rejectCallbacks = []</span><br><span class="line">    <span class="comment">// resolve(result)</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// reject(reason)</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 由于 fn 有可能异常，需要捕获</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Promise 一实例化就执行传入的 fn</span></span><br><span class="line">      <span class="comment">// 注意此处将函数当作参数传入，需要 bind 绑定上下文</span></span><br><span class="line">      <span class="comment">// 或者 resolve / reject 用箭头函数实现</span></span><br><span class="line">      fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="comment">// 修改状态</span></span><br><span class="line">      <span class="keyword">this</span>.state = RESOLVED</span><br><span class="line">      <span class="keyword">this</span>.result = result</span><br><span class="line">      <span class="comment">// 执行 then 中的 resolve 回调函数</span></span><br><span class="line">      <span class="keyword">this</span>.resolveCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(result))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="comment">// 修改状态</span></span><br><span class="line">      <span class="keyword">this</span>.state = REJECTED</span><br><span class="line">      <span class="keyword">this</span>.reason = reason</span><br><span class="line">      <span class="comment">// 执行 then 中的 reject 回调函数</span></span><br><span class="line">      <span class="keyword">this</span>.rejectCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(reason))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// 调用 .then 时如果还在 pending 则将回调先存起来，等待 resolve 后执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="comment">// 收集回调</span></span><br><span class="line">      <span class="keyword">this</span>.resolveCallbacks.push(onFulfilled)</span><br><span class="line">      <span class="keyword">this</span>.rejectCallbacks.push(onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果调用 .then 时已经 resolve / reject, 那么直接执行对应的回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === RESOLVED) &#123;</span><br><span class="line">      onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">      onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'resolved'</span>)</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myPromise.then(</span><br><span class="line">  (result) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;,</span><br><span class="line">  (reason) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Promise 的设计思路实际上就是观察者模式：收集回调函数，触发通知，依次执行回调。</p><p>上述版本还未能达到 Promise / A+ 的规范，比如 链式调用 等。</p><h4 id="符合-Promise-A-的-Promise"><a href="#符合-Promise-A-的-Promise" class="headerlink" title="符合 Promise / A+ 的 Promise"></a>符合 Promise / A+ 的 Promise</h4><p>参考 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise / A+</a> ，以下还需要补充下面几点：</p><ol><li>then 方法的参数可选</li><li><code>onFulfilled</code> 和 <code>onRejected</code>是异步执行的，可以使用如 <code>setTimeout</code> 或 <code>setImmediate</code> 之类的“宏任务”机制，或者使用诸如 <code>MutationObserver</code> 或 <code>process.nextTick</code> 之类的“微任务”机制来实现。</li><li>链式调用 与 promise 解决步骤</li></ol><h5 id="值穿透"><a href="#值穿透" class="headerlink" title="值穿透"></a>值穿透</h5><p>针对 then 的参数可选这一点，如果 <code>onFulfilled</code>  和 <code>onRejectd</code> 不是函数，则会被忽略，并且将值传递给下一个 then。即所谓的值穿透，对 <code>then</code> 进行改造:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="comment">// 如果不是函数，传递 result</span></span><br><span class="line">    onFulfilled =</span><br><span class="line">      <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function">(<span class="params">result</span>) =&gt;</span> result</span><br><span class="line">  <span class="comment">// 如果不是函数，抛出 reason</span></span><br><span class="line">    onRejected =</span><br><span class="line">      <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">        ? onRejected</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason</span><br><span class="line">          &#125;</span><br><span class="line">  <span class="comment">// ... if (this.state === PENDING) ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然当前的简易版 promise 还不支持链式调用，值穿透也就无从谈起。</p><h5 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h5><p>在实现链式调用之前，我们完善代码，使得<code>onFulfilled</code> 和 <code>onRejected</code>是异步执行的。</p><p>当前执行以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myPromise.then(</span><br><span class="line">  (val) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">  &#125;,</span><br><span class="line">  (val) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>现输出 1 再输出 2，显然不是异步的。根据 Promise/ A+ 的规范，这里我们可以通过 setTimeout 来改造 resolve 和 reject ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">resolve(result) &#123;</span><br><span class="line">  <span class="comment">// 通过 setTimeout 模拟异步</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reject(reason) &#123;</span><br><span class="line">    <span class="comment">// 通过 setTimeout 模拟异步</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>至此，输出顺序将是 2, 1。 符合预期</p><h5 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h5><p>现在来实现链式调用：</p><ol><li><code>then</code> 需要返回一个 Promise</li><li><code>then</code> 拿到上一次 then 的返回值</li><li>如果 then 返回的是一个 Promise 则需要等待该 promise 状态发生变化后再执行下一个 then</li></ol><p>promise2: 我们将 then 返回的 promise 命名为 promise2, 即 <code>promise2 = promise1.then(onFulfilled, onRejected);</code></p><p>x: 将 onFulfilled 或者 onRejected 的返回值命名为 x，这个 x 可以是一个 thenable。</p><p>resolutionProcedure: promise 解决步骤。如果 <code>x</code> 具有 thenable 特性，我们就假设 <code>x</code> 的行为至少有点像 promise，它将试图使 promise 接收 <code>x</code> 的状态。否则，它使用值 <code>x</code> 执行 <code>promise</code>。之所以是 thenable 是为了可以兼容别的 promise（例如 fetch）。实际上这个方法在 Promise / A+ 中有很多情况分叉，我们先简化成以下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更, 否则直接resolve</span></span><br><span class="line">x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br></pre></td></tr></table></figure><p>现在的 Promise 完整代码如下，<strong>接近完全体版本</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING</span><br><span class="line">    <span class="comment">// 收集 .then 中的 resolve 的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.resolveCallbacks = []</span><br><span class="line">    <span class="comment">// 收集 .then 中的 reject 的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.rejectCallbacks = []</span><br><span class="line">    <span class="comment">// resolve(result)</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// reject(reason)</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 由于 fn 有可能异常，需要捕获</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Promise 一实例化就执行传入的 fn</span></span><br><span class="line">      <span class="comment">// 注意此处将函数当作参数传入，需要 bind 绑定上下文</span></span><br><span class="line">      <span class="comment">// 或者 resolve / reject 用箭头函数实现</span></span><br><span class="line">      fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="keyword">this</span>.state = RESOLVED</span><br><span class="line">        <span class="keyword">this</span>.result = result</span><br><span class="line">        <span class="comment">// 执行 then 中的 resolve 回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.resolveCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(result))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="keyword">this</span>.state = REJECTED</span><br><span class="line">        <span class="keyword">this</span>.reason = reason</span><br><span class="line">        <span class="comment">// 执行 then 中的 reject 回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.rejectCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(reason))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// 如果不是函数，传递 result</span></span><br><span class="line">    onFulfilled =</span><br><span class="line">      <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function">(<span class="params">result</span>) =&gt;</span> result</span><br><span class="line">    <span class="comment">// 如果不是函数，抛出 reason</span></span><br><span class="line">    onRejected =</span><br><span class="line">      <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">        ? onRejected</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason</span><br><span class="line">          &#125;</span><br><span class="line">    <span class="comment">// 调用 .then 时如果还在 pending 则将回调先存起来，等待 resolve 后执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="keyword">const</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> resolvedCallBack = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">            <span class="comment">// 简化逻辑的 resolutionProcedure</span></span><br><span class="line">            x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            <span class="comment">// resolutionProcedure(promise2, x, resolve, reject)</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> rejectCallBack = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = onRejected(<span class="keyword">this</span>.result)</span><br><span class="line">            <span class="comment">// 简化逻辑的 resolutionProcedure</span></span><br><span class="line">            x <span class="keyword">instanceof</span> MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">            <span class="comment">// resolutionProcedure(promise2, x, resolve, reject)</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集回调</span></span><br><span class="line">        <span class="keyword">this</span>.resolveCallbacks.push(resolvedCallBack)</span><br><span class="line">        <span class="keyword">this</span>.rejectCallbacks.push(onRejected)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果调用 .then 时已经 resolve / reject, 那么直接执行对应的回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === RESOLVED) &#123;</span><br><span class="line">      onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">      onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="resolutionProcedure"><a href="#resolutionProcedure" class="headerlink" title="resolutionProcedure"></a>resolutionProcedure</h5><p>最后根据 Promise / A+ 的规范来完善 resolutionProcedure，实际上就是一系列的判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolutionProcedure = <span class="function">(<span class="params">promise2, x, resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    x.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        resolutionProcedure(promise2, value, resolve, reject)</span><br><span class="line">    &#125;, reject)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          y =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            resolutionProcedure(promise2, y, resolve, reject)</span><br><span class="line">          &#125;,</span><br><span class="line">          e =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="符合-Promise-A-的-Promise-1"><a href="#符合-Promise-A-的-Promise-1" class="headerlink" title="符合 Promise / A+ 的 Promise"></a>符合 Promise / A+ 的 Promise</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolutionProcedure = <span class="function">(<span class="params">promise2, x, resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    x.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      resolutionProcedure(promise2, value, resolve, reject)</span><br><span class="line">    &#125;, reject)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          (y) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            resolutionProcedure(promise2, y, resolve, reject)</span><br><span class="line">          &#125;,</span><br><span class="line">          (e) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING</span><br><span class="line">    <span class="comment">// 收集 .then 中的 resolve 的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.resolveCallbacks = []</span><br><span class="line">    <span class="comment">// 收集 .then 中的 reject 的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.rejectCallbacks = []</span><br><span class="line">    <span class="comment">// resolve(result)</span></span><br><span class="line">    <span class="keyword">this</span>.result = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// reject(reason)</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 由于 fn 有可能异常，需要捕获</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Promise 一实例化就执行传入的 fn</span></span><br><span class="line">      <span class="comment">// 注意此处将函数当作参数传入，需要 bind 绑定上下文</span></span><br><span class="line">      <span class="comment">// 或者 resolve / reject 用箭头函数实现</span></span><br><span class="line">      fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resolve(result) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="keyword">this</span>.state = RESOLVED</span><br><span class="line">        <span class="keyword">this</span>.result = result</span><br><span class="line">        <span class="comment">// 执行 then 中的 resolve 回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.resolveCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(result))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        <span class="keyword">this</span>.state = REJECTED</span><br><span class="line">        <span class="keyword">this</span>.reason = reason</span><br><span class="line">        <span class="comment">// 执行 then 中的 reject 回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.rejectCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(reason))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// 如果不是函数，传递 result</span></span><br><span class="line">    onFulfilled =</span><br><span class="line">      <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function">(<span class="params">result</span>) =&gt;</span> result</span><br><span class="line">    <span class="comment">// 如果不是函数，抛出 reason</span></span><br><span class="line">    onRejected =</span><br><span class="line">      <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">        ? onRejected</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason</span><br><span class="line">          &#125;</span><br><span class="line">    <span class="comment">// 调用 .then 时如果还在 pending 则将回调先存起来，等待 resolve 后执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="keyword">const</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> resolvedCallBack = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> rejectCallBack = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = onRejected(<span class="keyword">this</span>.result)</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集回调</span></span><br><span class="line">        <span class="keyword">this</span>.resolveCallbacks.push(resolvedCallBack)</span><br><span class="line">        <span class="keyword">this</span>.rejectCallbacks.push(onRejected)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果调用 .then 时已经 resolve / reject, 那么直接执行对应的回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === RESOLVED) &#123;</span><br><span class="line">      onFulfilled(<span class="keyword">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">      onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们完成了一个 符合 Promise / A+ 的 Promise，实际上 Promise 还会提供一些如 <code>.all</code>, <code>.race</code> 之类的 api，这里也实现一下。</p><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>Promise.all 接收多个 Promise 实例，返回一个新的 Promise 实例。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br></pre></td></tr></table></figure><p>上述的 p1, p2, p3 都是 Promise 实例，如果不是则会用 Promise.resolve 转成 promise。此外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><p>实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  all(arr) &#123;</span><br><span class="line">    <span class="comment">// 用于存储返回值</span></span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line">    <span class="comment">// 记录 resolve 了多少个 promise</span></span><br><span class="line">    <span class="keyword">let</span> length = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 执行 promise 的过程中是否有异常</span></span><br><span class="line">    <span class="keyword">let</span> hasError = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 返回一个新的 Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 判断元素是否为 MyPromise， 否则 resolve</span></span><br><span class="line">        <span class="keyword">const</span> p =</span><br><span class="line">          arr[i] <span class="keyword">instanceof</span> MyPromise ? arr[i] : MyPromise.resolve(arr[i])</span><br><span class="line">        p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          list[i] = data</span><br><span class="line">          length++</span><br><span class="line">          <span class="keyword">if</span> (length === arr.length) &#123;</span><br><span class="line">            <span class="comment">// 如果全部 promise 都 resolved</span></span><br><span class="line">            resolve(list)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!hasError) &#123;</span><br><span class="line">            <span class="comment">// 第一个被 reject 的实例的返回值，会传递给 p 的回调函数</span></span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">          hasErr = <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  race(arr) &#123;</span><br><span class="line">    <span class="comment">// 是否有结果</span></span><br><span class="line">    <span class="keyword">let</span> hasResult = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 返回一个新的 Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 判断元素是否为 MyPromise， 否则 resolve</span></span><br><span class="line">        <span class="keyword">const</span> p =</span><br><span class="line">          arr[i] <span class="keyword">instanceof</span> MyPromise ? arr[i] : MyPromise.resolve(arr[i])</span><br><span class="line">        p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!hasResult) &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">          &#125;</span><br><span class="line">          hasResult = <span class="literal">true</span></span><br><span class="line">        &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!hasResult) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">          hasResult = <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svg 图片的上传下载</title>
      <link href="/2020/08/17/svg%20%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2020/08/17/svg%20%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近有个需求：</p><ol><li>根据传入的 code 生成条形码 svg 图片</li><li>将 svg 图片上传至 cdn</li><li>展示图片时需要点击按钮后保存至本地</li></ol><a id="more"></a><h4 id="生成条形码"><a href="#生成条形码" class="headerlink" title="生成条形码"></a>生成条形码</h4><p>这里借助一个开源的仓库</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> JsBarcode <span class="keyword">from</span> <span class="string">'jsbarcode'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generateBarcode = <span class="keyword">async</span> (barcode, options = &#123;&#125;) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建一个 svg 元素</span></span><br><span class="line">  <span class="keyword">const</span> svg = <span class="built_in">document</span>.createElementNS(<span class="string">'http://www.w3.org/2000/svg'</span>, <span class="string">'svg'</span>);</span><br><span class="line">  <span class="comment">// 甚至宽高</span></span><br><span class="line">  svg.setAttribute(<span class="string">'width'</span>, <span class="string">`<span class="subst">$&#123;width&#125;</span>px`</span>);</span><br><span class="line">  svg.setAttribute(<span class="string">'height'</span>, <span class="string">`<span class="subst">$&#123;height&#125;</span>px`</span>);</span><br><span class="line">  <span class="comment">// 生成条形码 svg 的图片</span></span><br><span class="line">  JsBarcode(svg, barcode, options);</span><br><span class="line">  <span class="keyword">return</span> svg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h4><h5 id="svg-转-canvas"><a href="#svg-转-canvas" class="headerlink" title="svg 转 canvas"></a>svg 转 canvas</h5><p>由于服务端同学提供的接口只支持 canvas，因此首先要将 svg 转成 canvas：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> svgToCanvas = <span class="function">(<span class="params">svg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// svg.outerHTML 获取 svg 元素的 html 字符串</span></span><br><span class="line">  <span class="comment">// btoa 将 svg 转成 base64</span></span><br><span class="line"><span class="keyword">const</span> href = <span class="string">`data:image/svg+xml;base64,<span class="subst">$&#123;<span class="built_in">window</span>.btoa(</span></span></span><br><span class="line"><span class="string"><span class="subst">    <span class="built_in">unescape</span>(<span class="built_in">encodeURIComponent</span>(svg.outerHTML)),</span></span></span><br><span class="line"><span class="string"><span class="subst">  )&#125;</span>`</span>;</span><br><span class="line">  <span class="comment">// 构建一个 Image</span></span><br><span class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.width = width;</span><br><span class="line">  img.height = height;</span><br><span class="line">  </span><br><span class="line">  img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 构建一个 canvas</span></span><br><span class="line">    <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">    <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    <span class="comment">// 将 图片画到 canvas 中</span></span><br><span class="line">    ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    <span class="comment">// 转成 jpeg 的 base64</span></span><br><span class="line"> <span class="keyword">const</span> dataURI = canvas.toDataURL(<span class="string">'image/jpeg'</span>);</span><br><span class="line">    <span class="comment">// 上传</span></span><br><span class="line">    upload(dataURI);</span><br><span class="line">  &#125; </span><br><span class="line">  img.src = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Data-URL"><a href="#Data-URL" class="headerlink" title="Data URL"></a>Data URL</h5><p>通过 `canvas.toDataURL 将 canvas 转成 Data URL，一段 Data URL 由 4 个部分组成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br><span class="line">// 例如： "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC"</span><br></pre></td></tr></table></figure><h5 id="Base64的解码与编码"><a href="#Base64的解码与编码" class="headerlink" title="Base64的解码与编码"></a>Base64的解码与编码</h5><p><code>atob()</code> 函数能够解码通过base-64编码的字符串数据。</p><p><code>btoa()</code> 函数能够从二进制数据“字符串”创建一个base-64编码的ASCII字符串。</p><h5 id="Base64-转-Blob"><a href="#Base64-转-Blob" class="headerlink" title="Base64 转 Blob"></a>Base64 转 Blob</h5><p>上传图片文件需要将 base64 转成 Blob 对象，有两种方法：</p><p>######Base64 转 Blob 第一种方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURItoBlob</span>(<span class="params">dataURI: string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 atob 转回 string</span></span><br><span class="line">  <span class="keyword">const</span> byteString = atob(dataURI.split(<span class="string">','</span>)[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// 获得文件类型</span></span><br><span class="line">  <span class="keyword">const</span> mimeString = dataURI.split(<span class="string">','</span>)[<span class="number">0</span>].split(<span class="string">':'</span>)[<span class="number">1</span>].split(<span class="string">';'</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 转成 </span></span><br><span class="line">  <span class="keyword">const</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(byteString.length);</span><br><span class="line">  <span class="keyword">const</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; byteString.length; i++) &#123;</span><br><span class="line">    ia[i] = byteString.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 转成 blob</span></span><br><span class="line">  <span class="keyword">const</span> bb = <span class="keyword">new</span> Blob([ab], &#123; <span class="attr">type</span>: mimeString &#125;);</span><br><span class="line">  <span class="keyword">return</span> bb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 思路：</p><ol><li>拆解 data uri，通过 atob 将 base64 解码成字符串</li><li>拆解 data uri，获得图片的格式</li><li>创建一个 arraybuffer</li><li>通过TypedArray（这里使用 Uint8Array）将字符串的内容写入 arraybuffer </li><li>将 array buffer 转成 blob</li></ol><h6 id="Base64-转-Blob-第二种方法："><a href="#Base64-转-Blob-第二种方法：" class="headerlink" title="Base64 转 Blob 第二种方法："></a>Base64 转 Blob 第二种方法：</h6><p>通过 <code>fetch</code> 将 dataURI 转成 blob：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bb = <span class="keyword">await</span> fetch(dataURI).then(<span class="function">(<span class="params">res</span>) =&gt;</span> res.blob())</span><br></pre></td></tr></table></figure><h5 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h5><p>构造 FormData 上传图片文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> upload = <span class="function">(<span class="params">dataURI: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建form对象</span></span><br><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">  <span class="comment">// 通过 append 向 form 对象添加数据</span></span><br><span class="line">  formData.append(<span class="string">'file'</span>, dataURItoBlob(dataURI));</span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> axios.post(<span class="string">'/api/upload'</span>, formData, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span>,</span><br><span class="line">      <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h5><p>保存图片到本地：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> download = <span class="function">(<span class="params">fileUrl, name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  x.open(<span class="string">'GET'</span>, fileUrl, <span class="literal">true</span>);</span><br><span class="line">  x.responseType = <span class="string">'blob'</span>;</span><br><span class="line">  x.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 转为 objectUrl</span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="built_in">window</span>.URL.createObjectURL(x.response);</span><br><span class="line">    <span class="comment">// 构建一个 a 标签</span></span><br><span class="line">    <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">    a.href = url;</span><br><span class="line">    a.download = name;</span><br><span class="line">    a.click();</span><br><span class="line">  &#125;;</span><br><span class="line">  x.send();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用 a 标签的 download 属性可以实现图片的下载，但是有个限制是 href 必须是同源的地址，否则无法下载。</p><p>因此这里通过 get 请求获得图片的 Blob 格式，并用 window.URL.createObjectURL 将 Blob 转成 objectUrl 解决了跨域问题。之后就可以用 a 标签的 download 属性下载文件。</p><h4 id="补充几个概念"><a href="#补充几个概念" class="headerlink" title="补充几个概念"></a>补充几个概念</h4><h5 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h5><p>上传图片时，我们实现了一个函数 dataURItoBlob， 通过这个函数来将 base64 转为 Blob，最终上传给接口的 formData 中的 file 也是一个 Blob 对象。</p><p>什么是 Blob 对象？</p><blockquote><p>一个 <strong>Blob</strong>对象表示一个不可变的, 原始数据的类似文件对象。Blob 表示的不一定是JavaScript原生格式的数据。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File" target="_blank" rel="noopener"><code>File</code></a> 接口基于<code>Blob</code>，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p></blockquote><p>Blob 属于 web 提供的 api，因此 mdn 上说的 Blob 表示的不一定是JavaScript原生格式的数据。</p><h5 id="File"><a href="#File" class="headerlink" title="File"></a>File</h5><p>File 继承自 Blob，可以看作是特殊的 Blob。常见的获得 File 对象的方法有 <code>input</code> 标签上选择文件后返回的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileList" target="_blank" rel="noopener"><code>FileList</code></a> 对象。</p><h5 id="Blob-转-URL"><a href="#Blob-转-URL" class="headerlink" title="Blob 转 URL"></a>Blob 转 URL</h5><p>在下载时，我们通过 get 请求获得了图片的 blob 格式，之后通过 URL.createObjectURL 转成 objectUrl，这样就可以像普通的 url，赋值给 img 的 src 属性或者 a 标签的 href 属性。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码层面解读Vue响应式原理</title>
      <link href="/2020/08/11/%E6%BA%90%E7%A0%81%E5%B1%82%E9%9D%A2%E8%A7%A3%E8%AF%BBVue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2020/08/11/%E6%BA%90%E7%A0%81%E5%B1%82%E9%9D%A2%E8%A7%A3%E8%AF%BBVue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在 Vue（以下均指的是 2.x 版本） 中，数据模型仅仅是普通的 JavaScript 对象，当你修改它们时，视图会进行更新，这就是 Vue 的响应式系统，其设计模式就是观察者模式。</p><a id="more"></a><h4 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h4><p>以下为阅读源码时，对响应式实现原理的理解，为了思路更清晰，仅考虑最简单的情况，并且可能会省略或修改部分代码。</p><p>首先，顺着 vue 的生命周期开始：</p><h5 id="beforeCreate-与-created"><a href="#beforeCreate-与-created" class="headerlink" title="beforeCreate 与 created"></a>beforeCreate 与 created</h5><p>首先 在 _init 方法中执行 beforeCreate 与 created ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  initState(vm)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callHook(vm, <span class="string">'created'</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住这里执行了一个方法： <code>initState</code></p><p>#####initState</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 略：...初始化 props，methods 等</span></span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 略：...初始化 computed，watch 等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 initData 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 略：...将 data 的每个属性都挂在 vm 上,这样可以通过 this.xx 直接访问到</span></span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住 <code>observe</code> 这个方法。</p><h5 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h5><p><code>observe</code>  用于创建一个 observer 实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="comment">// 判断是否已经 observe 过，是的话直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    <span class="comment">// observer 最终会挂在 value 的 __ob__ 属性上，因此可以这么判断是否  observe 过，详情看 Observer 的代码</span></span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 否则满足一系列条件的情况下就会重新实例化一个 observer</span></span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化  observer 的过程中实际上会将传入对象的每个属性通过 <code>defineReactive</code> 方法转成响应式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="comment">// 初始化数据模型的 dep 实例</span></span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="comment">// observer 最终会挂在 value 的 __ob__ 属性上</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 略：...重写 value 的一些数组方法</span></span><br><span class="line">      <span class="comment">// 略：...遍历数组元素并 observe</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">       <span class="comment">// 遍历传入的每个属性，并用 defineReactive 转成响应式</span></span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h5><p>上面代码中最核心的一个函数是 <code>defineReactive</code>，做了以下几件事情：</p><ol><li>初始化目标属性的 dep 实例，这实际上是一个发布者</li><li>对该属性的子对象递归调用 observe</li><li>通过<code>Object.defineProperty</code>劫持该属性的 getter 与 setter：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化目标属性的 dep 实例</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"><span class="comment">// 略：... 一些容错判断</span></span><br><span class="line">  <span class="comment">// 略：... 一些初始化</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 递归 observe</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="comment">// 劫持 get 与 set</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="comment">// ...一旦获取该属性就会进行依赖收集</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="comment">// ...一旦设置了新值就会派发更新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就用到了观察者模式：当这个属性更新时，会通过发布者通知到观察者，这些观察者收到通知后更新视图。这里发布者实际上是<code>Dep</code> 实例，观察者实际上是 <code>Watcher</code> 实例，它的 <code>update</code> 方法可以更新视图。</p><p>所以，依赖收集实际上就是将<code>Wathcer</code> 实例添加到 <code>Dep</code> 实例的观察者列表。</p><p>reactiveGetter 和 reactiveSetter 这两个方法的具体实现我们先放一边，这里只需要知道大概的作用即可，后面会详细介绍。我们现在来看看什么时候会触发 get 呢？答案是在挂载组件的时候。</p><h5 id="beforeMount-与-mounted"><a href="#beforeMount-与-mounted" class="headerlink" title="beforeMount 与 mounted"></a>beforeMount 与 mounted</h5><p>然后是在 mountComponent 中执行  beforeMount 以及 mounted：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line">  <span class="comment">// 略：...这里有个非生产环境的判断，这里不考虑简化成如下：</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// 这里实例化 Watcher：可以看作是更新视图用的观察者，这里省略一些参数</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent)</span><br><span class="line">  <span class="comment">// ...仅考虑 new Vue 的情况，代码简化如下</span></span><br><span class="line">  callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂载组件的时候就会实例化一个 <code>Watcher</code></p><h5 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h5><p>当我们实例化 Watcher 的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 略：...一些初始化</span></span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.newDeps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="comment">// 略：...一些初始化</span></span><br><span class="line">    <span class="comment">// 略：...对 this.getter 的一些初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.computed) &#123;</span><br><span class="line">      <span class="comment">// computed 的情况，本文暂不考虑</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化时就会执行 get 方法</span></span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="comment">// pushTarget 用于将 watcher 实例挂到 Dep 的 target 这个静态属性上</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 此时的 this.getter 实际上就是 updateComponent</span></span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 略：...错误处理</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 略：...递归访问 value，触发它所有子项的 getter</span></span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pushTarget</code> 将 <code>watcher</code> 实例挂到 <code>Dep</code> 的 <code>target</code> 这个静态属性, 用于 <code>Dep</code> 内部可以访问到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: ?Watcher</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  Dep.target = _target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用 <code>this.getter</code>, 这里的 <code>this.getter</code> 实际上就是 <code>updateComponent</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm._update(vm._render(), hydrating)</span><br></pre></td></tr></table></figure><p><code>vm._render()</code> 会生成 VNode，这个过程会访问 vm 上的数据，至此就会触发数据对象的 getter，进行依赖收集。</p><h5 id="思路小结"><a href="#思路小结" class="headerlink" title="思路小结"></a>思路小结</h5><p>至此我们先梳理一下这一整个过程，以免遗忘：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate =&gt; </span><br><span class="line">initState -&gt; observe -&gt; <span class="keyword">new</span> Observer</span><br><span class="line">  -&gt; defineReactive：实例化 Dep，劫持对象属性 getter 与 setter</span><br><span class="line">=&gt; created</span><br><span class="line">=&gt; beforeMount</span><br><span class="line">  实例化 Watcher -&gt; 将 watcher 实例绑定到 Dep.target，并触发对象属性的 getter，收集依赖</span><br><span class="line">=&gt; mounted</span><br><span class="line">=&gt; 当数据模型变更时，触发 setter，更新视图</span><br></pre></td></tr></table></figure><p>在 defineReactive 中有个关键的步骤是实例化 <code>Dep</code>。</p><h5 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h5><p>上面说过 Dep 实例是一个发布者，其代码其实很简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      <span class="comment">// 这里将 Dep.target 即 watcher 添加到 subs 里</span></span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// 发布通知</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最终调用的是 <code>depend</code>方法来添加观察者，即<code>Dep.target.addDep</code>，我们知道此时 Dep.target 实际上就是 watcher 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.id</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="comment">// 将发布者 id 添加到 this.newDepIds</span></span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">    <span class="comment">// 将发布者 添加到 this.newDeps</span></span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      <span class="comment">// 如果旧的 发布者id 列表中没有这个发布者 id，那么就添加到发布者的观察者列表中</span></span><br><span class="line">      dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>而在 watcher 中，最终还是调用了传入的 dep 实例的 addSub 来添加到 dep 的观察者列表中。之所以这么设计，其原因是为了能在 watcher 中维护一个自己订阅的发布者列表。</p><p>那么 watcher 中的发布者列表有什么用呢？还记得 Watcher 实例化的最后会调用  <code>this.cleanupDeps()</code> 吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cleanupDeps () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">      dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">  <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">  <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">  <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">  tmp = <span class="keyword">this</span>.deps</span><br><span class="line">  <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">  <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">  <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数实际上的作用是：</p><ol><li><p>如果无需再观察，则从发布者的观察者列表中移除</p></li><li><p>将本次的发布者 id 列表记录在 this.depsIds 中，清空 this.newDepIds</p></li><li><p>将本次的发布者列表记录在 this.deps 中，清空 this.newDeps</p><p>那么具体是如何将对象属性转为响应式的呢，我们看看其具体实现：</p></li></ol><h5 id="reactiveGetter"><a href="#reactiveGetter" class="headerlink" title="reactiveGetter"></a>reactiveGetter</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 此时的 Dep.target 就是 watcher，关于 Dep 后面会详细解释</span></span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    <span class="comment">// 这里会将 watcher 实例添加进 dep 的 subs 中维护，即收集依赖</span></span><br><span class="line">    dep.depend()</span><br><span class="line">    <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">      <span class="comment">// 子对象的依赖收集</span></span><br><span class="line">      childOb.dep.depend()</span><br><span class="line">      <span class="comment">// 略：...对数组的一些处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回属性值</span></span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="reactiveSetter"><a href="#reactiveSetter" class="headerlink" title="reactiveSetter"></a>reactiveSetter</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// value：属性值</span></span><br><span class="line">  <span class="keyword">const</span> value = ...</span><br><span class="line">  <span class="comment">// 略：...一些判断是否触发 setter 的条件</span></span><br><span class="line">  <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">    setter.call(obj, newVal)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    val = newVal</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置新值后需要重新 observe</span></span><br><span class="line">  childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">  <span class="comment">// 发布通知</span></span><br><span class="line">  dep.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文简化了一些细节，但是 Vue 的响应式原理大致如此。当理解了原理之后，如果后面遗忘了的话，以下为重要的记忆点：</p><ol><li>observe：实例化 Observe，参数为数据模型，实例化过程会调用遍历对象属性调用 defineReactive</li><li>defineReactive：实例化 Dep，劫持对象属性的 getter 与 setter，getter 时进行依赖收集</li><li>在挂载组件的时候，会实例化 Watcher，此时会触发 getter</li><li>当更新对象属性时，会调用 Dep 实例的 notify，触发 watcher 的 update</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react常见问题解析</title>
      <link href="/2020/08/10/react%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/08/10/react%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>断断续续开始梳理一些 react 的常见问题，将尽可能结合源码来解释。当前版本为 16.x。</p><a id="more"></a><h4 id="Q：为什么-react-组件需要-import-React-from-‘react’？"><a href="#Q：为什么-react-组件需要-import-React-from-‘react’？" class="headerlink" title="Q：为什么 react 组件需要 import React from ‘react’？"></a>Q：为什么 react 组件需要 import React from ‘react’？</h4><p>A：这是因为 babel 在编译 jsx 代码时，是调用 React.createElement 来创建一个组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">转换前：&lt;div /&gt;</span><br><span class="line">转换后：React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="Q：为什么-react-组件开头需要大写？"><a href="#Q：为什么-react-组件开头需要大写？" class="headerlink" title="Q：为什么 react 组件开头需要大写？"></a>Q：为什么 react 组件开头需要大写？</h4><p>A：React.createElement  的第一个参数表示类型。如果开头小写，类型为字符串，此时 react 会认为是一个原生的 dom 节点。而如果是大写，则类型会是个变量，react 会认为这是个自定义的组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">转化前：&lt;Comp /&gt;</span><br><span class="line">转化后：React.createElement(Comp, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="Q：为什么诸如-key，ref-等-props-不会传递给组件？"><a href="#Q：为什么诸如-key，ref-等-props-不会传递给组件？" class="headerlink" title="Q：为什么诸如 key，ref 等 props 不会传递给组件？"></a>Q：为什么诸如 key，ref 等 props 不会传递给组件？</h4><p>A：React.createElement 的第二个参数为 config，babel 转化如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">转化前：&lt;Comp props1=<span class="string">"props1"</span> props2=&#123;props2&#125; /&gt;</span><br><span class="line">转化后：</span><br><span class="line">React.createElement(Comp, &#123;</span><br><span class="line">  props1: <span class="string">"props1"</span>,</span><br><span class="line">  props2: props2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而在生成 props 时会将保留属性移除出去的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">    !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">  ) &#123;</span><br><span class="line">    props[propName] = config[propName];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保留属性就包括了 key 和 ref，因此不会传给组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RESERVED_PROPS = &#123;</span><br><span class="line">  key: <span class="literal">true</span>,</span><br><span class="line">  ref: <span class="literal">true</span>,</span><br><span class="line">  __self: <span class="literal">true</span>,</span><br><span class="line">  __source: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Q-props-children-是什么？"><a href="#Q-props-children-是什么？" class="headerlink" title="Q: props.children 是什么？"></a>Q: props.children 是什么？</h4><p>A：props.children 是组件的子节点合集，babel 转化如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">转换前：</span><br><span class="line">&lt;Comp&gt;</span><br><span class="line">  &lt;div&gt;<span class="number">1</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span&gt;2&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/Comp&gt;</span></span><br><span class="line"><span class="regexp">转换后：</span></span><br><span class="line"><span class="regexp">React.createElement(Comp, null,</span></span><br><span class="line"><span class="regexp">React.createElement("div", null, "1"), </span></span><br><span class="line"><span class="regexp">React.createElement("span", null, "2")</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>React.createElement 虽然只声明了三个参数，实际上从第三个参数开始就都是子节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createElement(type, config, children)</span><br></pre></td></tr></table></figure><p>在生成 props.children 时，如果是单个子节点，则直接赋值给 props.children，如果有多个子节点将这些节点合成一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.freeze) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.freeze(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="Q-React-children-map"><a href="#Q-React-children-map" class="headerlink" title="Q: React.children.map"></a>Q: React.children.map</h4><h4 id="Q-React-遍历元素的-key-属性"><a href="#Q-React-遍历元素的-key-属性" class="headerlink" title="Q: React 遍历元素的 key 属性"></a>Q: React 遍历元素的 key 属性</h4><h4 id="Q：什么是-Fiber？"><a href="#Q：什么是-Fiber？" class="headerlink" title="Q：什么是 Fiber？"></a>Q：什么是 Fiber？</h4><p>A：每个 ReactElement 都有一个对应的 Fiber，Fiber 上记录了组件的各种状态。同时 Fiber 通过 child，sibling，以及 return 来记录其子，兄弟以及父节点的 Fiber。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;son&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child1&quot; &#x2F;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child2&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;son2&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>那么 Fiber 遍历所有节点的顺序为：</p><img src="https://images.gitee.com/uploads/images/2020/0826/084732_693094f2_1748283.png" alt="fiber" style="zoom:50%;" /><p>遍历的顺序为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一直遍历到最后一个层级的叶子结点</span></span><br><span class="line">FiberRoot -&gt; RootFiber -&gt; App -&gt; parent -&gt; son -&gt; child</span><br><span class="line"><span class="comment">// 然后查找兄弟节点</span></span><br><span class="line">child -&gt; child2</span><br><span class="line"><span class="comment">// 如果兄弟节点也没有子节点，则 return ，即返回父节点</span></span><br><span class="line">child2 -&gt; son -&gt; son2 -&gt; parent -&gt; App -&gt; RootFiber -&gt; FiberRoot</span><br></pre></td></tr></table></figure><h4 id="Q：concurrent-mode？"><a href="#Q：concurrent-mode？" class="headerlink" title="Q：concurrent mode？"></a>Q：concurrent mode？</h4><h4 id="Q：React-Fiber-Reconciler？"><a href="#Q：React-Fiber-Reconciler？" class="headerlink" title="Q：React Fiber Reconciler？"></a>Q：React Fiber Reconciler？</h4>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-JS中的观察者模式与发布订阅模式</title>
      <link href="/2020/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在上一篇文章《debounce与throttle》 中提到了 RxJS， RxJS 中有两个重要的概念: Observable（可被观察者） 和 Observer（观察者），RxJS 的 Observable 就是观察者模式和迭代器模式的组合。</p><p>在 javascript 中，观察者模式和发布订阅模式极为相似，因此本文将探讨这两种模式以及其应用。</p> <a id="more"></a><h4 id="观察者模式（Observer-pattern）"><a href="#观察者模式（Observer-pattern）" class="headerlink" title="观察者模式（Observer pattern）"></a>观察者模式（Observer pattern）</h4><blockquote><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 —— Graphic Design Patterns</p></blockquote><p>观察者模式有两个对象：一个是观察者，另一个上面提到的目标对象可以称为是发布者，基本的流程为：</p><ol><li>发布者维护一个观察者列表，可以添加或者删除观察者</li><li>当发布者发布通知时，遍历观察者列表，并调用观察者提供的方法</li></ol><p>发布者的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 维护一个观察者列表</span></span><br><span class="line">    <span class="keyword">this</span>.observers = []</span><br><span class="line">    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">// 添加观察者</span></span><br><span class="line">  addObserver(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除观察者</span></span><br><span class="line">  removeObserver(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = <span class="keyword">this</span>.observers.filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== observer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发布通知</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行观察者提供的方法，这里假设为 update</span></span><br><span class="line">      item.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅者则比较简单，实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`observer <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> update`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Observer(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> Observer(<span class="string">'b'</span>)</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Observer(<span class="string">'c'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> publisher = <span class="keyword">new</span> Publisher()</span><br><span class="line">publisher.addObserver(a)</span><br><span class="line">publisher.addObserver(b)</span><br><span class="line">publisher.addObserver(c)</span><br><span class="line"><span class="comment">// 发布通知</span></span><br><span class="line">publisher.notify()</span><br><span class="line"><span class="comment">// a b c</span></span><br></pre></td></tr></table></figure><p>Vue 的响应式原理就是观察者模式的一个典型应用，关于 Vue 的响应式由于篇幅原因，将会另起一篇详细分析。</p><h4 id="发布订阅模式（Pub-sub-pattern）"><a href="#发布订阅模式（Pub-sub-pattern）" class="headerlink" title="发布订阅模式（Pub-sub pattern）"></a>发布订阅模式（Pub-sub pattern）</h4><p>发布订阅模式是从观察者模式发展而来，两者的区别在于：观察者模式中发布者与观察者是松耦合，而发布订阅则在发布者与订阅者中加入了事件中心实现发布者与观察者的完全解耦。</p><p>用发布订阅模式模拟事件绑定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventCenter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addListener(type, fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers[type] = [...(<span class="keyword">this</span>.observers[type] || []), fn]</span><br><span class="line">  &#125;</span><br><span class="line">  removeListener(type, fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="keyword">this</span>.observers[type];</span><br><span class="line">    <span class="keyword">if</span> (!listeners || !listeners.length) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.observers[type] = listeners.filter(<span class="function"><span class="params">v</span> =&gt;</span> v !== fn);</span><br><span class="line">  &#125;</span><br><span class="line">  dispatchEvent(type) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="keyword">this</span>.observers[type];</span><br><span class="line">    <span class="keyword">if</span> (!listeners || !listeners.length) <span class="keyword">return</span>;</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> evtCenter = <span class="keyword">new</span> EventCenter()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅 click 事件</span></span><br><span class="line">evtCenter.addListener(<span class="string">'click'</span>, handleClick)</span><br><span class="line"><span class="comment">// 发布 click 事件</span></span><br><span class="line">evtCenter.dispatchEvent(<span class="string">'click'</span>)</span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">evtCenter.removeListener(<span class="string">'click'</span>, handleClick)</span><br></pre></td></tr></table></figure><p>可以看到与观察者模式不同，在发布订阅模式中，我们的发布和订阅都是通过事件中心来进行调度的。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debounce与throttle</title>
      <link href="/2020/08/06/debounce%E4%B8%8Ethrottle/"/>
      <url>/2020/08/06/debounce%E4%B8%8Ethrottle/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>测试同学提了个 bug，在搜索框中疯狂输入文字，不一会儿接口就报错了。这个 bug 实际上就是由于每输入一个字符时，就去请求接口引起的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleSearch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...请求接口</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;Input onChange=&#123;handleSearch&#125; /&gt;</span><br></pre></td></tr></table></figure><p>解决方法是通过 <code>debounce</code> 来控制输入的频率。</p><p>实际上 <code>debounce</code> 和 <code>throttle</code> 这两个概念经常是一起出现，在工作中也常常使用到。在早年接触前端的时候，项目里有 <code>lodash</code>，因此直接使用其提供的  <code>debounce</code> 和 <code>throttle</code> 。而在一些简单的项目里，往往不引入 <code>lodash</code>，这个时候就需要自己实现，于此做个记录。</p><a id="more"></a><h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><p><code>debounce</code> 也就是防抖，看看 lodash 中 debounce 的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.debounce(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure><p>返回一个函数，该函数会距离上次调用后，延迟 <code>wait</code> 毫秒后调用<code>func</code>。</p><p>在上面的 bug 中，对原搜索方法进行防抖处理后，仅当用户停止输入 300 毫秒后，才请求接口进行搜索：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止输入 300 ms 后，进行搜索</span></span><br><span class="line">_.debounce(handleSearch, <span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>####throttle</p><p><code>throttle</code> 我们称之为截流，同样看看 loads 中 throttle 的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.throttle(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure><p>返回一个函数，该函数最多每 <code>wait</code> 毫秒调用一次 <code>func</code>。</p><p>如果对搜索方法进行截流，则无论用户输入多快，每 1 秒仅请求一次：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止输入 300 ms 后，进行搜索</span></span><br><span class="line">_.debounce(handleSearch, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h4 id="手写一个-debounce"><a href="#手写一个-debounce" class="headerlink" title="手写一个 debounce"></a>手写一个 debounce</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeout) &#123;</span><br><span class="line">      clearTimeout(timeout)</span><br><span class="line">    &#125;</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> func.call(<span class="keyword">this</span>, ...args), wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 func 被当作是参数传递进来，注意上面的 func 需要绑定 this。并且在使用时如果有 this 指向，需要显式指明 this，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = debounce(o.b).bind(o);</span><br></pre></td></tr></table></figure><p>对 debounce 进一步拓展，如果需要在调用时立刻执行一次，则可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait = <span class="number">0</span>, head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callNow = head &amp;&amp; !timeout;</span><br><span class="line">    timeout &amp;&amp; clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!callNow) &#123;</span><br><span class="line">        func.call(<span class="keyword">this</span>, ...args);</span><br><span class="line">      &#125;</span><br><span class="line">      timeout = <span class="literal">null</span></span><br><span class="line">    &#125;, wait);</span><br><span class="line">    <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">      func.call(<span class="keyword">this</span>, ...args)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手写一个-throttle"><a href="#手写一个-throttle" class="headerlink" title="手写一个 throttle"></a>手写一个 throttle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, timeFrame = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      <span class="keyword">if</span> (now - lastTime &gt;= timeFrame) &#123;</span><br><span class="line">          func.call(<span class="keyword">this</span>, ...args);</span><br><span class="line">          lastTime = now;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="what’s-more-rxjs"><a href="#what’s-more-rxjs" class="headerlink" title="what’s more: rxjs"></a>what’s more: rxjs</h4><p>截流和防抖很多时候是出现在事件中的，使用 rxjs 则可以使用 debounceTime 和 throttleTime：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fromEvent &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; debounceTime &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputEle = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>)</span><br><span class="line"><span class="keyword">const</span> inputs = fromEvent(inputEle, <span class="string">'input'</span>);</span><br><span class="line"><span class="keyword">const</span> result = inputs.pipe(debounceTime(<span class="number">1000</span>));</span><br><span class="line"><span class="comment">// 如果是节流可使用 throttleTime</span></span><br><span class="line"><span class="comment">// const result = inputs.pipe(throttleTime(1000));</span></span><br><span class="line">result.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure><h4 id="rxjs-react"><a href="#rxjs-react" class="headerlink" title="rxjs + react"></a>rxjs + react</h4><p>如果是 react 中的事件需要防抖，那么可以通过 <code>Subject</code> 来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useEffect &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; Subject &#125; from &quot;rxjs&quot;;</span><br><span class="line">import &quot;rxjs&#x2F;add&#x2F;operator&#x2F;debounceTime&quot;;</span><br><span class="line"></span><br><span class="line">const value$ &#x3D; new Subject().debounceTime(300);</span><br><span class="line"></span><br><span class="line">export default function App() &#123;</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    const subscription &#x3D; value$.subscribe(console.log)</span><br><span class="line">      return () &#x3D;&gt; subscription.unsubscribe()</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  const onChange &#x3D; e &#x3D;&gt; &#123;</span><br><span class="line">    value$.next(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input onChange&#x3D;&#123;onChange&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当我们说到打包时，我们在说什么</title>
      <link href="/2020/07/31/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E5%88%B0%E6%89%93%E5%8C%85%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/31/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E5%88%B0%E6%89%93%E5%8C%85%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>从早期的 grunt (我接触前端开发的时候这个已经趋于没落) 到 gulp，再到如今的 webpack，rollup ，parcel，以及 snowpack，vite，如今的前端已经脱离了刀耕火种的时代，各种打包工具层出不穷。前端项目基本离不开打包这个过程。那么当我们说到打包（bundle）时，我们在说的是什么？</p><p>这里不对 webpack 或者这些打包工具的使用进行具体说明，本文想探究的是打包的本质。</p><a id="more"></a><h4 id="从模块化说起"><a href="#从模块化说起" class="headerlink" title="从模块化说起"></a>从模块化说起</h4><p>在没有模块化之前，前端开发时需要格外注意命名冲突以及文件之间的相互依赖，参考 <a href="https://github.com/seajs/seajs/issues/547#issue-11105836。" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/547#issue-11105836。</a></p><p>模块化实际上就是将程序分解成离散的功能块，使代码易于复用，维护和测试。如 less 中通过 @import 引入的样式，ES6 Module / CommonJs 引入的 Js 等都可以称为模块。</p><p>然而浏览器不支持模块化，因此我们需要一个打包工具，将代码中诸如 require, @import, import 进来的模块打包成一个或者多个文件(即 bundle)。</p><h4 id="打包的本质"><a href="#打包的本质" class="headerlink" title="打包的本质"></a>打包的本质</h4><p>参考 webpack 的定义：</p><blockquote><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p></blockquote><p>而至于这个过程中，对代码进行压缩，混淆等等则是锦上添花的功能。</p><h4 id="打包的过程"><a href="#打包的过程" class="headerlink" title="打包的过程"></a>打包的过程</h4><p>这里以 webpack 为例：</p><ol><li>初始化：从配置文件和 Shell 语句中读取并合并配置参数</li><li>开始编译：根据上面得到的参数初始化 Compiler，加载插件（Plugins），执行 Compiler 的 run 方法开始编译</li><li>入口文件：配置的 entry</li><li>从入口文件开始，针对不同的模块使用对应的 Loader 编译，再找到该模块所依赖的模块，递归这个步骤</li><li>完成编译：经过上述步骤后得到每个模块编译后的内容以及相互之间的依赖关系</li><li>输出：根据依赖关系，将模块组合成一个个代码块（Chunk），最后输出成文件</li></ol><h4 id="实现一个简易的打包工具"><a href="#实现一个简易的打包工具" class="headerlink" title="实现一个简易的打包工具"></a>实现一个简易的打包工具</h4><p>参考 <a href="https://github.com/ronami" target="_blank" rel="noopener">ronami</a>/<strong><a href="https://github.com/ronami/minipack" target="_blank" rel="noopener">minipack</a></strong> 实现一个支持 ES Module 的简易打包工具（这里不考虑循环依赖等情况）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">'babylon'</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'babel-traverse'</span>).default</span><br><span class="line"><span class="keyword">const</span> &#123; transformFromAst &#125; = <span class="built_in">require</span>(<span class="string">'babel-core'</span>)</span><br></pre></td></tr></table></figure><p>引入上述相关依赖：</p><ul><li>babylon：生成 AST（抽象语法树）</li><li>babel-traverse：来分析文件的依赖</li><li>transformFromAst：将 AST 转为 ES5</li></ul><p><strong>首先</strong> 定义一个函数用于读取文件的内容和依赖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取文件内容和依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAsset</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(filePath, <span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="comment">// 生成 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = babylon.parse(content, &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 当前文件的依赖关系</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = []</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    <span class="comment">// 当遇到导入的声明时，将其内容 push 到 dependencies 里</span></span><br><span class="line">    ImportDeclaration: <span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      dependencies.push(node.source.value)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 将 AST 转为 ES5</span></span><br><span class="line">  <span class="keyword">const</span> &#123; code &#125; = transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    presets: [<span class="string">'env'</span>],</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    filePath,</span><br><span class="line">    dependencies,</span><br><span class="line">    code,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Asset 接口如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Assets &#123;</span><br><span class="line"><span class="comment">// 文件路径</span></span><br><span class="line">  filePath: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 文件的依赖</span></span><br><span class="line">  dependencies: <span class="built_in">string</span>[];</span><br><span class="line">  <span class="comment">// 转为 ES5 后的文件内容</span></span><br><span class="line">  code: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 相对路径</span></span><br><span class="line">  relativePath?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，我们现在有个文件 entry.js ，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><p>运行 <code>createAsset(&#39;./entry.js&#39;)</code> 将会返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  filePath: <span class="string">'./entry.js'</span>,</span><br><span class="line">  dependencies: [ <span class="string">'./a.js'</span> ],</span><br><span class="line">  code: <span class="string">`"use strict";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _a = require("./a.js");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _a2 = _interopRequireDefault(_a);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(_a2.default);`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接着</strong>定义一个函数用于构建依赖关系图( dependency graph )：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建依赖关系图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGraph</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从入口文件开始</span></span><br><span class="line">  <span class="keyword">const</span> entryAsset = createAsset(entry);</span><br><span class="line">  <span class="comment">// 初始时，queue 中只有 entryAsset, 之后分析依赖关系，会将新的 Asset push 到 queue 中用于分析，直到分析完全部依赖</span></span><br><span class="line">  <span class="keyword">const</span> queue = [entryAsset]</span><br><span class="line">  <span class="comment">// 遍历所有文件依赖关系</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> asset <span class="keyword">of</span> queue) &#123;</span><br><span class="line">    <span class="comment">// 获得文件目录</span></span><br><span class="line">    <span class="keyword">const</span> dirname = path.dirname(asset.filePath)</span><br><span class="line">    <span class="comment">// 遍历当前文件依赖关系</span></span><br><span class="line">    asset.dependencies.forEach(<span class="function">(<span class="params">relativePath</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获得绝对路径</span></span><br><span class="line">      <span class="keyword">const</span> absolutePath = path.join(dirname, relativePath)</span><br><span class="line">      <span class="keyword">const</span> childAsset = createAsset(absolutePath)</span><br><span class="line">      childAsset.relativePath = relativePath</span><br><span class="line">      <span class="comment">// 将当前文件所依赖的文件的 Asset 也 push 到 queue 中用于遍历</span></span><br><span class="line">      queue.push(childAsset)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，在上面的基础上，有个 a.js 以及 b.js 文件, 运行 <code>createGraph</code>会返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">// createGraph('./entry.js')</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    filePath: <span class="string">'./entry.js'</span>,</span><br><span class="line">    dependencies: [ <span class="string">'./a.js'</span> ],</span><br><span class="line">    code: <span class="string">`"use strict";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _a = require("./a.js");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _a2 = _interopRequireDefault(_a);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(_a2.default);`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    filePath: <span class="string">'a.js'</span>,</span><br><span class="line">    dependencies: [ <span class="string">'./b.js'</span> ],</span><br><span class="line">    code: <span class="string">`"use strict";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Object.defineProperty(exports, "__esModule", &#123;</span></span><br><span class="line"><span class="string">  value: true</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _b = require("./b.js");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var _b2 = _interopRequireDefault(_b);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var a = '1';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exports.default = a;`</span>,</span><br><span class="line">    relativePath: <span class="string">'./a.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    filePath: <span class="string">'b.js'</span>,</span><br><span class="line">    dependencies: [],</span><br><span class="line">    code: <span class="string">`"use strict";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Object.defineProperty(exports, "__esModule", &#123;</span></span><br><span class="line"><span class="string">  value: true</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">var b = '2';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exports.default = b;`</span>,</span><br><span class="line">    relativePath: <span class="string">'./b.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>最后</strong>实现一个打包函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> graph = createGraph(entry)</span><br><span class="line">  <span class="keyword">let</span> modules = <span class="string">''</span></span><br><span class="line">  <span class="comment">// 构建函数参数</span></span><br><span class="line">  graph.forEach(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> filePath = mod.relativePath || entry</span><br><span class="line">    <span class="comment">// 拼装成 modules</span></span><br><span class="line">    modules += <span class="string">`'<span class="subst">$&#123;filePath&#125;</span>': (</span></span><br><span class="line"><span class="string">      function (module, exports, require) &#123; <span class="subst">$&#123;mod.code&#125;</span> &#125;</span></span><br><span class="line"><span class="string">    ),`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 最终结果</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="string">`</span></span><br><span class="line"><span class="string">    (function(modules) &#123;</span></span><br><span class="line"><span class="string">// ast 转 es5 的代码是 commonjs 风格，而浏览器不支持 commonjs，因此自定义 require，以文件名作为 id</span></span><br><span class="line"><span class="string">      function require(id) &#123;</span></span><br><span class="line"><span class="string">        const module = &#123; exports : &#123;&#125; &#125;</span></span><br><span class="line"><span class="string">        modules[id](module, module.exports, require)</span></span><br><span class="line"><span class="string">        return module.exports</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">// 引入入口文件代码</span></span><br><span class="line"><span class="string">      require('<span class="subst">$&#123;entry&#125;</span>')</span></span><br><span class="line"><span class="string">    &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="comment">// 当生成的内容写入到文件中</span></span><br><span class="line">  fs.writeFileSync(<span class="string">'./bundle.js'</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出一个 IIFE：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;</span><br><span class="line">    modules[id](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, <span class="built_in">require</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./entry.js'</span>)</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">'./entry.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _a2 = _interopRequireDefault(_a)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(_a2.default)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'./a.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(exports, <span class="string">'__esModule'</span>, &#123;</span><br><span class="line">      value: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _b2 = _interopRequireDefault(_b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'1'</span></span><br><span class="line"></span><br><span class="line">    exports.default = a</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'./b.js'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(exports, <span class="string">'__esModule'</span>, &#123;</span><br><span class="line">      value: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">    exports.default = b</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-JS中的单例模式</title>
      <link href="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>此前项目有个 im  模块，需要用到 websocket。使用 websocket 需要建立连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initWs = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'wss://xxx.com'</span>);</span><br><span class="line">  ws.onopen(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'opened'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  ws.onmessage(<span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received evt'</span>, evt.data)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  <span class="keyword">return</span> ws</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们肯定不希望在每个用到 ws 的地方都重复初始化，即我们只需要一个 WebSocket 的实例。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wsA = <span class="keyword">new</span> SingleWs()</span><br><span class="line"><span class="keyword">const</span> wsB = <span class="keyword">new</span> SingleWs()</span><br><span class="line"><span class="comment">// 有没有办法使得:</span></span><br><span class="line">wsA <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsB <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsA === wsB</span><br></pre></td></tr></table></figure><p>那么要如何做到这一点？实际上就可以用到单例模式。下面列举几个实现的方法：</p><h4 id="使用全局变量"><a href="#使用全局变量" class="headerlink" title="使用全局变量"></a>使用全局变量</h4><p>这个可能是最容易想到的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.ws = <span class="built_in">window</span>.ws || initWs()</span><br></pre></td></tr></table></figure><p>将 ws 挂在 window 对象上，使用时也用 window.ws，显然这个解决方案有个问题是需要小心 window.ws 被覆盖。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包可以保持局部变量保持在内存中不被销毁，通过这个特性可以就可以避免污染全局变量，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SingleWs = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> ws = <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">// const initWs = ....</span></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   getWs() &#123;</span><br><span class="line">     <span class="keyword">if</span>(!ws) &#123;</span><br><span class="line">       ws = initWs()</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ws</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wsA = SingleWs.getWs()</span><br><span class="line"><span class="keyword">const</span> wsB = SingleWs.getWs()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(wsA <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsB <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsA === wsB)</span><br></pre></td></tr></table></figure><p>然而上面的写法也有一些缺点，如 getWs 可以被改写。</p><p>写法还可以进一步改写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SingleWs = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> ws = <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">// const initWs = .... </span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!ws) &#123;</span><br><span class="line">      ws = initWs()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 new 可以不写</span></span><br><span class="line"><span class="keyword">const</span> wsA = <span class="keyword">new</span> SingleWs()</span><br><span class="line"><span class="keyword">const</span> wsB = <span class="keyword">new</span> SingleWs()</span><br><span class="line"></span><br><span class="line">wsA <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsB <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsA === wsB</span><br></pre></td></tr></table></figure><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>通过模块化也能实现上述的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ws.js</span></span><br><span class="line"><span class="keyword">let</span> ws = <span class="literal">null</span></span><br><span class="line"><span class="comment">// const initWs = ....</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SingleWs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ws) &#123;</span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line">  &#125;</span><br><span class="line">  ws = initWs()</span><br><span class="line">  <span class="keyword">return</span> ws</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> SingleWs</span><br></pre></td></tr></table></figure><h4 id="通过-class-的静态属性来实现"><a href="#通过-class-的静态属性来实现" class="headerlink" title="通过 class 的静态属性来实现"></a>通过 class 的静态属性来实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleWs</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SingleWs.instance) &#123;</span><br><span class="line">      SingleWs.instance = <span class="keyword">this</span>.initWs()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SingleWs.instance</span><br><span class="line">  &#125;</span><br><span class="line">  initWs() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wsA = <span class="keyword">new</span> SingleWs()</span><br><span class="line"><span class="keyword">const</span> wsB = <span class="keyword">new</span> SingleWs()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(wsA <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsB <span class="keyword">instanceof</span> WebSocket &amp;&amp; wsA === wsB)</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>JS 中的单例模式：</p><ol><li>实例化时，判断是否已经存在实例。</li><li>如果不存在，则初始化，并将生成的实例存储起来。</li><li>存储的方法可以是全局变量，闭包，模块以及类的静态属性。</li><li>如果已经存在实例，那么就直接返回该实例。</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】ReactHooks-并非黑魔法，本质是数组</title>
      <link href="/2020/07/26/%E3%80%90%E8%AF%91%E3%80%91ReactHooks-%E5%B9%B6%E9%9D%9E%E9%BB%91%E9%AD%94%E6%B3%95%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B0%E7%BB%84/"/>
      <url>/2020/07/26/%E3%80%90%E8%AF%91%E3%80%91ReactHooks-%E5%B9%B6%E9%9D%9E%E9%BB%91%E9%AD%94%E6%B3%95%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本文翻译自 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a>，该文章很好的阐释了 react hooks 原理，我将保持原文的意思进行翻译，如有自己感觉不清楚的地方将会在括号中注明。以下为翻译内容。</p><p>我是 hooks api 的忠实粉丝。然而 hooks 在使用时却有一些<a href="https://reactjs.org/docs/hooks-rules.html" target="_blank" rel="noopener">奇怪的约束</a>。在这里，我给尝试去理解这些规则由来的人提供一个了模型，用于思考如何去使用这些新 api。</p><a id="more"></a><h4 id="hooks-的规则"><a href="#hooks-的规则" class="headerlink" title="hooks 的规则"></a>hooks 的规则</h4><p>在 <a href="https://reactjs.org/docs/hooks-rules.html" target="_blank" rel="noopener">hooks proposal documentation</a> 的提纲中，React 核心团队规定了两条开发者在使用 hooks 时需要遵守的主要规则：</p><ul><li>不要在循环，条件或者是嵌套函数中使用 hooks</li><li>只能在 React Functions 中才能使用 hooks</li></ul><p>后者我认为是显而易见的。要将行为附加到函数式组件上，你需要能够以某种方式将该行为与组件关联起来。（原文为： To attach behaviour to a functional component you need to be able to associate that behaviour with the component somehow. 不太理解作者想表达的意思）</p><p>前者我认为会比较让人困惑，因为像这样使用 api 可能看起来不太自然。而这正是我今天想要探讨的内容。</p><h4 id="hooks-的状态管理都是基于数组"><a href="#hooks-的状态管理都是基于数组" class="headerlink" title="hooks 的状态管理都是基于数组"></a>hooks 的状态管理都是基于数组</h4><p>为了更清晰地理解心智模型，让我们来看一下如何实现一个简单的 hooks api。</p><p><strong>注意这只是 API 的一种可能的实现方式及猜想，用于让你理解，而非 API 真正的内部实现方式</strong></p><h4 id="我们如何实现-useState"><a href="#我们如何实现-useState" class="headerlink" title="我们如何实现 useState?"></a>我们如何实现 <code>useState</code>?</h4><p>让我们打开一个实例来演示如何实现一个 state hook。</p><p>首先，我们定义一个组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function RenderFunctionComponent() &#123;</span><br><span class="line">  const [firstName, setFirstName] &#x3D; useState(&quot;Rudi&quot;);</span><br><span class="line">  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Hooks api 背后的思想是，你可以用 hook 函数返回的数组的第二个元素作为 setter 方法，这个 setter 方法可以控制被 hook 管理的状态。</p><h4 id="那么-React-是如何做到这个的呢？"><a href="#那么-React-是如何做到这个的呢？" class="headerlink" title="那么 React 是如何做到这个的呢？"></a>那么 React 是如何做到这个的呢？</h4><p>让我们看看这个在 React 内部是如何运作的。以下内容将在特定组件的上下文中运行。这就是说数据存储在要渲染的组件的上一层。这个 state 不与其他组件共享，但是维护在一个可以用于该组件后续渲染的作用域内。（原文：The following would work within the execution context for rendering a particular component. That means that the data stored here lives one level outside of the component being rendered. This state is not shared with other components but it is maintained in a scope that is accessible to subsequent rendering of the specific component）</p><ol><li><p>初始化</p><p>创建两个空数组：<code>setter</code> 和 <code>state</code></p><p>将指针设置为 0</p><p><img src="https://miro.medium.com/max/1280/1*LAZDuAEm7nbcx0vWVKJJ2w.png" alt="Image for post"></p></li><li><p>首次渲染</p><p>首次运行该组件。</p><p>每次调用 <code>useState</code> ，如果是首次运行，则 push 一个 setter 方法（绑定到指针的位置）到 setters 数组中，并且 push 一些 state 到 state 数组中。</p><p><img src="https://miro.medium.com/max/1260/1*8TpWnrL-Jqh7PymLWKXbWg.png" alt="Image for post"></p></li><li><p>后续渲染</p><p>每次后续渲染，指针将被重置，然后从各个数组中读取对应的值。</p><p><img src="https://miro.medium.com/max/1254/1*qtwvPWj-K3PkLQ6SzE2u8w.png" alt="Image for post"></p></li><li><p>事件处理</p><p>每一个 setter 都保存一个对应的指针位置的引用，因此触发任意一个 <code>setter</code> 都可以修改 state 数组中对应指针位置的 state。</p><p><img src="https://miro.medium.com/max/1260/1*3L8YJnn5eV5ev1FuN6rKSQ.png" alt="Image for post"></p></li></ol><h4 id="简单的实现-And-the-naive-implementation"><a href="#简单的实现-And-the-naive-implementation" class="headerlink" title="简单的实现(And the naive implementation)"></a>简单的实现(And the naive implementation)</h4><p>下面是简单的代码演示：</p><p><strong>注意：这不代表 hooks 的实际实现，但是应该能给你一个理解 hooks 工作原理的思路。这就是我为什么使用块级变量的原因（原文： That is why we are using module level vars etc）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">let state &#x3D; [];</span><br><span class="line">let setters &#x3D; [];</span><br><span class="line">let firstRun &#x3D; true;</span><br><span class="line">let cursor &#x3D; 0;</span><br><span class="line"></span><br><span class="line">function createSetter(cursor) &#123;</span><br><span class="line">  return function setterWithCursor(newVal) &#123;</span><br><span class="line">    state[cursor] &#x3D; newVal;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; This is the pseudocode for the useState helper</span><br><span class="line">export function useState(initVal) &#123;</span><br><span class="line">  if (firstRun) &#123;</span><br><span class="line">    state.push(initVal);</span><br><span class="line">    setters.push(createSetter(cursor));</span><br><span class="line">    firstRun &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const setter &#x3D; setters[cursor];</span><br><span class="line">  const value &#x3D; state[cursor];</span><br><span class="line"></span><br><span class="line">  cursor++;</span><br><span class="line">  return [value, setter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Our component code that uses hooks</span><br><span class="line">function RenderFunctionComponent() &#123;</span><br><span class="line">  const [firstName, setFirstName] &#x3D; useState(&quot;Rudi&quot;); &#x2F;&#x2F; cursor: 0</span><br><span class="line">  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;); &#x2F;&#x2F; cursor: 1</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Richard&quot;)&#125;&gt;Richard&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; This is sort of simulating Reacts rendering cycle</span><br><span class="line">function MyComponent() &#123;</span><br><span class="line">  cursor &#x3D; 0; &#x2F;&#x2F; resetting the cursor</span><br><span class="line">  return &lt;RenderFunctionComponent &#x2F;&gt;; &#x2F;&#x2F; render</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(state); &#x2F;&#x2F; Pre-render: []</span><br><span class="line">MyComponent();</span><br><span class="line">console.log(state); &#x2F;&#x2F; First-render: [&#39;Rudi&#39;, &#39;Yardley&#39;]</span><br><span class="line">MyComponent();</span><br><span class="line">console.log(state); &#x2F;&#x2F; Subsequent-render: [&#39;Rudi&#39;, &#39;Yardley&#39;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; click the &#39;Fred&#39; button</span><br><span class="line"></span><br><span class="line">console.log(state); &#x2F;&#x2F; After-click: [&#39;Fred&#39;, &#39;Yardley&#39;]</span><br></pre></td></tr></table></figure><h4 id="为什么顺序很重要？"><a href="#为什么顺序很重要？" class="headerlink" title="为什么顺序很重要？"></a>为什么顺序很重要？</h4><p>现在如果在一个生命周期里，我们基于外部的因素或者组件状态改变了 hooks 的顺序，将会发生什么事情？</p><p>让我们试试看 react 不建议我们做的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let firstRender &#x3D; true;</span><br><span class="line"></span><br><span class="line">function RenderFunctionComponent() &#123;</span><br><span class="line">  let initName;</span><br><span class="line"></span><br><span class="line">  if(firstRender)&#123;</span><br><span class="line">    [initName] &#x3D; useState(&quot;Rudi&quot;);</span><br><span class="line">    firstRender &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line">  const [firstName, setFirstName] &#x3D; useState(initName);</span><br><span class="line">  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在一个条件语句中使用了 <code>useState</code>，让我们看看造成了什么样的破坏：</p><h4 id="坏组件的第一次渲染"><a href="#坏组件的第一次渲染" class="headerlink" title="坏组件的第一次渲染"></a>坏组件的第一次渲染</h4><p><img src="https://miro.medium.com/max/1270/1*C4IA_Y7v6eoptZTBspRszQ.png" alt="Image for post"></p><p>在这个时候，我们的实例变量 <code>firstName</code> 和 <code>lastName</code> 指向的正确的数据，但是我们看看第二次渲染发生了什么：</p><h4 id="坏组件的第二次渲染"><a href="#坏组件的第二次渲染" class="headerlink" title="坏组件的第二次渲染"></a>坏组件的第二次渲染</h4><p><img src="https://miro.medium.com/max/1274/1*aK7jIm6oOeHJqgWnNXt8Ig.png" alt="Image for post"></p><p>现在我们的 state 存储出现异常， <code>firstName</code> 和 <code>lastName</code> 都指向 “Rudi”。上述明显错误的操作给了我们一个思路：为什么 hooks 要如此规定。</p><blockquote><p>The React team are stipulating the usage rules because not following them will lead to inconsistent data</p></blockquote><h4 id="想想-hooks-操作一系列的数组，那么你就不会打破规则了（Think-about-hooks-manipulating-a-set-of-arrays-and-you-wont-break-the-rules）"><a href="#想想-hooks-操作一系列的数组，那么你就不会打破规则了（Think-about-hooks-manipulating-a-set-of-arrays-and-you-wont-break-the-rules）" class="headerlink" title="想想 hooks 操作一系列的数组，那么你就不会打破规则了（Think about hooks manipulating a set of arrays and you wont break the rules）"></a>想想 hooks 操作一系列的数组，那么你就不会打破规则了（Think about hooks manipulating a set of arrays and you wont break the rules）</h4><p>现在应该能很清晰理解为什么不能在条件或者循环语句中使用 <code>use</code> hook 了：因为我们使用了指针指向了数组，如果在 render 的时候改变了顺序，那么指针就不能对应正确的数据，所以调用 use 也不会指向正确的数据和 setter。</p><p>因此，诀窍就是将 hooks 想像成用恒定的指针来管理一系列数组。如果能做到这个，那么一切就能按预期进行。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>希望我已经就如何思考 hooks api 的工作原理指出了一个清晰的心智模型。（后面就偷个懒不翻译了，基本是上述观点的重复强调。）</p><p>Hopefully I have laid out a clearer mental model for how to think about what is going on under the hood with the new hooks API. Remember the true value here is being able to group concerns together so being careful about order and using the hooks API will have a high payoff.</p><p>Hooks is an effective plugin API for React Components. There is a reason why people are excited about this and if you think about this kind of model where state exists as a set of arrays then you should not find yourselves breaking the rules around their usage.</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端入坑flutter</title>
      <link href="/2020/07/24/%E5%89%8D%E7%AB%AF%E5%85%A5%E5%9D%91flutter/"/>
      <url>/2020/07/24/%E5%89%8D%E7%AB%AF%E5%85%A5%E5%9D%91flutter/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>踩过 RN 的坑之后越发想尝试学习下 flutter 的开发，本文用于记录下开发过程中的问题与思考，本来是写在 notion 里的，最近 notion 无法打开，故记录于此。</p><a id="more"></a><h4 id="Flutter为什么选择了-Dart而不是-JavaScript"><a href="#Flutter为什么选择了-Dart而不是-JavaScript" class="headerlink" title="Flutter为什么选择了 Dart而不是 JavaScript"></a>Flutter为什么选择了 Dart而不是 JavaScript</h4><p>以下内容引用自 <a href="https://book.flutterchina.club/chapter1/flutter_intro.html" target="_blank" rel="noopener">flutter 开发实战</a>。</p><p>首先要了解两个概念：JIT和AOT。<br>目前，程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为<strong>AOT</strong> （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为<strong>JIT</strong>（Just-in-time）即“即时编译”。AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。在此，读者不必纠结于概念，概念就是为了传达精神而发明的，只要读者能够理解其原理即可，得其神忘其形。<br>JavaScript为脚本语言，执行时需要JIT(Just In Time)，执行效率和AOT(Ahead Of Time)代码仍有差距。<br>Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。<br>但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。</p><h4 id="网页开发"><a href="#网页开发" class="headerlink" title="网页开发"></a>网页开发</h4><p>现在 flutter 已经支持 web 了，切换到 beta ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 切换 channel</span><br><span class="line">flutter channel beta</span><br><span class="line">// 更新 sdk</span><br><span class="line">flutter upgrade</span><br><span class="line">// 安装依赖</span><br><span class="line">flutter packages get</span><br><span class="line">// 启动开发模式</span><br><span class="line">flutter run -d chrome</span><br></pre></td></tr></table></figure><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><p>过程不提，文档讲的比较清晰了，注意配置国内的源即可。</p><h4 id="项目结构与命名规范"><a href="#项目结构与命名规范" class="headerlink" title="项目结构与命名规范"></a>项目结构与命名规范</h4><p>dart 的文件名是用下划线连接的，源文件在 lib 目录下，main.dart 为入口文件, 从 main 函数开始执行，下划线开头的变量为私有变量</p><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>dart 里如何导入本地文件的呢？和引用第三方的库的用法一样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:&#123;项目名&#125;/&#123;文件名&#125;'</span>;</span><br></pre></td></tr></table></figure><p>其中成员变量自动导出，那么如何防止命名冲突？:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:&#123;项目名&#125;/&#123;文件名&#125;'</span> <span class="keyword">as</span> MyModule;</span><br></pre></td></tr></table></figure><p>通过 as 来指定包名，此时要使用内部成员就需要 MyModule.xxx。</p><p>也可以屏蔽某些变量导出：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:&#123;项目名&#125;/&#123;文件名&#125;'</span> <span class="keyword">hide</span> MyVar;</span><br></pre></td></tr></table></figure><h4 id="Material-组件库"><a href="#Material-组件库" class="headerlink" title="Material 组件库"></a>Material 组件库</h4><p><a href="https://flutterchina.club/widgets/material/" target="_blank" rel="noopener">https://flutterchina.club/widgets/material/</a></p><h4 id="💀-Divider-在-web-需要传-thickness"><a href="#💀-Divider-在-web-需要传-thickness" class="headerlink" title="💀 Divider 在 web 需要传 thickness"></a>💀 Divider 在 web 需要传 thickness</h4><p>否则不渲染， issue 如下： <a href="https://github.com/flutter/flutter/issues/46339" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/46339</a></p><h4 id="💀-BottomNavigationBar"><a href="#💀-BottomNavigationBar" class="headerlink" title="💀 BottomNavigationBar"></a>💀 BottomNavigationBar</h4><p>如果超过 3 个 items，背景会变白，原因是超过 3 个 BottomNavigationBar 的 type 会变成 BottomNavigationBarType.shifting 类型，详情见： <a href="https://github.com/flutter/flutter/issues/13642#issuecomment-371875044" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/13642#issuecomment-371875044</a></p><p>解决的办法是设置 type 属性为 fixed。</p><h4 id="进程锁死"><a href="#进程锁死" class="headerlink" title="进程锁死"></a>进程锁死</h4><p>遇到控制台提示，Waiting for another flutter command to release the startup lock… 可以简单粗暴杀进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -9 dart</span><br></pre></td></tr></table></figure><h4 id="运行所有的-flutter-命令都被挂起时"><a href="#运行所有的-flutter-命令都被挂起时" class="headerlink" title="运行所有的 flutter 命令都被挂起时"></a>运行所有的 flutter 命令都被挂起时</h4><p>删除 <code>flutter/bin/cache</code>，然后重新运行 <code>flutter doctor -v</code></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见的安全问题汇总</title>
      <link href="/2020/07/23/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/23/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近安全部门的小伙伴提了一个前端安全的漏洞，想到前端开发过程中有时候往往追求开发效率，忽略掉一些安全问题，以下简单总结一些自己遇到过的以及一些常见的攻击手段，以自查自省。</p><a id="more"></a><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>回到安全部门提出的漏洞，场景还原如下：<br>这是一个老项目，展示文章用，页面路由为 <a href="http://xxx/article/:id?these-are-queries，node" target="_blank" rel="noopener">http://xxx/article/:id?these-are-queries，node</a> 层收到这个 url 后，返回返回该文章 html，内容则包括了【推荐文章】， 而推荐文章的链接则是根据 url 的值来的，仅变化 id。此时如果在 url 上的 query 上构造一段恶意脚本，然后引导用户打开，那么用户打开页面后就会运行该恶意脚本。<br>上述正是一个典型的 XSS 攻击，定义如下：</p><blockquote><p>XSS是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p></blockquote><p>XSS 的本质是信任了某些不安全的输入，导致恶意代码混入正常代码，进而发生的攻击行为。常见的不安全输入有：</p><ol><li>上面提到的 url 参数，这种需要诱导用户取点击</li><li>用户输入的内容，比如用户发表评论</li><li>第三方的链接等</li></ol><p>防范的方法通常是：对用户输入内容和服务端返回内容进行过滤和转译。</p><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>CSRF 攻击常见的过程如下：</p><ol><li>用户登录你的网站，产生登录凭证，如 cookie</li><li>用户被<strong>诱导</strong>登录到恶意网站</li><li>恶意网站携带刚刚在浏览器产生的凭证向你的服务器发送一个恶意请求</li><li>你的服务器无法识别是否恶意请求，请求完成，用户受害。</li></ol><p>与上面提到的 XSS 攻击有个明显的区别在于：CSRF 攻击发生在恶意网站，而不是被攻击的网站。而这也使得攻击者并不能获取到受害者的登录凭证，仅仅只能使用。<br>防范的方法通常是：</p><ol><li>请求 url 添加 token 或者是在 http 请求头自定义属性进行验证</li><li>同源检测，通过解析 请求头中的 referer 判断请求来源</li><li>Samesite，Google 起草了一份草案来改进 HTTP 协议，为 Set-Cookie 响应头新增 Samesite 属性，用于标明 Cookie 是否能作用于其他网站，目前兼容性还不是很好。</li></ol><h4 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h4><p>当我们使用 iframe 加载第三方网站时，第三方网站可以对我们的网站执行恶意操作，如操作DOM，加载 js 等。<br>防范的方法是通过设置 sandbox 属性控制 iframe 的操作权限。</p><h4 id="opener"><a href="#opener" class="headerlink" title="opener"></a>opener</h4><p>我们在通常通过以下写法在 新 tab 下打开链接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;a target=<span class="string">'_blank'</span> href=<span class="string">'new-site.com'</span>&gt;</span><br><span class="line"><span class="number">2.</span> <span class="built_in">window</span>.open(<span class="string">'new-site.com'</span>)</span><br></pre></td></tr></table></figure><p>上述两种写法的问题在于， <code>new-site.com</code> 是可以通过 <code>window.opener</code> 来拿到源页面的 <code>window</code> 对象，进而进行恶意操作。<br>防范的方法通常是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> &lt;a target=<span class="string">"_blank"</span> href=<span class="string">"new-site.com"</span> rel=<span class="string">"noopener noreferrer nofollow"</span>&gt;a标签跳转url&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">2. function openurl(url) &#123;</span></span><br><span class="line"><span class="regexp">    var newTab = window.open();</span></span><br><span class="line"><span class="regexp">    newTab.opener = null;</span></span><br><span class="line"><span class="regexp">    newTab.location = url;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul><li><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener">前端安全系列（一）：如何防止XSS攻击？</a></p></li><li><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener">前端安全系列（二）：如何防止CSRF攻击？</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN 避坑指北</title>
      <link href="/2020/07/21/RN%20%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97/"/>
      <url>/2020/07/21/RN%20%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p>记录平时开发 rn 时遇到的问题，特指 0.59 版本，不同版本可能情况不同，仅供参考。</p><a id="more"></a><h5 id="一像素问题"><a href="#一像素问题" class="headerlink" title="一像素问题"></a>一像素问题</h5><p>rn 解决一像素很简单，只需要  <code>StyleSheet.hairlineWidth</code> 即可解决。</p><h5 id="TextInput-组件"><a href="#TextInput-组件" class="headerlink" title="TextInput  组件"></a>TextInput  组件</h5><p>自带内边距，多行文字时文字居中展示，想要消除需要设置样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 文字向上对齐</span><br><span class="line">textAlignVertical: 'top'</span><br><span class="line">// 消除内边距</span><br><span class="line"><span class="selector-tag">padding</span>: 0</span><br></pre></td></tr></table></figure><p>Placeholder 在 ios 和 android 下默认颜色表现不一致，可以通过 <code>placeholderTextColor</code>  属性进行设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">placeholderTextColor=<span class="string">"#CCCCCC"</span></span><br></pre></td></tr></table></figure><h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><p>因为设计理念的问题，android 下几乎无法实现和 ios 一致的阴影效果。而 flutter 基于 skia 引擎渲染，应该会有比较好的表现？有空尝试下。 🤔</p><h5 id="border-虚线"><a href="#border-虚线" class="headerlink" title="border 虚线"></a>border 虚线</h5><p>border 虚线也是一个比较棘手的问题, android 上实测无效，详情看 <a href="https://github.com/facebook/react-native/issues/17251" target="_blank" rel="noopener">issue</a>。解决方案是循环一个 pattern 然后 overhidden 掉，又多了一个让我想尝试 flutter 的理由 😂</p><h5 id="多行文字"><a href="#多行文字" class="headerlink" title="多行文字"></a>多行文字</h5><p>多行文字在 android 机型下有可能会出现高度不够导致文字被截掉的问题，解决方法：设置  <code>lineHeight</code></p><h5 id="实现不同字号的文字底部对齐"><a href="#实现不同字号的文字底部对齐" class="headerlink" title="实现不同字号的文字底部对齐"></a>实现不同字号的文字底部对齐</h5><p>例如 ¥500 想要 ¥ 字号小一点，而 500 字号大一点，但是需要底部对齐，则可以用 Text 包裹起来，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text&gt;</span><br><span class="line">  &lt;Text style&#x3D;&#123;&#123; fontSize: 12 &#125;&#125;&gt;¥&lt;&#x2F;Text&gt;</span><br><span class="line">  &lt;Text style&#x3D;&#123;&#123; fontSize: 20 &#125;&#125;&gt;500&lt;&#x2F;Text&gt;</span><br><span class="line">&lt;&#x2F;Text&gt;</span><br></pre></td></tr></table></figure><h5 id="Text-组件样式继承"><a href="#Text-组件样式继承" class="headerlink" title="Text 组件样式继承"></a>Text 组件样式继承</h5><p>众所周知，css 如果想设置默认的全局样式相当简单，比如字体颜色默认为 ‘#323232’ , 只要在 body 上设置一下 <code>color: #323232</code> 即可 ，然而对于 RN 来说则有两种解决方案：</p><ol><li><p>将原生 Text 替换成自定义 Text 组件（官方推荐）</p><blockquote><p>The recommended way to use consistent fonts and sizes across your application is to create a component <code>MyAppText</code> that includes them and use this component across your app</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123; TextProps, StyleSheet, Text &#125; from &#39;react-native&#39;;</span><br><span class="line"></span><br><span class="line">const styles &#x3D; StyleSheet.create(&#123;</span><br><span class="line">  defaultStyle: &#123;</span><br><span class="line">    color: &#39;#323232&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default function CustomText(props: TextProps &amp; &#123; children?: any &#125;) &#123;</span><br><span class="line">  const &#123; style, ...restProps &#125; &#x3D; props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Text style&#x3D;&#123;[styles.defaultStyle, style]&#125; &#123;...restProps&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;&#x2F;Text&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参考 <a href="https://github.com/Ajackster" target="_blank" rel="noopener">Ajackster</a>/<strong><a href="https://github.com/Ajackster/react-native-global-props" target="_blank" rel="noopener">react-native-global-props</a></strong> 的实现，在项目入口位置，修改组件的 render 方法。</p></li></ol><p>方案二虽然方便，但不是官方解法，万一有坑就 GG 了。而方案一如果是已有项目，则需要批量修改代码。<br>这里顺便提一下在 vscode 里批量替换的方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 将正则，大小写，全匹配 三个按钮点亮</span><br><span class="line">find: Text(,|\s)(.*react-nativ<span class="string">e';)</span></span><br><span class="line"><span class="string">replace: $2\nimport Text from '</span>Your/<span class="type">Text</span><span class="string">';</span></span><br></pre></td></tr></table></figure><p>一开始我是这么写的，只考虑到了单行，结果下面这种情况没有替换掉：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line"><span class="built_in">  StyleSheet,</span></span><br><span class="line"><span class="built_in">  ViewStyle,</span></span><br><span class="line"><span class="built_in">  View,</span></span><br><span class="line"><span class="built_in">  Text,</span></span><br><span class="line"><span class="built_in">  Image,</span></span><br><span class="line"><span class="built_in">  TouchableOpacity,</span></span><br><span class="line">&#125; from 'react-native'<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>后面换成 <code>\sText[,|\s]\n?([\s\S]*&#39;react-native&#39;;)</code> 在浏览器里可以匹配上，但是 vscode 无法匹配 🤔。 最后简单写个脚本补全上面的漏网之鱼:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> replace = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    glob(<span class="string">'src/**/*.tsx'</span>, &#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> reg = <span class="regexp">/\sText[,|\s]\n?([\s\S]*'react-native';)/</span>;</span><br><span class="line">      files.forEach(<span class="keyword">async</span> (file) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> content = <span class="keyword">await</span> util.promisify(fs.readFile)(file, <span class="string">'utf8'</span>);</span><br><span class="line">        <span class="keyword">const</span> newContent = content.replace(reg, (m, p1) =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">` <span class="subst">$&#123;p1.trim()&#125;</span></span></span><br><span class="line"><span class="string">import Text from '@/components/Text';`</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">await</span> util.promisify(fs.writeFile)(file, newContent, <span class="string">'utf8'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">replace();</span><br></pre></td></tr></table></figure><p>🤔 上面 CustomText 的写法有一个问题，即嵌套 Text 的样式如果是自定义组件中默认的样式，将不会被继承:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text style&#x3D;&#123;&#123; color: &#39;red&#39; &#125;&#125;&gt;</span><br><span class="line">  &lt;Text&gt;red&lt;&#x2F;Text&gt;</span><br><span class="line">  &lt;Text&gt;red&lt;&#x2F;Text&gt;</span><br><span class="line">&lt;&#x2F;Text&gt;</span><br><span class="line"></span><br><span class="line">&lt;CustomText style&#x3D;&#123;&#123; color: &#39;red&#39; &#125;&#125;&gt;</span><br><span class="line">  &lt;CustomText&gt;not red&lt;&#x2F;Text&gt;</span><br><span class="line">  &lt;CustomText&gt;not red&lt;&#x2F;Text&gt;</span><br><span class="line">&lt;&#x2F;CustomText&gt;</span><br></pre></td></tr></table></figure><p>改良版： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Children, isValidElement, cloneElement &#125; from &#39;react&#39;;</span><br><span class="line">import &#123; TextProps, StyleSheet, Text &#125; from &#39;react-native&#39;;</span><br><span class="line"></span><br><span class="line">const styles &#x3D; StyleSheet.create(&#123;</span><br><span class="line">  defaultStyle: &#123;</span><br><span class="line">    color: &#39;#323232&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default function CustomText(</span><br><span class="line">  props: TextProps &amp; &#123; children?: any; useDefaultStyle?: boolean &#125;,</span><br><span class="line">) &#123;</span><br><span class="line">  const &#123; style, useDefaultStyle &#x3D; true, ...restProps &#125; &#x3D; props;</span><br><span class="line">  const newStyle &#x3D; useDefaultStyle ? [styles.defaultStyle, style] : style;</span><br><span class="line"></span><br><span class="line">  const childrenWithProps &#x3D; Children.map(props.children, (child) &#x3D;&gt; &#123; </span><br><span class="line">   if (isValidElement(child)) &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果子元素是个组件，则子组件不使用默认 style</span><br><span class="line">      return cloneElement(child as React.ReactElement&lt;any&gt;, &#123;</span><br><span class="line">        useDefaultStyle: false,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return child;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Text style&#x3D;&#123;newStyle&#125; &#123;...restProps&#125;&gt;</span><br><span class="line">      &#123;childrenWithProps&#125;</span><br><span class="line">    &lt;&#x2F;Text&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view" target="_blank" rel="noopener">react-native-scrollable-tab-view</a></p><p><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view" target="_blank" rel="noopener">react-native-scrollable-tab-view</a> 组件作为 ScrollView 的子组件时不可用，会出现 tab 选中不一致，tab content 无法撑开的现象，详情看：<a href="https://github.com/ptomasroos/react-native-scrollable-tab-view/issues/982" target="_blank" rel="noopener">https://github.com/ptomasroos/react-native-scrollable-tab-view/issues/982</a></p></li><li><p>设置环境变量<br>通常我们的 web 项目可以在 npm script 里通过设置 NODE_ENV 来设置不同的环境变量。比如 <code>NODE_ENV=develope node index.js</code>, 之后可以在代码中通过 <code>process.env.NODE_ENV</code> 来判断具体是哪个环境。rn 项目要达到同样的目的，则需要额外安装 babel 插件 <a href="https://www.npmjs.com/package/babel-plugin-transform-inline-environment-variables" target="_blank" rel="noopener">babel-plugin-transform-inline-environment-variables</a>（或者可以通过 <a href="https://github.com/luggit/react-native-config" target="_blank" rel="noopener">react-native-config</a>，不过这个方法没有去验证，因为低于 6.x 版本的需要客户端 link）</p></li></ul><h5 id="ScrollView-与-Keyboard"><a href="#ScrollView-与-Keyboard" class="headerlink" title="ScrollView 与 Keyboard"></a>ScrollView 与 Keyboard</h5><p>场景： 当 ScrollView / FlatList / SectionList 中包含输入框时，点击输入框唤起键盘。如果此时输入框右侧有清除输入的按钮，点击时首先会将键盘收起，之后再次点击才会执行 onPress。</p><p>方案：将 <code>keyboardShouldPersistTaps</code> 属性设置为 <code>always</code>，点击清除输入的按钮，键盘不会自动收起。</p><h5 id="iOS-Text"><a href="#iOS-Text" class="headerlink" title="iOS Text"></a>iOS Text</h5><p>ios 的 Text 组件 <code>borderRadius</code> | <code>textAlignVertical</code> 属性无效，只能外层再包个 View</p><h5 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h5><p>RN 的盒模型是 border-box, 即 宽高包括了 padding 和 border。</p><p>在开发中发现如果容器具有 backgroundColor 与 borderRadius 后，设置一个不同颜色的 border, 该容器外围会有一层浅浅的 backgroundColor 描边（目前仅 ios 有这种情况）解决方案：在容器外层再包一个 View，设置 border 样式</p><h5 id="FlatList-的-onViewableItemsChanged"><a href="#FlatList-的-onViewableItemsChanged" class="headerlink" title="FlatList 的 onViewableItemsChanged"></a>FlatList 的 onViewableItemsChanged</h5><p>onViewableItemsChanged 的方法在 FlatList 的生命周期中不可以改变，否则报错：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invariant Violation: Changing onViewableItemsChanged <span class="keyword">on</span> <span class="keyword">the</span> fly <span class="keyword">is</span> <span class="keyword">not</span> supported</span><br></pre></td></tr></table></figure><p>如果是类组件，可以在 constructor 中定义该方法，如果是函数组件，可以通过 useRef 包裹该方法。</p><h5 id="等宽字体"><a href="#等宽字体" class="headerlink" title="等宽字体"></a>等宽字体</h5><p>如果字体不是等宽的话，倒计时组件会产生宽度抖动。ios 和 安卓平台的字体并不通用，参考 <a href="https://github.com/react-native-training/react-native-fonts。想要设置等宽字体可以设置" target="_blank" rel="noopener">https://github.com/react-native-training/react-native-fonts。想要设置等宽字体可以设置</a> Text 如下样式属性：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">fontVariant:</span> [<span class="string">'tabular-nums'</span>] <span class="comment">// 仅 IOS</span></span><br><span class="line"><span class="string">fontFamily:</span> Platform.OS === <span class="string">'android'</span> ? 'monospace' : undefined <span class="comment">// 如果是安卓则设置字体为 monospace</span></span><br></pre></td></tr></table></figure><p>注意如果 fontFamily 指定的字体不存在，则页面将报错</p><h5 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h5><p>轮播图一开始用的是社区里 star 数比较高的 <a href="https://github.com/leecade/react-native-swiper/issues/932，" target="_blank" rel="noopener">https://github.com/leecade/react-native-swiper/issues/932，</a></p><p>☠️ 但是这个组件存在一个坑：如果 loop 为 true，rerender 的时候，会先展示最后一项，再闪回到第一项。这个 bug 存在好几年了，提了很多 issue，都没有解决掉，例如 <a href="https://github.com/leecade/react-native-swiper/issues/932" target="_blank" rel="noopener">https://github.com/leecade/react-native-swiper/issues/932</a> </p><p>由于项目比较紧张，又没有时间自己去实现一个，后面发现 <a href="https://github.com/f111fei/react-native-banner-carousel" target="_blank" rel="noopener">https://github.com/f111fei/react-native-banner-carousel</a> 这个仓库不存在该问题。后续还是需要自己去研究一下 rn 的轮播图实现方案。</p><h5 id="stickyHeaderIndices"><a href="#stickyHeaderIndices" class="headerlink" title="stickyHeaderIndices"></a>stickyHeaderIndices</h5><p>ScrollView 提供 stickyHeaderIndices 可以指定滚动时吸顶的组件索引</p><p>☠️ 这个属性如果是动态的会导致 ScrollView 无法正常渲染，见 // <a href="https://github.com/facebook/react-native/issues/25157" target="_blank" rel="noopener">https://github.com/facebook/react-native/issues/25157</a> ，解决的方法是将 removeClippedSubviews 设置成 false </p><h5 id="关闭弹窗与跳转新页面"><a href="#关闭弹窗与跳转新页面" class="headerlink" title="关闭弹窗与跳转新页面"></a>关闭弹窗与跳转新页面</h5><p>在我们的 ios 客户端发现一个问题：点击一个 Modal 中的内容后，关闭该 modal 并打开一个新的 webview，此时有很大概率无法打开新 webview。</p><p>猜测是由于关闭 modal 的动画影响到打开新 webview（不清楚是否 ios 原生就是如此）</p><p>解决方案就是延迟 300ms 后再打开新 webview</p><p>未完待续～</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次搭建 react 项目遇到的坑</title>
      <link href="/2020/07/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%20react%20%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2020/07/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%20react%20%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>电商项目需要搭建一个 h5 项目。这里简单记录一下搭建过程遇到的坑，作为总结。</p><a id="more"></a><p>ui 框架：为了统一 ui 框架，因此选择使用 antd-mobile。<br>打包：parceljs 在此前的项目中已经使用过很多次了，打包速度较 cra 快，且配置简单，因此拟用 parcel。<br>ts：多人项目还是上 ts，没什么好说的。<br>很快就搭建好 demo，接着就开始遇到一些问题。</p><h5 id="antd-mobile-按需加载"><a href="#antd-mobile-按需加载" class="headerlink" title="antd-mobile 按需加载"></a>antd-mobile 按需加载</h5><p>antd-mobile 按需加载推荐使用 <a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .babelrc or babel-loader option</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"import"</span>, &#123; <span class="attr">"libraryName"</span>: <span class="string">"antd-mobile"</span>, <span class="attr">"style"</span>: <span class="string">"css"</span> &#125;] <span class="comment">// `style: true` 会加载 less 文件</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此前 parcel 实际上内置支持了 ts，直接转成 es5 了，因此此前没有额外再配置 babel。<br>🤔 babel-plugin-import 只支持 es6 module 写法的代码，看来需要先把 ts 转成 es6 然后在通过 babel 转成 es5， 没问题，安排～ 于是：</p><ol><li><p>新增 .babelrc</p></li><li><p>修改 tsconfig 的 module 为 <code>es6</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"ES6"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目启动，没问题。但是 vscode 开始报错：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">&#x2F;&#x2F; Module &#39;&quot;&#x2F;node_modules&#x2F;@types&#x2F;react&#x2F;index&quot;&#39; can only be default-imported using the &#39;allowSyntheticDefaultImports&#39; flag</span><br></pre></td></tr></table></figure><p>根本原因是由于 react 导出如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'react.development.js'</span>)</span><br></pre></td></tr></table></figure><p>而非</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.default = <span class="built_in">require</span>(<span class="string">'react.development.js'</span>)</span><br></pre></td></tr></table></figure><p>Babel 会在 commonjs 格式添加 default 导出，那我们要做的就是让 ts 不要提示这种类型的报错：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🤔 不过为什么一开始 parcel 不会报错呢？</p><p>接下来路由动态引入组件开始报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Suspense, lazy &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">const List &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;modules&#x2F;List&#39;))</span><br><span class="line">&#x2F;&#x2F; Dynamic imports are only supported when the &#39;--module&#39; flag is set to &#39;es2020&#39;, &#39;esnext&#39;, &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, or &#39;umd&#39;.</span><br></pre></td></tr></table></figure><p>看来 <code>es6</code> 是不支持 import() 语法, 那好办，将 module 改成 <code>esnext</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"ESNext"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来引入 anti-mobile 组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; List &#125; <span class="keyword">from</span> <span class="string">'antd-mobile'</span></span><br><span class="line"><span class="comment">// Cannot find module 'antd-mobile' or its corresponding type declarations.</span></span><br></pre></td></tr></table></figure><p>此时提示找不到对应的模块声明， 此时我的内心是崩溃的，看起来应该是模块解析路径不对，因此在 tsconfig 中显式配置 <code>moduleResolution</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"moduleResolution"</span>: <span class="string">"Node"</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不再报错了，看看 ts 文档的解释吧，ts 共有两种可用的模块解析策略：<a href="https://www.tslang.cn/docs/handbook/module-resolution.html#node" target="_blank" rel="noopener">Node</a>和<a href="https://www.tslang.cn/docs/handbook/module-resolution.html#classic" target="_blank" rel="noopener">Classic</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span> === <span class="string">"AMD"</span> or <span class="string">"System"</span> or <span class="string">"ES6"</span> ? <span class="string">"Classic"</span> : <span class="string">"Node"</span></span><br></pre></td></tr></table></figure><p>🤔 按理说 module 为 esnext 的话岂不是应该按 node 策略解析？但是目前看来似乎不是这样的？</p><h5 id="配置-antd-mobile-主题"><a href="#配置-antd-mobile-主题" class="headerlink" title="配置 antd-mobile 主题"></a>配置 antd-mobile 主题</h5><p>接下来需要配置主题，anti-mobile 推荐使用 <a href="http://lesscss.org/usage/#using-less-in-the-browser-modify-variables" target="_blank" rel="noopener">modifyVars</a> 来配置主题。<br>将 .babelrc 改成做一下调整：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [<span class="string">"import"</span>, &#123;<span class="string">"libraryName"</span>: <span class="string">"antd-mobile"</span>, <span class="string">"style"</span>: <span class="literal">true</span>&#125;],</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照 webpack 的经验，此时需要开启 <code>javascriptEnabled: true</code>问题来了 parcel 内置支持 less ，那我们要在哪里去配置 less 呢？根据 <a href="https://github.com/parcel-bundler/parcel/issues/907" target="_blank" rel="noopener">issue</a> 提到可以用 .lessrc 文件来配置，但是我经过尝试发现其实是无效的。。<br>至此基本放弃 parcel。parcel 在快速搭建实验性项目时确实有一定的优势，不过生态确实不如 webpack，由此转向使用 create-react-app</p><h5 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h5><p>使用 cra 很快也建好 demo，解决如何让 cra 创建的项目支持 less ，这个简单：<br>通过 <code>customize-cra</code> 提供的 <code>addLessLoader</code> 方法即可，同时也提供了 <code>fixBabelImports</code> 可以很方便的添加 babel-plugin-import 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; override, fixBabelImports, addLessLoader &#125; = <span class="built_in">require</span>(<span class="string">'customize-cra'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = override(</span><br><span class="line">  fixBabelImports(<span class="string">'import'</span>, &#123;</span><br><span class="line">    libraryName: <span class="string">'antd-mobile'</span>,</span><br><span class="line">    style: <span class="literal">true</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  addLessLoader(&#123;</span><br><span class="line">    lessOptions: &#123;</span><br><span class="line">      javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">      modifyVars: &#123;</span><br><span class="line">        <span class="string">'@brand-primary'</span>: <span class="string">'#ff74b9'</span>,</span><br><span class="line">        <span class="string">'brand-primary-tap'</span>: <span class="string">'#ff9cca'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><p>接着是配置路径别名遇到的问题，通过 <code>customize-cra</code> 提供的 <code>addWebpackAlias</code> 可以配置别名，但是 typescript 一直无法解析对应别名，那么应该只需要配置好 ts 的 paths 就行了吧：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"baseUrl"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="attr">"paths"</span>: &#123;</span><br><span class="line">      <span class="attr">"@/*"</span>: [<span class="string">"./src/*"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vscode 不再报错了,接下来就是见证奇迹的时刻了<code>npm run start</code>：<br>控制台显示 <code>- compilerOptions.paths must not be set (aliased imports are not supported)</code> 并且 cra 会自动把 tscongfig 中的 paths 移除掉 😂<br>根据 <a href="https://github.com/timarney/react-app-rewired/issues/375" target="_blank" rel="noopener">issue</a>，使用将 baseUrl 和 paths 的配置移动到单独的文件后，在 tsconfig 里通过 extends 的方式继承，虽然控制台依然提示错误，但是别名可以生效。</p><h5 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h5><p>在 build 时，mini-css-extract-plugin 提示 Conflicting order， 错误位置在 antd-mobile 的样式文件。根据 <a href="https://github.com/ant-design/ant-design/issues/14895" target="_blank" rel="noopener">issue</a> 以及 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250" target="_blank" rel="noopener"> issue </a>看来这个问题主要是由于懒加载加上 antd 组件导入顺序不一致导致的，目前看来无需解决。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重学 Generator《一》</title>
      <link href="/2020/07/15/%E9%87%8D%E5%AD%A6%20Generator%E3%80%8A%E4%B8%80%E3%80%8B/"/>
      <url>/2020/07/15/%E9%87%8D%E5%AD%A6%20Generator%E3%80%8A%E4%B8%80%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>在实际工作的业务开发中，使用到 Generator 比较少。近期有个项目状态管理使用的是 redux-saga，而 redux-saga 又是基于 Generator，借此机会重新学了下 Generator。</p><p>本文主要是记录 generator 的要点，以防将来遗忘。</p><a id="more"></a><h5 id="调用-generator-将会返回一个迭代器"><a href="#调用-generator-将会返回一个迭代器" class="headerlink" title="调用 generator 将会返回一个迭代器"></a>调用 generator 将会返回一个迭代器</h5><p>所谓 generator 实际上就是带有 * 的函数，调用后不会执行 generator 内部代码，而是返回一个 iterator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'generator'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction()</span><br><span class="line"><span class="built_in">console</span>.log(iterator[<span class="built_in">Symbol</span>.iterator])</span><br><span class="line"></span><br><span class="line"><span class="comment">// function [Symbol.iterator]()</span></span><br></pre></td></tr></table></figure><h5 id="执行-generator"><a href="#执行-generator" class="headerlink" title="执行 generator"></a>执行 generator</h5><p>每次调用返回的迭代器的 next 方法可以执行 generator 中的代码，直到执行完遇到的第一个 yield 或者 return 后并交出执行权</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">  <span class="keyword">yield</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction()</span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h5 id="return-与-yield-的异同"><a href="#return-与-yield-的异同" class="headerlink" title="return 与 yield 的异同"></a>return 与 yield 的异同</h5><p>执行 iterator.next 返回的是一个包括 value 和 done 两个属性的对象，这个对象的 value 就是 <code>yield</code> 或 <code>return</code> 后面表达式的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction()</span><br><span class="line"><span class="keyword">var</span> a = iterator.next()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="keyword">var</span> b = iterator.next()</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>yield 与 return 类似，但 yield 是暂停的意思，而 return 则代表结束, return 之后的代码将不会被执行到。</p><p>done 为 true 表示遍历结束，但是此时依然可以可以继续调用 iterator.next()，只不过返回值将是 { value: undefined, done: true }。</p><p><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，直到 done 变为 true。</p><p>⚠️ done 为 true 的运行结果会被抛弃掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h5 id="next-的参数"><a href="#next-的参数" class="headerlink" title="next 的参数"></a>next 的参数</h5><p>next 的参数可以最为 yield 语句的返回值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">yield</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// a 1</span></span><br></pre></td></tr></table></figure><h5 id="yield"><a href="#yield" class="headerlink" title="yield *"></a>yield *</h5><p>通过 yield * 可以进入到另一个 generator 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'foo'</span>;</span><br><span class="line">    <span class="keyword">yield</span> * bar();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'bar'</span>;</span><br><span class="line">    <span class="keyword">yield</span> * baz();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'baz'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure><h5 id="向-generaotr-内部抛异常"><a href="#向-generaotr-内部抛异常" class="headerlink" title="向 generaotr 内部抛异常"></a>向 generaotr 内部抛异常</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generatorFunction = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="string">'a'</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Generator caught'</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> iterator = generatorFunction();</span><br><span class="line">iterator.next();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    iterator.throw(<span class="string">'a'</span>);</span><br><span class="line">    iterator.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Uncaught'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Generator caught a</span></span><br><span class="line"><span class="comment">// Uncaught b</span></span><br></pre></td></tr></table></figure><p>资料主要参考自  <a href="https://github.com/gajus/gajus.com-blog/blob/master/posts/the-definitive-guide-to-the-javascript-generators/index.md" target="_blank" rel="noopener">generator 权威指南</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
