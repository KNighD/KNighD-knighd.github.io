<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于 webpack 的 tree shaking</title>
      <link href="/2021/05/27/%E5%85%B3%E4%BA%8E-webpack-%E7%9A%84-tree-shaking/"/>
      <url>/2021/05/27/%E5%85%B3%E4%BA%8E-webpack-%E7%9A%84-tree-shaking/</url>
      
        <content type="html"><![CDATA[<p>最近重新翻看了下 ant design 的文档，发现这样一段话</p><blockquote><p><code>antd</code> 默认支持基于 ES modules 的 tree shaking，对于 js 部分，直接引入 <code>import &#123; Button &#125; from &#39;antd&#39;</code> 就会有按需加载的效果。</p></blockquote><p>而之前的版本要做到按需加载是通过 <a href="https://github.com/ant-design/babel-plugin-import">babel-plugin-import</a> ，通过修改引用路径来实现的。</p><p>虽然也知道 tree shaking，但没有深入去了解具体的配置。以下简单记录一下探索的过程，webpack 版本为 5.37.1。</p><a id="more"></a><p>tree shaking 简单来说就是可以将代码中没有使用到的代码移除，以减少包的体积。</p><p>根据 <a href="https://webpack.js.org/guides/tree-shaking/#conclusion">webpack 文档</a>可知，影响 webpack tree shaking 有以下几点：</p><ol><li>使用 esm 语法（import，export）</li><li>未将代码编译成 CommonJS，常见的如 @babel/preset-env 这个预设就会将代码编译成 CommonJS</li><li>package.json 添加 sideEffects 字段</li><li>mode 必须是 production</li></ol><p>文档里的说明有点绕，因此我简单写了几个 case 测试实际效果如何</p><h4 id="1-符合所有条件的情况"><a href="#1-符合所有条件的情况" class="headerlink" title="1. 符合所有条件的情况"></a>1. 符合所有条件的情况</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; a.jsexport const a1 &#x3D; &#39;a1&#39;export const a2 &#x3D; &#39;a2&#39;&#x2F;&#x2F; index.jsimport &#123; a1, a2 &#125; from &#39;.&#x2F;a&#39;console.log(a1)&#x2F;&#x2F; webpack.config.jsmode: &#39;production&#39;&#x2F;&#x2F; package.json&quot;sideEffects&quot;: false&#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;console.log(&quot;a1&quot;)&#125;)();</code></pre><p>可以看到虽然 a.js 文件中包含了 a2，但是实际打包却并未将其打包进去</p><h4 id="2-非-production-模式"><a href="#2-非-production-模式" class="headerlink" title="2. 非 production 模式"></a>2. 非 production 模式</h4><p>将上述 mode 改成 development</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 输出...&#x2F;***&#x2F; &quot;.&#x2F;src&#x2F;a.js&quot;:&#x2F;*!******************!*\  !*** .&#x2F;src&#x2F;a.js ***!  \******************&#x2F;&#x2F;***&#x2F; ((__unused_webpack_module, __webpack_exports__, __webpack_require__) &#x3D;&gt; &#123;eval(&quot;__webpack_require__.r(__webpack_exports__);\n&#x2F;* harmony export *&#x2F; __webpack_require__.d(__webpack_exports__, &#123;\n&#x2F;* harmony export *&#x2F;   \&quot;a1\&quot;: () &#x3D;&gt; (&#x2F;* binding *&#x2F; a1),\n&#x2F;* harmony export *&#x2F;   \&quot;a2\&quot;: () &#x3D;&gt; (&#x2F;* binding *&#x2F; a2)\n&#x2F;* harmony export *&#x2F; &#125;);\nconst a1 &#x3D; &#39;a1&#39;\nconst a2 &#x3D; &#39;a2&#39;\n\n&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;test-webpack&#x2F;.&#x2F;src&#x2F;a.js?&quot;);&#x2F;***&#x2F; &#125;),...</code></pre><p>可以看到这次将 a2 打包进来了，即 development 模式下是不会进行 tree shaking 的</p><p>而如果，我们开启了<code>optimization.usedExports</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; webpack.config.jsoptimization: &#123;  usedExports: true,&#125;,</code></pre><p>可以看到</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;***&#x2F; &#39;.&#x2F;src&#x2F;a.js&#39;:      &#x2F;*!******************!*\  !*** .&#x2F;src&#x2F;a.js ***!  \******************&#x2F;      &#x2F;***&#x2F; (        __unused_webpack_module,        __webpack_exports__,        __webpack_require__      ) &#x3D;&gt; &#123;        eval(          &#39;&#x2F;* harmony export *&#x2F; __webpack_require__.d(__webpack_exports__, &#123;\n&#x2F;* harmony export *&#x2F;   &quot;a1&quot;: () &#x3D;&gt; (&#x2F;* binding *&#x2F; a1)\n&#x2F;* harmony export *&#x2F; &#125;);\n&#x2F;* unused harmony export a2 *&#x2F;\nconst a1 &#x3D; &quot;a1&quot;\n\nconst a2 &#x3D; \&#39;a2\&#39;\n\n\n\n&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;test-webpack&#x2F;.&#x2F;src&#x2F;a.js?&#39;        )        &#x2F;***&#x2F;      &#125;,</code></pre><p>这里看到 <code>unused harmony export a2</code> 即 webpack 标识 a2 没有被实际使用到。</p><p>这里 optimization.usedExports 在 webpack 文档里提到，可以用于别的压缩工具压缩时移除掉。</p><p>奇怪的是，这里我根据文档说明，配置了<code>concatenateModules</code> 与 <code>TerserPlugin</code> ，但是没能将 a2 tree shaking 掉</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; webpack.config.js&#123;  ...  mode: &#39;development&#39;,  optimization: &#123;    usedExports: true,    minimize: true,    minimizer: [new TerserPlugin(&#123;&#125;)],    concatenateModules: true,    providedExports: true,  &#125;&#125;&#x2F;&#x2F;输出;(() &#x3D;&gt; &#123;  &#39;use strict&#39;  var __webpack_modules__ &#x3D; &#123;      &#39;.&#x2F;src&#x2F;index.js&#39;: () &#x3D;&gt; &#123;        eval(          &#39;\n;&#x2F;&#x2F; CONCATENATED MODULE: .&#x2F;src&#x2F;a.js\nconst a1 &#x3D; &quot;a1&quot;\n\nconst a2 &#x3D; \&#39;a2\&#39;\n\n\n;&#x2F;&#x2F; CONCATENATED MODULE: .&#x2F;src&#x2F;index.js\n\n\nconsole.log(a1)\n\n\n&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;test-webpack&#x2F;.&#x2F;src&#x2F;index.js_+_1_modules?&#39;        )      &#125;,    &#125;,    __webpack_exports__ &#x3D; &#123;&#125;  __webpack_modules__[&#39;.&#x2F;src&#x2F;index.js&#39;]()&#125;)()</code></pre><p>但如果上述的配置，将 mode 改成 ‘none’ 之后又是能正确 tree shaking 的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; webpack.config.js&#123;  ...  mode: &#39;none&#39;,  optimization: &#123;    usedExports: true,    minimize: true,    minimizer: [new TerserPlugin(&#123;&#125;)],    concatenateModules: true,    providedExports: true,  &#125;,&#125;&#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;console.log(&quot;a1&quot;)&#125;)();</code></pre><p>如果将相关配置移除掉，那即使是在 none 模式下也是不能正常 tree shaking 的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; webpack.config.js&#123;...mode: &#39;none&#39;,  optimization: &#123;    usedExports: true,    &#x2F;&#x2F; minimize: true,    &#x2F;&#x2F; minimizer: [new TerserPlugin(&#123;&#125;)],    &#x2F;&#x2F; concatenateModules: true,    &#x2F;&#x2F; providedExports: true,  &#125;,&#125;  &#x2F;&#x2F; 输出&#x2F;***&#x2F; ((__unused_webpack_module, __webpack_exports__, __webpack_require__) &#x3D;&gt; &#123;&#x2F;* harmony export *&#x2F; __webpack_require__.d(__webpack_exports__, &#123;&#x2F;* harmony export *&#x2F;   &quot;a1&quot;: () &#x3D;&gt; (&#x2F;* binding *&#x2F; a1)&#x2F;* harmony export *&#x2F; &#125;);&#x2F;* unused harmony export a2 *&#x2F;const a1 &#x3D; &quot;a1&quot;const a2 &#x3D; &#39;a2&#39;&#x2F;***&#x2F; &#125;)</code></pre><p>可见配置好了 usedExports 与 TerserPlugin 以及 concatenateModules 等相关配置，即使在别的 mode 下也是能将无用的代码 tree shaking 掉的。不过目前为止还没找到为什么这个配置在 development 模式下没能 tree shaking 掉。。待后续研究。不过作为平时开发，我们几乎不会在 development 模式下去研究 tree shaking 就是了</p><h4 id="3-改成-commonjs"><a href="#3-改成-commonjs" class="headerlink" title="3. 改成 commonjs"></a>3. 改成 commonjs</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; index.jsconst &#123; a1 &#125; &#x3D; require(&#39;.&#x2F;a&#39;)console.log(a1)&#x2F;&#x2F; 输出（格式化后）...var e &#x3D; &#123;      85: (e, o, r) &#x3D;&gt; &#123;        &#39;use strict&#39;        r.r(o), r.d(o, &#123; a1: () &#x3D;&gt; t, a2: () &#x3D;&gt; n &#125;)        const t &#x3D; &#39;a1&#39;,          n &#x3D; &#39;a2&#39;      &#125;,    &#125;...</code></pre><p>可以看到 a2  还是被打包进来了，因此 commonjs 是不支持 tree shaking 的</p><h4 id="4-sideEffects"><a href="#4-sideEffects" class="headerlink" title="4. sideEffects"></a>4. sideEffects</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; package.json 移除掉 sideEffects&#x2F;&#x2F; &quot;sideEffects&quot;: false&#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;console.log(&quot;a1&quot;)&#125;)();</code></pre><p>看起来即使未配置 sideEffects 也不影响到 tree shaking</p><p>对此我产生了一个疑惑，那么 sideEffects 的作用是什么？为什么文档里又说 sideEffects 是必须要配置的？</p><p>因此我又做了以下几个实验</p><ol><li><p>IIFE</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; a.jsexport const a1 &#x3D; &#39;a1&#39;export const a2 &#x3D; &#39;a2&#39;export const a3 &#x3D; (function () &#123;  console.log(&#39;a3&#39;)  return &#39;a3&#39;&#125;)()&#x2F;&#x2F; index.jsimport &#123; a1, a2 &#125; from &#39;.&#x2F;a&#39;console.log(a1)&#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;console.log(&quot;a3&quot;),console.log(&quot;a1&quot;)&#125;)();</code></pre><p>无论 package.json 中 sideEffects 是否配置，即使我们没有使用到 a3， IIFE 中的代码会被打包进去执行,但是 a3 是不会被打包进去的。</p></li><li><p>样式文件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; webpack.config.jsmodule: &#123;  rules: [    &#123;      test: &#x2F;\.css$&#x2F;i,      use: [&#39;style-loader&#39;, &#39;css-loader&#39;],    &#125;,  ],&#125;,  &#x2F;&#x2F; style.cssbody &#123;  background-color: red;&#125;  &#x2F;&#x2F; index.jsimport &#39;.&#x2F;style.css&#39;</code></pre><p>这里就有差别了，如果我们此时配置 <code>sideEffects: false</code> 那么输出将会是空白内容，如果将 <code>sideEffects: false</code> 删掉，则输出</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">...o.push([e.id, &#39;body &#123;\n  background-color: red;\n&#125;\n&#39;, &#39;&#39;])...</code></pre><p>也就是说引入样式文件会被认为一种副作用，如果 sideEffects：false，则认为我们的代码中没有包含副作用的模块，可以放心将样式文件移除。如果我们配置 <code>sideEffects：[&quot;src/style.css&quot;]</code>,即配置 style.css 为有副作用的模块，那么此时也是会将 style.css 打包进去的</p></li><li><p>polyfill</p><p>如果在代码中修改了全局变量，或原型会发生什么</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; b.jswindow.b1 &#x3D; &#39;b1&#39;Array.prototype.test &#x3D; function () &#123;  console.log(&#39;test&#39;)&#125;&#x2F;&#x2F; index.jsimport &#39;.&#x2F;b&#39;&#x2F;&#x2F; package.json&#x2F;&#x2F; sideEffects: false&#x2F;&#x2F; 输出...;(window.b1 &#x3D; &#39;b1&#39;),  (Array.prototype.test &#x3D; function () &#123;  console.log(&#39;test&#39;)&#125;)...</code></pre><p>与样式的结果是一样的，即如果配置了 sideEffect: false，则认为所有文件模块都是没有副作用的，就不会将 b.js 中的内容打包</p></li><li><p>作为 npm 包</p><p>上面的实验都是引用本地文件，那 webpack 是如何对依赖进行 tree shaking 的呢？这里我新开一个项目 test-npm，并且将当前项目 link 过去</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; npm-test src&#x2F;index.jsexport &#123; a3 &#125; from &#39;.&#x2F;a&#39;export const a1 &#x3D; &#39;a1&#39;export const a2 &#x3D; &#39;a2&#39;&#x2F;&#x2F; npm-test src&#x2F;index.jsexport const a3 &#x3D; &quot;a3&quot;window.a4 &#x3D; &quot;a4&quot;&#x2F;&#x2F; npm-test package.json&quot;module&quot;: &quot;src&#x2F;index.js&quot;,</code></pre><p>在 test-npm 中，指定 esm 入口文件为 src/index.js，在这里重新的导出 a.js 中的 a3，然而 a.js 中存在一个副作用 <code>window.a4 = &quot;a4&quot;</code></p><p>当我们在项目中使用时，无论是否用到 a3，都会将 a4 这个副作用引进来</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; index.jsimport &#123; a1 &#125; from &#39;test-npm&#39;console.log(a1)&#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;window.a4&#x3D;&quot;a4&quot;,console.log(&quot;a1&quot;)&#125;)();</code></pre><p>而当在 test-npm 中我们配置了 <code>sideEffects: false</code> 之后，只有使用到 a3 才会将 a4 这个副作用引进来。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; index.jsimport &#123; a1 &#125; from &#39;test-npm&#39;console.log(a1)&#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;console.log(&quot;a1&quot;)&#125;)();</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; index.jsimport &#123; a1, a3 &#125; from &#39;test-npm&#39;console.log(a1, a3)&#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;window.a4&#x3D;&quot;a4&quot;,console.log(&quot;a1&quot;,&quot;a3&quot;)&#125;)();</code></pre><p>实际上我们还可以通过 <code>/*#__PURE__*/</code> 这个注释来表示语句是无副作用的，这里就不展开探讨。</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上面的用例并没有做到完全的控制变量，仅供参考。然后这里我结合自己的理解来试图说明 webpack 中 tree shaking ：webpack 有两个方式做 tree shaking，一方面是通过 optimization.usedExports 以及 压缩工具来移除。但是这种方式做不到移除包含副作用的代码，如果我们需要移除可能包含副作用的代码，就需要用到第二个方式，配置 sideEffects 告知 webpack 当前项目中哪些文件可能包含副作用或者当前项目完全没有副作用。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录保存网页的脚本优化过程</title>
      <link href="/2021/05/21/%E8%AE%B0%E5%BD%95%E4%BF%9D%E5%AD%98%E7%BD%91%E9%A1%B5%E7%9A%84%E8%84%9A%E6%9C%AC%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/05/21/%E8%AE%B0%E5%BD%95%E4%BF%9D%E5%AD%98%E7%BD%91%E9%A1%B5%E7%9A%84%E8%84%9A%E6%9C%AC%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>近期为了看文章开了网站会员，想把内容保存到本地，以便后续回顾，为此写了个脚本，记录一下思考的过程</p><a id="more"></a><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>长截图，然而一方面，长截图效果不太好，保存下来是图片，文字也不能选中，而且操作也麻烦。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>chrome dev tool 提供了 capture snapshot 的功能，可以全屏长截图，或者是对节点进行截图。功能虽好，但依然存在手动的麻烦，并且存下来还是图片</p><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>使用 html2pdf，将网页存成 pdf。<a href="https://github.com/eKoopmans/html2pdf.js">html2pdf</a> 实际上依赖了 <a href="https://github.com/niklasvh/html2canvas">html2canvas</a> 与 <a href="https://github.com/MrRio/jsPDF">jsPDF</a></p><p>存在几个问题：</p><ol><li>原网页做了特殊处理，导致绘制 canvas 时不能正确还原展示样式</li><li>保存成 pdf 时 page-breaks 配置无效，导致文本从中间被断开</li><li>pdf 实际上也是插入 cavans，所以实际体验和图片差不多</li><li>文章中的图片绘制到 canvas 时，会跨域导致无法绘制，需要将 img 标签里的 src 转成 object url 或者 base64</li></ol><p>代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var imgs &#x3D; document.querySelectorAll(&#39;img&#39;)for (let i &#x3D; 0; i &lt; imgs.length; i++) &#123;  var img &#x3D; imgs[i]  await fetch(new Request(img.src))    .then((response) &#x3D;&gt; response.blob())    .then(function (myBlob) &#123;      var objectURL &#x3D; URL.createObjectURL(myBlob)      &#x2F;&#x2F; 将 img 转为 objectURL, 防止跨域      img.src &#x3D; objectURL    &#125;)&#125;function addScript(url) &#123;  var script &#x3D; document.createElement(&#39;script&#39;)  script.type &#x3D; &#39;application&#x2F;javascript&#39;  script.src &#x3D; url  document.head.appendChild(script)&#125;addScript(  &#39;https:&#x2F;&#x2F;raw.githack.com&#x2F;eKoopmans&#x2F;html2pdf&#x2F;master&#x2F;dist&#x2F;html2pdf.bundle.js&#39;)var pdfTitle &#x3D; document.querySelector(&#39;.title&#39;).innerTexthtml2pdf()  .set(&#123;    filename: &#96;$&#123;pdfTitle&#125;.pdf&#96;,  &#125;)  .from(document.body)  .save()</code></pre><h3 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h3><p>利用无头浏览器例如 <a href="https://pptr.dev/">puppeteer</a> （以下简称 pptr）来生成 pdf。这个方案可以完美避开方案三的问题，生成的 pdf 质量也是最好的。但是需要解决一个问题：登录问题。理想的方案是使用 pptr ，启动时即可实现登录，跳转到对应的文章，保存成 pdf。鉴于实现脚本登录的成本较大，将需求拆分，即登录是在 chrome 里手动完成的，之后将整个 html 保存为本地 html，pptr 读取本地 html 并转成 pdf 即可。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>思路</p><ol><li>网站有比较多影响阅读的元素，如目录，用户信息等，需要将这些元素移除，仅保留内容和样式。</li><li>后台起一个 nodejs 搭建的本地服务，当处理完网页后，将整个 html 内容传输给服务器，服务器写入一个本地目录（这里我用 dist）保存起来</li><li>将所有需要保存的文章都存到本地后，运行生成 pdf 脚本，这个脚本读取 dist 目录所有文件，启动 pptr，依次将内容作为网页打开，保存成 pdf</li></ol><p>上述就是第一个版本的做法</p><p>本地服务 server 代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const Koa &#x3D; require(&#39;koa&#39;)const cors &#x3D; require(&#39;@koa&#x2F;cors&#39;)const bodyParser &#x3D; require(&#39;koa-bodyparser&#39;)const fs &#x3D; require(&#39;fs-extra&#39;)const path &#x3D; require(&#39;path&#39;)const app &#x3D; new Koa()&#x2F;&#x2F; 允许跨域app.use(  cors(&#123;    allowHeaders: &#39;*&#39;,  &#125;))app.use(bodyParser())app.use(async (ctx) &#x3D;&gt; &#123;  &#x2F;&#x2F; 接收 &#123; html, title &#125; 参数  const &#123; title, html &#125; &#x3D; ctx.request.body  const dir &#x3D; path.join(__dirname, &#39;..&#x2F;dist&#x2F;&#39;)  try &#123;    await fs.ensureDir(dir)    &#x2F;&#x2F; 注意 title 如果带有 &#x2F; 会导致创建文件失败，将 &#x2F; 替换成 |    &#x2F;&#x2F; 将 title 作为文件名    await fs.writeFile(path.join(dir, &#96;$&#123;title.replace(&#39;&#x2F;&#39;, &#39;｜&#39;)&#125;.html&#96;), html)    ctx.body &#x3D; &#123; code: 200 &#125;  &#125; catch (error) &#123;    console.log(error)  &#125;&#125;)&#x2F;&#x2F; 服务端口 3000app.listen(3000)</code></pre><p>网页登录后，在浏览器控制台输入如下 web,js 代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 主要内容部分var mainEle &#x3D; document.querySelector(&#39;.main&#39;)&#x2F;&#x2F; 文章标题var title &#x3D; document.querySelector(&#39;.title&#39;).innerTextdocument  .querySelectorAll(&#39;script&#39;)  .forEach((s) &#x3D;&gt; s.remove())var body &#x3D; document.querySelector(&#39;body&#39;)&#x2F;&#x2F; 移除其他内容，仅保留主要内容body.innerHTML &#x3D; &#39;&#39;body.appendChild(mainEle)&#x2F;&#x2F; 通过 fetch 将 html 及 title 传给服务端await fetch(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;&#39;, &#123;  method: &#39;POST&#39;,  headers: &#123;    &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,  &#125;,  body: JSON.stringify(&#123;    title,    html: document.documentElement.outerHTML,  &#125;),&#125;)</code></pre><p>pptr 脚本代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const puppeteer &#x3D; require(&#39;puppeteer&#39;)const path &#x3D; require(&#39;path&#39;)const fs &#x3D; require(&#39;fs-extra&#39;);(async () &#x3D;&gt; &#123;  const dist &#x3D; path.resolve(__dirname, &#39;..&#x2F;dist&#39;)  const htmls &#x3D; await fs.readdir(dist)  &#x2F;&#x2F; 启动无头浏览器  const browser &#x3D; await puppeteer.launch()  &#x2F;&#x2F; 打开新页面  const page &#x3D; await browser.newPage()  for (let i &#x3D; 0; i &lt; htmls.length; i++) &#123;    &#x2F;&#x2F; 依次读取 html 文件    const html &#x3D; htmls[i]    var contentHtml &#x3D; await fs.readFile(path.join(dist, html), &#39;utf8&#39;)    &#x2F;&#x2F; 由于页面会有图片，&#123; &#39;waitUntil&#39;: &#39;networkidle0&#39; &#125; 即等待网络请求完成后    await page.setContent(contentHtml, &#123; &#39;waitUntil&#39;: &#39;networkidle0&#39; &#125;)    &#x2F;&#x2F; 生成 pdf 文件，注意这个 api 需要在 headless 模式下才能调用    await page.pdf(&#123; path: path.join(dist, html.replace(&#39;.html&#39;, &#39;.pdf&#39;)) &#125;)  &#125; &#x2F;&#x2F; 关掉浏览器  await browser.close()&#125;)()</code></pre><h3 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h3><p>由于 web,js 中的代码会修改网页，所以每次保存完成之后，需要刷新页面，点击下一页。这需要页面重新加载脚本，样式文件等。因此我们需要一个方法不去修改原网页，所幸，这里我们可以用 cloneNode 来复制整个网页的 dom 结构，这样我们就不用修改原来的 dom 了。</p><p>web-v2.js 代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var doc &#x3D; document.documentElement.cloneNode(true)&#x2F;&#x2F; ...</code></pre><p>这里将 document 深拷贝，之后所有的操作都基于这个深拷贝，就不会影响到原页面</p><h3 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h3><p>上述还有个问题就是需要手动点下一页，然后等待页面加载完成后，重新执行 web-v2.js 。这里也可以完全使用脚本来实现</p><p>Web-v3.js</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async function fetchWeb() &#123;  &#x2F;&#x2F; 深拷贝  var doc &#x3D; document.documentElement.cloneNode(true)  var body &#x3D; doc.querySelector(&#39;body&#39;)  var mainEle &#x3D; body.querySelector(&#39;.main&#39;)  &#x2F;&#x2F; 移除换行符号等特殊字符  var title &#x3D; body.querySelector(&#39;.title&#39;).innerText.replace(&#x2F;\s&#x2F;g, &#39;&#39;)  doc.querySelectorAll(&#39;script&#39;).forEach((s) &#x3D;&gt; s.remove())  body.innerHTML &#x3D; &#39;&#39;  body.appendChild(mainEle)  await fetch(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;&#39;, &#123;    method: &#39;POST&#39;,    headers: &#123;      &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,    &#125;,    body: JSON.stringify(&#123;      title,      html: doc.outerHTML,    &#125;),  &#125;)&#125;&#x2F;&#x2F; 延时函数async function sleep(time) &#123;  return new Promise((resolve) &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve()    &#125;, time)  &#125;)&#125;&#x2F;&#x2F; 跳转下一页function next() &#123;  const btn &#x3D; document.querySelector(&#39;.next&#39;)  btn.click()&#125;&#x2F;&#x2F; total 为需要保存的页数async function fetchAll(total) &#123;  for (let i &#x3D; 0; i &lt; total; i++) &#123;    console.log(&#39;开始&#39;)    await fetchWeb()    &#x2F;&#x2F; 等待 1 s    await sleep(1000)    &#x2F;&#x2F; 点击下一页    next()    &#x2F;&#x2F; 等待 3s 页面基本都加载好了，这里其实可以做的更准确点，比如根据某个元素加载好后开始 fetchWeb    await sleep(3000)  &#125;&#125;</code></pre><p>至此，只需要在浏览器控制台上输入 web-v3 脚本一次，然后运行</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; total 为需要保存的页面数量即可fetchAll(total)</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN 版本升级指北</title>
      <link href="/2021/05/17/RN-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8C%97/"/>
      <url>/2021/05/17/RN-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p>最近客户端打算将 react-native 版本升级到 0.64.1，此前是 0.59 版本。中间踩了不少坑，记录一下升级过程。</p><a id="more"></a><ol><li><p>升级一下 react-native 和 react，由于项目使用了 Typescript，因此还要升级一下对应的 types 库</p><pre class="line-numbers language-none"><code class="language-none">npm i react-native@0.64.1 react@17.0.1 @types&#x2F;react  @types&#x2F;react-native</code></pre></li><li><p>运行后报错: Module xxxx is not a registered callable module.</p><p>根据 <a href="https://github.com/react-native-community/upgrade-support/issues/47">https://github.com/react-native-community/upgrade-support/issues/47</a> 这个 issue 提到的需要配置 metro 中的 resolver 来跳过对 node_modules 中的 react-native 的编译。这让我想到有可能是由于我们用到一个私有包（以下简称 A 吧）。A 这个包里有 react-native 的依赖，并且声明到了 dependencies 里了。因此会存在两个版本的 react-native。</p><p>考虑到这点，我对 A 中的 react-native 也进行了升级。发现即使是相同版本，依然会出现报错。因此打算先按 issue 提到的来进行配置。</p><p>issue 中提到的 resolver 配置如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const blacklist &#x3D; require(&#39;metro-config&#x2F;src&#x2F;defaults&#x2F;blacklist&#39;);module.exports &#x3D; &#123;  transformer: &#123;    getTransformOptions: async () &#x3D;&gt; (&#123;      transform: &#123;        experimentalImportSupport: false,        inlineRequires: false,      &#125;,    &#125;),  &#125;,  resolver: &#123;    blacklistRE: blacklist([      &#x2F;node_modules\&#x2F;.*\&#x2F;node_modules\&#x2F;react-native\&#x2F;.*&#x2F;,    ])  &#125;,&#125;;</code></pre><p>在 0.64.1 里并未找到 blacklist，我这里配置 resolver 为</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const exclusionList &#x3D; require(&#39;metro-config&#x2F;src&#x2F;defaults&#x2F;exclusionList&#39;);module.exports &#x3D; &#123;  transformer: &#123;    getTransformOptions: async () &#x3D;&gt; (&#123;      transform: &#123;        experimentalImportSupport: false,        inlineRequires: false,      &#125;,    &#125;),  &#125;,  resolver: &#123;    blockList: exclusionList([      &#x2F;node_modules\&#x2F;.*\&#x2F;node_modules\&#x2F;react-native\&#x2F;.*&#x2F;,    ]),  &#125;,&#125;;</code></pre><p>这时候可以成功运行。</p><p>更好的办法是，我们不在 A 中将 react-native 设置为 dependency，而仅需要最外层一个 react-native 即可。我们要做到这点，可以将  react-native 从 dependencies 中移除，改为 peerDependencies。同时为了方便开发，我们还应该将其声明到  devDependencies 中。如果做了这些，其实上述 metro 的配置就无需修改了。</p></li><li><p>运行后提示 hook 不能在函数式组件以外使用。我跟着查看了报错的组件，该组件由 A 提供，奇怪的是该组件确实是函数式组件，根据提示，怀疑可能是内外两个版本的 react 导致的，因此类似步骤一所示，将 react 依赖移出即可</p></li><li><p>加载页面时，提示有模块路径引用错误。我们项目中 babel 配置了自定义的 preset（以下简称 B）。B 中使用 babel-plugin-transform-imports 来按需加载 react-native 导出的模块。而由于 react-native 导出的模块路径变更，导致报错。我一开始在想 metro 是否会提供类似 tree-shaking 的处理，搜索后发现 metro 并不支持，见 <a href="https://github.com/facebook/metro/issues/227">https://github.com/facebook/metro/issues/227</a> 。难道只能一个个修改路径了么？</p><p>幸运的是，有这么个 pr <a href="https://github.com/facebook/metro/pull/362">https://github.com/facebook/metro/pull/362</a> ，通过 @babel/plugin-transform-modules-commonjs 将 esm 专程 commonjs 并且实现懒加载，并且还是默认为懒加载，这不就是我需要的么？因此简单处理将 babel-plugin-transform-imports 中关于 react-native 的部分全部删除即可</p></li><li><p>运行提示：A 包中的 TextPropTypes 等文件找不到。看到文档说到：</p><blockquote><p><strong>Remove PropTypes</strong>: We’re removing <code>propTypes</code> from core components in order to reduce the app size impact of React Native core and to favor static type systems which check at compile time instead of runtime</p></blockquote><p>emm，为了减少应用体积已经将 PropTypes 移除了，并且倾向于使用静态类型系统。那就没什么好说了，只能将 PropTypes 相关的移除，后续再慢慢添加类型声明文件。</p></li><li><p>提示： Warning: ReactClass: You’re attempting to include a mixin that is either null or not an object.</p><p>A 包中有部分旧的组件中用到 mixin，react 已经不推荐使用 mixin 啦，并且看到 mixin 的是 NativeMethods，目前没有场景会使用到，先简单移除掉 mixin，后续考虑重构。</p></li><li><p>报错：VirtualizedLists should never be nested inside plain ScrollViews with the same orientation - use another VirtualizedList-backed container instead. 新版本 rn 的 ScrollView 不能嵌套同方向的 VirtualizedList。</p><p>最简单的处理方式是将 ScrollView 改为 FlatList，将原先 ScrollView 中的 children 改为 FlatList 的 ListHeaderComponent, 同时注意 ScrollView 与 FlatList 可能有些 api 不太一样，需要自行调整一下。</p></li><li><p>提示：Calling <code>getNode()</code> on the ref of an Animated component is no longer necessary。Animated 组件不需要通过 getNode 来获取节点了，直接用 ref 即可</p></li><li><p>提示：Animated.event now requires a second argument for options。即此前有默认值的 useNativeDriver，现在需要手动给值了。</p></li><li><p>报错：Invariant Violation: ViewPagerAndroid has been removed from React Native. It can now be installed and imported from ‘@react-native-community/viewpager’ instead of ‘react-native’.  如果有使用到或者是第三方库有使用到 ViewPagerAndroid 的，如 react-native-scrollable-tab-view，记得升级一下，使用 @react-native-community/viewpager。</p></li></ol><p>以上为升级 RN 到 0.64.1 踩过的坑，仅供参考。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 IntersectionObserver 做曝光埋点</title>
      <link href="/2021/04/15/%E5%88%A9%E7%94%A8-IntersectionObserver-%E5%81%9A%E6%9B%9D%E5%85%89%E5%9F%8B%E7%82%B9/"/>
      <url>/2021/04/15/%E5%88%A9%E7%94%A8-IntersectionObserver-%E5%81%9A%E6%9B%9D%E5%85%89%E5%9F%8B%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>前些天接了个紧急的简单需求，有多简单呢，就是一张背景图，然后上面加上一个悬浮的按钮。果然简单！不过按惯例，不可能这么简单。果然第二天就说说加了个需求，需要在这个背景图底部继续增加两行，每行三个商品，需要统计点击和曝光事件。上报点击事件倒是简单，曝光则相对麻烦点。</p><a id="more"></a><p>正如 mdn 上所说的</p><blockquote><p>过去，相交检测通常要用到事件监听，并且需要频繁调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect"><code>Element.getBoundingClientRect()</code></a> 方法以获取相关元素的边界信息。事件监听和调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect"><code>Element.getBoundingClientRect()</code></a> 都是在主线程上运行，因此频繁触发、调用可能会造成性能问题。这种检测方法极其怪异且不优雅。</p></blockquote><p>因此如今的浏览器提供了 IntersectionObserver  这个 api ，每当被监视的元素进入或者退出另外一个元素时(或者 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Viewport">viewport</a> )，或者两个元素的相交部分大小发生变化时，该回调方法会被触发执行。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>在了解如何使用之前，作为开发者我们往往比较关心的一个问题是：这个 API 的兼容性如何？</p><p>在 <a href="https://caniuse.com/?search=IntersectionObserver%20%20">can i use</a> 上看到大部分的浏览器是支持的</p><p><img src="https://i.loli.net/2021/04/15/SJXa9fkoCY1q3AE.png" alt="image.png"></p><p>那有人就问了，如果老板就是要兼容 IE 呢 😂 </p><p>幸好 IntersectionObserver  提供了 <a href="https://github.com/w3c/IntersectionObserver/tree/main/polyfill">polyfill</a> ，我们只需要按照文档引入<code>polyfill</code> 就好了。简单瞄了一下 polyfill 源码应该就是回退到 getBoundingClientRect 方案。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>原先的代码是原生 js 写的，后来（惯例）又加了一些 AB 实验等需求，索性改成 vue 写反而更快了，页面结构大致如下所示。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;template&gt;  &lt;div&gt;    &lt;img class&#x3D;&quot;bg-img&quot; :src&#x3D;&quot;bg-img&quot; &#x2F;&gt;    &lt;img      v-for&#x3D;&quot;product in productList&quot;      :key&#x3D;&quot;product.id&quot;      :src&#x3D;&quot;product.src&quot;      class&#x3D;&quot;product-img&quot;    &#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre><p>第一步，我们需要创建一个 observer</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 声明当观察到元素进出视口时触发的回调函数const callback &#x3D; (changes) &#x3D;&gt; &#123;  changes.forEach(function(change) &#123;    &#x2F;&#x2F; el 即为我们观察的元素    const el &#x3D; change.target;      &#x2F;&#x2F; 上报曝光    console.log(&quot;exposure&quot;, change);      &#x2F;&#x2F; 取消观察    observer.unobserve(el);  &#125;);&#125;&#x2F;&#x2F; IntersectionObserver 可以接收两个参数，第二个参数 opt 可以定义容器（默认为视口）等配置,这里不展开讲，详细可看 mdn 文档const observer &#x3D; new IntersectionObserver(callback，opt || &#123;&#125;);</code></pre><p>第二步，我们需要在页面初始化的时候观察。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">mounted() &#123;[...document.querySelectorAll(&quot;.product-img&quot;)].forEach(item &#x3D;&gt; &#123;    observer.observe(item);  &#125;);&#125;</code></pre><p>大功告成？no.</p><h3 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h3><p>实际上如果这么写的话会有几个问题。</p><ol><li><p>首先就是我们一打开页面，就会发现触发所有的了上报曝光事件。这个问题就出在当我们 observe 的时候，就会触发一次回调，即使元素并没有进出视口。那么我们要做的就是判断元素是否在视口中即可，调整 callback</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 声明当观察到元素进出视口时触发的回调函数const callback &#x3D; (changes) &#x3D;&gt; &#123;  changes.forEach(function(change) &#123;    &#x2F;&#x2F; el 即为我们观察的元素    const el &#x3D; change.target;    if (change.intersectionRatio &gt; 0) &#123;    &#x2F;&#x2F; 上报曝光    console.log(&quot;exposure&quot;, change);    &#x2F;&#x2F; 取消观察    observer.unobserve(el);    &#125;  &#125;);&#125;&#x2F;&#x2F; IntersectionObserver 可以接收两个参数，第二个参数 opt 可以定义容器（默认为视口）等配置,这里不展开讲，详细可看 mdn 文档const observer &#x3D; new IntersectionObserver(callback，opt || &#123;&#125;);</code></pre><p>通过 change.intersectionRatio 可以知道元素在视口中交叉的比例是多少，如果大于 0 则证明元素是在视口中，此时才需要曝光。</p></li><li><p>经过上述的修改，我们打开页面再看，emmm… 还是一开始就把所有的元素曝光都上报了啊。让我们来看看曝光时 change 的一些属性</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#123;  &#x2F;&#x2F; ...其他一些属性  &#x2F;&#x2F; 交叉比例  intersectionRatio: 1  &#x2F;&#x2F; 目标元素的属性  boundingClientRect: &#123;    bottom: 0    height: 0    left: 0    right: 375    top: 0    width: 375    x: 0    y: 0  &#125;&#125;</code></pre><p>可以看到 intersectionRatio = 1 即说明元素确确实实在视口中了，而 boundingClientRect 中的 height 表示当时元素的高度还是 0，再一看 y 也是 0。瞬间想到：mounted 的时候，图片都还没加载好，那么此时页面还没有撑开，自然所有的产品卡片都是在视口中！也就是说我们 observe 的时机不正确。那么正确的时机应该是在页面 onload 之后，而非在组件的 mounted 事件中。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">mounted() &#123;window.addEventListener(&#39;load&#39;, function() &#123;    [...document.querySelectorAll(&quot;.product-img&quot;)].forEach(item &#x3D;&gt; &#123;    observer.observe(item);  &#125;);  &#125;)&#125;</code></pre><p>至此就可以正常上报曝光。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>总结，IntersectionObserver 有如下几个优点：</p><ol><li>提供的 Api 友好，使用起来简单</li><li>兼容性不错，并且提供了 polyfill</li><li>性能方面浏览器做了相关优化</li><li>适用性广泛，应用场景则包括上述的曝光埋点，图片懒加载，无限滚动等等</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inversify 初体验</title>
      <link href="/2021/04/01/inversify-%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2021/04/01/inversify-%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈 styled-components</title>
      <link href="/2021/03/30/%E8%B0%88%E8%B0%88%20styled-components/"/>
      <url>/2021/03/30/%E8%B0%88%E8%B0%88%20styled-components/</url>
      
        <content type="html"><![CDATA[<p>早在刚开始接触 React 的时候就有听闻过 <code>css in js</code> 的理念，中间也简单使用过 <code>styled-components</code>，但用到最后总因为各种原因放弃。这次刚好心血来潮又想重新试试，同时记录一下从个人角度来看 <code>styled-components</code> 的优缺点，以便将来选型时作为参考之用。</p><a id="more"></a><p>基于 create-react-app 搭建的 TypeScript 项目，至于如何加入 styled-components，这里不赘述，按照文档很简单就可以完成了。以下简称为 <code>sc</code>。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>简单使用方法如下:</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import styled from &#39;styled-components&#39;const Title &#x3D; styled.h1&#96;  font-size: 1.5em;&#96;;render(  &lt;Title&gt;    Hello World!  &lt;&#x2F;Title&gt;);</code></pre><p>最终编译出来的是一个独特的 hash 值的样式名，这可以避免我们样式名称被覆盖，而在此之前我们往往需要配置 css modules， 如果是 create react app 创建的项目，往往会用 .module.css 来表示 css 模块。而 sc 则自带了这个特性，我觉得这是他的第一个优点。</p><p>styled-components 可以传 props。</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import styled from &#39;styled-components&#39;const Title &#x3D; styled.h1&lt;&#123;isRed: boolean&#125;&gt;&#96;  font-size: 1.5em;color: $&#123;props &#x3D;&gt; props.isRed ? &#39;red&#39; : &#39;black&#39;&#125;&#96;;const isRed &#x3D; ...render(  &lt;Title isRed&#x3D;&#123;isRed&#125;&gt;    Hello World!  &lt;&#x2F;Title&gt;);</code></pre><p>而在使用 styled-components 之前，我们要做到这个效果往往是在 style 里处理，或者是通过样式名来控制</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&#x2F;&#x2F; 在 style 里处理，不方便复用render(  &lt;h1 style&#x3D;&#123;&#123; color: isRed ? &#39;red&#39; : &#39;black&#39; &#125;&#125;&gt;    Hello World!  &lt;&#x2F;h1&gt;);&#x2F;&#x2F; 通过样式名控制较为繁琐.red &#123; color: &#39;red&#39; &#125;.black &#123; color: &#39;black&#39; &#125;render(  &lt;h1 className&#x3D;&#123;isRed ? &#39;red&#39; : &#39;black&#39;&#125;&gt;    Hello World!  &lt;&#x2F;h1&gt;);</code></pre><p>这是 styled-components 的第二个优点。</p><p>有个场景比较经常出现在维护旧代码的时候，往往有的组件不需要了，我们可以简单移除掉，但是这个组件所使用的样式名却不敢轻易删掉，因为鬼知道这个样式是不是别的地方用到了。而这个则是 sc 中样式组件则不存在这个问题，所以这是第三个优点：便于维护。</p><p>以上是我觉得感知比较强烈的优点，当然还有一些别的优点这里就不说了，具体可以查看文档。</p><p>说完了优点，说说开发时遇到的缺点吧</p><p>第一个就是由于 sc 实际上就是组件，而这个往往会让我分不清哪些是样式组件，哪些是 React 组件，就是显得不够直观。</p><p>第二个是有一些组件，实际上只是一行样式就解决了，那么每次都需要重新写一个 sc 组件，反而显得繁琐。官方是推荐可以使用 <code>css prop</code>  来解决</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import &#123; css &#125; from &#39;styled-components&#x2F;macro&#39;render(  &lt;h1 css&#x3D;&#123;css&#96;font-size: 1.5em;&#96;&#125;&gt;    Hello World!  &lt;&#x2F;h1&gt;);</code></pre><p>这个功能需要有babel-plugin-styled-components 或者 babel-plugin-macro 的支持，create react app 默认支持了,详情看<a href="https://styled-components.com/docs/api#css-prop">文档</a>。</p><p>如果是 Typescript，由于原先的组件上并没有 css 这个属性，则需要额外在全局引入</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import &#123;&#125; from &#39;styled-components&#x2F;cssprop&#39;</code></pre><p>文档中提到 <code>css prop</code> 实际上也是将组件转为样式组件，而如果是在 typescript 中需要传递自定义 prop，我不知道该如何定义类型?</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import &#123; css &#125; from &#39;styled-components&#x2F;macro&#39;const Title &#x3D; css&#96;font-size: 1.5em;color: &#123;props &#x3D;&gt; props.color&#125;&#96;render(  &#x2F;&#x2F; 此时将提示 color 类型错误云云。。  &lt;h1 css&#x3D;&#123;Title&#125; color&#x3D;&quot;red&quot;&gt;    Hello World!  &lt;&#x2F;h1&gt;);</code></pre><p>第三个是样式复用，即如果我有相同的样式想要用在不同的组件上，sc 也是推荐使用 <code>css props</code>，而 css props 的体验是在是不敢说很好。</p><p>就我个人而言目前主要是这三点用着不爽。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>那么 <code>sc</code> 为什么可以通过 <code>styled</code>来给组件添加样式的呢？</p><p>es6 提供了 `` 作为模板字符串，我们通常的用法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const name &#x3D; &#96;$&#123;firstName&#125;$&#123;secondName&#125;&#96;</code></pre><p>而如果 ``是跟随在一个函数时，则该函数将被调用来处理这个模板字符串，这个称为标签模板</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log&#96;hi&#96;&#x2F;&#x2F; 等同于console.log(&#39;hi&#39;)</code></pre><p>关于这部分可以查阅 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates">MDN 相关文档</a></p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">styled.div&#96;color: red&#96;&#x2F;&#x2F; 等同于styled.div([&#39;\n  color: red;\n&#39;])</code></pre><p>在编译后的代码中可以看到一段如下代码，不难猜测出 <code>Object(i.a)</code> 就是 <code>styled.div</code></p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">var n &#x3D; Object(i.a)([&#39;\n  color: red;\n&#39;])</code></pre><p><code>styled.div</code>等同于 <code>styled(&#39;div&#39;)</code>，因而 <code>styled</code> 可以看作一个高阶组件</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const StyledComponent &#x3D; styled(Component)(styles)</code></pre><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>为了解决一两行代码也要用 <code>css prop</code> 的情况，我引入了 <code>tailwindcss</code>，这个 css 框架中的原子性类名理念非常契合我的问题。我觉得这两个框架搭配写起来还是比较顺畅的。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 react 中使用 rxjs</title>
      <link href="/2021/03/24/%E5%9C%A8-react-%E4%B8%AD%E4%BD%BF%E7%94%A8-rxjs/"/>
      <url>/2021/03/24/%E5%9C%A8-react-%E4%B8%AD%E4%BD%BF%E7%94%A8-rxjs/</url>
      
        <content type="html"><![CDATA[<p>最近出于学习目的在临摹一个在线 ppt 的开源项目。原项目使用的是 vue3，我则打算用 react 来实现，同时玩一些暂时不会在工作中使用到的技术，比如 rxjs。本文用于记录在 react 中加入 rxjs 的过程，本人也是在学习过程中，因此以下仅为个人理解，并不代表最佳实践。</p><a id="more"></a><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>每次点击”添加幻灯片”按钮，创建一张幻灯片，并创建一个历史快照，创建历史快照是一个 debounce 后的方法。即如果快速点击多次”添加幻灯片”， 也仅创建一个历史快照。</p><h4 id="React-通常写法"><a href="#React-通常写法" class="headerlink" title="React 通常写法"></a>React 通常写法</h4><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React from &#39;react&#39;import debounce from &#39;lodash&#x2F;debounce&#39;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  const createSnapshot &#x3D; debounce(() &#x3D;&gt; &#123;    console.log(&#39;create snapshot&#39;)  &#125;, 300)  const createSlide &#x3D; () &#x3D;&gt; &#123;    console.log(&#39;create slide&#39;)  &#125;  const handleClick &#x3D; () &#x3D;&gt; &#123;    createSlide()    createSnapshot()  &#125;  return (    &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;  )&#125;export default CreateSlideButton</code></pre><h4 id="改成-rxjs-实现"><a href="#改成-rxjs-实现" class="headerlink" title="改成 rxjs 实现"></a>改成 rxjs 实现</h4><p>在 rxjs 里，数据 / 事件 是一个流的概念。比如我们点击按钮，每点击一次，那么这个事件流就多了一个点击事件。</p><p>我们需要做的就是在组件创建这么个事件流并且订阅，每当事件流有新的事件，那么就会执行我们的回调函数，当然别忘了在组件卸载的时候，需要取消订阅。</p><p>具体来说，通常我们会以 <code>$</code> 结尾来表示这是一个流，订阅这个流实际上就是执行流的 subscribe 方法，subscribe 接收的第一个参数就是当事件流有新事件时执行的回调。而卸载则是指流的 unsubscribe 方法。</p><p>那么如何创建一个流呢？rxjs 提供了很多操作符，通常我们可以通过 <code>fromEvent</code>创建一个事件流</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; fromEvent &#125; from &#39;rxjs&#39;;const clickEvt$ &#x3D; fromEvent(document, &#39;click&#39;);</code></pre><p>但是 react 有自己的合成事件机制，显然上面的写法不太合适。我们需要自己来创建一个流，这个流可以接收 react 事件，同时这个流可以被订阅。我们称这样的流为 Subject。那么现在创建一个流可以这么写</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  const clickEvt$ &#x3D; new Subject();  const handleClick &#x3D; () &#x3D;&gt; &#123;    clickEvt$.next();  &#125;;  return &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;;&#125;;export default CreateSlideButton;</code></pre><p>上述代码通过 <code>const clickEvt$ = new Subject();</code> 创建了一个点击事件流，并且在每次 <code>onClick</code> 的时候，<code>clickEvt$.next();</code>给事件流推送一个事件。</p><p>但是这个写法明显有个问题，每次组件更新的时候都将创建一个新的 <code>clickEvt$</code>，这里我们用<code>useMemo</code>包起来</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useMemo &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  const clickEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  const handleClick &#x3D; () &#x3D;&gt; &#123;    clickEvt$.next();  &#125;;  return &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;;&#125;;export default CreateSlideButton;</code></pre><p>接着我们需要在组件初始化时订阅这个事件流，并且在组件卸载时取消订阅这个事件流。</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useMemo &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  const clickEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  useEffect(() &#x3D;&gt; &#123;    clickEvt$.subscribe(() &#x3D;&gt; &#123;      console.log(&quot;click&quot;);    &#125;);    return () &#x3D;&gt; clickEvt$.unsubscribe();  &#125;, [clickEvt$]);  const handleClick &#x3D; () &#x3D;&gt; &#123;    clickEvt$.next();  &#125;;  return &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;;&#125;;export default CreateSlideButton;</code></pre><p>至此我们点击按钮后，将打印 “click”。</p><p>那么如何实现创建 幻灯片和历史快照自然就不言而喻了</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useMemo &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;import debounce from &quot;lodash&#x2F;debounce&quot;;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  &#x2F;&#x2F; 创建点击事件流  const clickEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  const [createSnapshot, createSlide] &#x3D; useMemo(    () &#x3D;&gt; [      debounce(() &#x3D;&gt; &#123;        console.log(&quot;create snapshot&quot;);      &#125;, 300),      () &#x3D;&gt; &#123;        console.log(&quot;create slide&quot;);      &#125;    ],    []  );  useEffect(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 订阅    clickEvt$.subscribe(() &#x3D;&gt; &#123;      createSlide();      createSnapshot();    &#125;);    &#x2F;&#x2F; 取消订阅    return () &#x3D;&gt; clickEvt$.unsubscribe();  &#125;, [clickEvt$, createSnapshot, createSlide]);  const handleClick &#x3D; () &#x3D;&gt; &#123;    &#x2F;&#x2F; 推送点击事件    clickEvt$.next();  &#125;;  return &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;;&#125;;export default CreateSlideButton;</code></pre><p>还有可以改造的地方么？</p><p>既然我们接受了 frp 的编程思想，是否可以这么思考，我们每次点击，就产生了点击事件流，而点击事件的回调中，我们又派发了创建历史快照这个事件？那么创建历史快照这个事件应该也有自己的流！</p><p>从这个角度我们用同样的方法改造一下代码</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useMemo &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;import debounce from &quot;lodash&#x2F;debounce&quot;;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  const clickEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  &#x2F;&#x2F; 初始化 创建快照事件流  const createSnapshotEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  const [createSnapshot, createSlide] &#x3D; useMemo(    () &#x3D;&gt; [      debounce(() &#x3D;&gt; &#123;        console.log(&quot;create snapshot&quot;);      &#125;, 300),      () &#x3D;&gt; &#123;        console.log(&quot;create slide&quot;);      &#125;    ],    []  );  useEffect(() &#x3D;&gt; &#123;    createSnapshotEvt$.subscribe(() &#x3D;&gt; &#123;      createSnapshot();    &#125;);    return () &#x3D;&gt; createSnapshotEvt$.unsubcribe()  &#125;, [createSnapshotEvt$, createSnapshot]);  useEffect(() &#x3D;&gt; &#123;    clickEvt$.subscribe(() &#x3D;&gt; &#123;      createSlide();      &#x2F;&#x2F; 推送创建快照事件      createSnapshotEvt$.next();    &#125;);    return () &#x3D;&gt; clickEvt$.unsubscribe();  &#125;, [clickEvt$, createSnapshotEvt$, createSlide]);  const handleClick &#x3D; () &#x3D;&gt; &#123;    clickEvt$.next();  &#125;;  return &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;;&#125;;export default CreateSlideButton;</code></pre><p>实际上 createSlide 也可以单独创建事件流，这里不赘述。那么上面写法有什么好处呢？</p><p>好处就是 rxjs 提供了大量的操作符，其中就包括了 <code>debounceTime</code>。因此我们可以这么写</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useMemo &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;import &#123; debounceTime &#125; from &quot;rxjs&#x2F;operators&quot;;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  const clickEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  const createSnapshotEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  const [createSnapshot, createSlide] &#x3D; useMemo(    () &#x3D;&gt; [      () &#x3D;&gt; &#123;        console.log(&quot;create snapshot&quot;);      &#125;,      () &#x3D;&gt; &#123;        console.log(&quot;create slide&quot;);      &#125;    ],    []  );  useEffect(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 通过 .pipe 对事件流进行 debounce 操作    createSnapshotEvt$.pipe(debounceTime(300)).subscribe(() &#x3D;&gt; &#123;      createSnapshot();    &#125;);    return () &#x3D;&gt; createSnapshotEvt$.unsubcribe();  &#125;, [createSnapshotEvt$, createSnapshot]);  useEffect(() &#x3D;&gt; &#123;    clickEvt$.subscribe(() &#x3D;&gt; &#123;      createSlide();      createSnapshotEvt$.next();    &#125;);    return () &#x3D;&gt; clickEvt$.unsubscribe();  &#125;, [clickEvt$, createSnapshotEvt$, createSlide]);  const handleClick &#x3D; () &#x3D;&gt; &#123;    clickEvt$.next();  &#125;;  return &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;;&#125;;export default CreateSlideButton;</code></pre><p>可以看到我们不再需要 lodash 的 debounce 对 createSnapshot 进行操作，而是对事件流进行 debounce 操作。</p><h4 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h4><p>上面举出的例子里 <code>observable</code> 的 <code>observer</code> 很简单，就直接 console.log 就完事儿了。然而在实际的开发场景中，确并非如此简单。上面的代码太长了，因此重新举一个例子</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useState &#125; from &#39;react&#39;import &#123; of &#125; from &#39;rxjs&#39;export default function App() &#123;  const [count, setCount] &#x3D; useState(0)  const sum &#x3D; (val) &#x3D;&gt; setCount(count + val)  useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; of(1, 2, 3).subscribe(sum)    return () &#x3D;&gt; subscription.unsubscribe()  &#125;, [])  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;&#125;</code></pre><p>上面这个例子，我的本意是希望订阅一个 <code>of</code>  流，并且将产出的值相加后展示出来，也就是说我预期是能打印出 <code>0 + 1 + 2 + 3 = 6</code>。但一旦如果按上面的写法，输出将会是 <code>3</code>。如果有开启 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>，eslint 会提示 <code>React Hook useEffect has a missing dependency: &#39;sum&#39;. Either include it or remove the dependency array</code>。实际上就是因为我们没有正确去配置 <code>useEffect</code> 的依赖，导致 <code>sum</code> 中获取到的 <code>count</code> 一直是 0，因此最终输出为 3。那我们稍加改进</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useState, useCallback &#125; from &#39;react&#39;import &#123; of &#125; from &#39;rxjs&#39;export default function App() &#123;  const [count, setCount] &#x3D; useState(0)  const sum &#x3D; useCallback((val) &#x3D;&gt; setCount(count + val), [count])  useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; of(1, 2, 3).subscribe(sum)    return () &#x3D;&gt; subscription.unsubscribe()  &#125;, [sum])  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;&#125;</code></pre><p>这次我们给 useEffect 添加了 <code>sum</code> 作为依赖，并且给 <code>sum</code> 包裹了 <code>useCallback</code>。这个时候，打开页面发现，页面上的数字不断增加。原因是我们每次 <code>setCount</code> 之后，<code>count</code> 更新导致 <code>sum</code> 更新，同时也导致不断执行 <code>useEffect</code> 中的方法，即不断的 <code>subscribe</code>  与 <code>unsubscribe</code>。</p><p>react 为 setState 提供了一种函数回调的方式，即可以通过 <code>setCount(count =&gt; count + val)</code>这样的形式来获取旧值，那么代码可以改成</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useState, useCallback &#125; from &#39;react&#39;import &#123; of &#125; from &#39;rxjs&#39;export default function App() &#123;  const [count, setCount] &#x3D; useState(0)const sum &#x3D; useCallback((val) &#x3D;&gt; setCount((count) &#x3D;&gt; count + val), [])  useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; of(1, 2, 3).subscribe(sum)    return () &#x3D;&gt; subscription.unsubscribe()  &#125;, [sum])  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;&#125;</code></pre><p>这一次页面显示了预期的 <code>6</code>。</p><p>经过上面的改写，我们获取到了预期的结果，之后我一度考虑是否能通过将 sum 保存到 ref 中，从而将 sum 从 依赖项中移除呢？</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useState, useCallback, useRef &#125; from &#39;react&#39;import &#123; of &#125; from &#39;rxjs&#39;export default function App() &#123;  const [count, setCount] &#x3D; useState(0)  const sum &#x3D; useCallback((val) &#x3D;&gt; setCount((count) &#x3D;&gt; count + val), [])  const latestSum &#x3D; useRef(sum)  useEffect(() &#x3D;&gt; &#123;    latestSum.current &#x3D; sum  &#125;)  useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; of(1, 2, 3).subscribe(latestSum.current)    return () &#x3D;&gt; subscription.unsubscribe()  &#125;, [])  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;&#125;</code></pre><p>很遗憾，上面的写法是能输出预期结果，然而实际上这么写却并非正确。因为上述的例子只是恰好 sum 不会变更，从而只需要 subscribe 一次。假设 sum 会变更，那么 subscribe 订阅的将一直是初始化时的 sum，而非最新的 sum。将上述代码改成</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useState, useCallback, useRef &#125; from &#39;react&#39;import &#123; of &#125; from &#39;rxjs&#39;export default function App() &#123;  const [count, setCount] &#x3D; useState(0)  const sum &#x3D; useCallback((val) &#x3D;&gt; setCount(count + val), [count])  const latestSum &#x3D; useRef(sum)  useEffect(() &#x3D;&gt; &#123;    latestSum.current &#x3D; sum  &#125;)  useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; of(1, 2, 3).subscribe(latestSum.current)    return () &#x3D;&gt; subscription.unsubscribe()  &#125;, [])  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;&#125;</code></pre><p>页面将会输出 3，即 latestSum.current 中的 count 一直是 0。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看到对于原代码而言，rxjs 的实现反而多了很多代码，不过上面的例子只是给到一个启发与入门的作用，让我们从函数响应式编程的角度去思考如何组织代码，而往往在更复杂的场景才能真正展示 rxjs 的威力，是否要使用 rxjs 需要根据具体的场景来考量。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 中的 unknown 类型</title>
      <link href="/2021/03/20/TypeScript-%E4%B8%AD%E7%9A%84-unknown-%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/03/20/TypeScript-%E4%B8%AD%E7%9A%84-unknown-%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>早在 TypeScript 3.0 中就新增加了一种 unkown 类型 <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type">New <code>unknown</code> top type</a>，然而目前中文文档似乎还没有相关的说明，而<a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown">英文文档</a>中也仅有简短的一点说明。那么 unknown 的应用场景是什么，为什么需要新增这个类型呢？以下为结合官方 wiki，就比较常见的应用场景做的个人笔记总结。</p><a id="more"></a><p>如果将类型看作一个集合的话，那么顶部类型则包含了所有其他类型，而底部类型则不包含其他所有类型。在 typescript 中，底部类型则是 never。而 unknown  类型与 any 非常相似，都是顶部类型。</p><p>我们知道如果使用了 any，那就几乎意味着放弃了类型保护，我们可以使用 any 做任何事情，而 unknown 却恰恰相反，我们几乎无法利用 unknown 来做任何事情。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f1(a: any) &#123;  a.b(); &#x2F;&#x2F; OK&#125;function f2(a: unknown) &#123;  a.b();  &#x2F;&#x2F; error: Object is of type &#39;unknown&#39;.&#125;</code></pre><p>要使用 unknown 前须通过类型断言等方式确定类型，因此在面对未知类型时，使用 unknown 比 any 更加安全。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">declare interface A &#123;  b: Function;&#125;declare function isA(x: unknown): x is A;function func(x: unknown) &#123;  &#x2F;&#x2F; 类型断言  (x as number).toFixed(2);    &#x2F;&#x2F; 相等  if(x &#x3D;&#x3D;&#x3D; 123) &#123;    x; &#x2F;&#x2F; 123  &#125;    &#x2F;&#x2F; 类型防护  if (typeof x &#x3D;&#x3D;&#x3D; &#39;string&#39; || typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;    x; &#x2F;&#x2F; string | number  &#125;  if (x instanceof Error) &#123;    x; &#x2F;&#x2F; Error  &#125;    &#x2F;&#x2F; 断言函数  if (isA(x)) &#123;    x.b();  &#125;&#125;</code></pre><p>那么 unknown 与 any 具体还有哪些区别呢？</p><ol><li><p>作为顶部类型，则意味着所有的类型都可以赋值给 unknown，然而 unknown 只能赋值给 any 或者 unknown。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Anything is assignable to unknownfunction f21&lt;T&gt;(pAny: any, pNever: never, pT: T) &#123;  let x: unknown;  x &#x3D; 123;  x &#x3D; &quot;hello&quot;;  x &#x3D; [1, 2, 3];  x &#x3D; new Error();  x &#x3D; x;  x &#x3D; pAny;  x &#x3D; pNever;  x &#x3D; pT;&#125;&#x2F;&#x2F; unknown assignable only to itself and anyfunction f22(x: unknown) &#123;  let v1: any &#x3D; x;  let v2: unknown &#x3D; x;  let v3: object &#x3D; x; &#x2F;&#x2F; Error  let v4: string &#x3D; x; &#x2F;&#x2F; Error  let v5: string[] &#x3D; x; &#x2F;&#x2F; Error  let v6: &#123;&#125; &#x3D; x; &#x2F;&#x2F; Error  let v7: &#123;&#125; | null | undefined &#x3D; x; &#x2F;&#x2F; Error&#125;</code></pre></li><li><p>在联合类型中，any 交叉(&amp;)或者联合(|)任何类型, 除了 never 外都为 any，而 unknown 交叉(&amp;)任何类型都为其所交叉类型，联合(|)任何类型(除了 any 外)都为 unknown</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type T00 &#x3D; unknown &amp; null; &#x2F;&#x2F; nulltype T03 &#x3D; unknown &amp; string; &#x2F;&#x2F; stringtype T06 &#x3D; unknown &amp; any; &#x2F;&#x2F; anytype T00 &#x3D; any &amp; null; &#x2F;&#x2F; anytype T02 &#x3D; any &amp; null &amp; undefined; &#x2F;&#x2F; null &amp; undefined (which becomes never)type T03 &#x3D; any &amp; string; &#x2F;&#x2F; any</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type T10 &#x3D; unknown | null; &#x2F;&#x2F; unknowntype T13 &#x3D; unknown | string; &#x2F;&#x2F; unknowntype T16 &#x3D; unknown | any; &#x2F;&#x2F; anytype T10 &#x3D; any | null; &#x2F;&#x2F; anytype T12 &#x3D; any | null | undefined; &#x2F;&#x2F; anytype T13 &#x3D; any | string; &#x2F;&#x2F; any</code></pre></li><li><p>在之前泛型类型默认为 <code>&#123;&#125;</code>, 现在则默认为 unknown。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function foo&lt;T&gt;(x: T): [T, string] &#123;    return [x, x.toString()]    &#x2F;&#x2F;           ~~~~~~~~ TypeScript 3.5 之后将会报错：error! Property &#39;toString&#39; does not exist on type &#39;T&#39;.&#125;</code></pre><p>如果要不报错，可以这么写</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function foo&lt;T extends &#123;&#125;&gt;(x: T): [T, string] &#123;    return [x, x.toString()]&#125;</code></pre></li><li><p>function 如果返回的是 unknown ，则可以没有返回语句</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f27(): unknown &#123;&#125;</code></pre></li></ol><p>简单来说，unknown 主要的场景就是，当我们需要一个值，这个值可以是任何类型，但是在使用这个值前，需要先判断类型以确保类型安全。换句话说，在使用 any 前，可以先试试 unknown。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-OOP.md</title>
      <link href="/2021/02/19/JavaScript-OOP/"/>
      <url>/2021/02/19/JavaScript-OOP/</url>
      
        <content type="html"><![CDATA[<p>在平时的 CodeReview 中要如何去分辨代码的好坏呢？最近看到 <a href="https://github.com/ryanmcdermott/clean-code-javascript">https://github.com/ryanmcdermott/clean-code-javascript</a> 这个仓库的总结，感觉蛮有参考价值的。特别是关于类这一章，涉及很多设计模式的思想。刚好相关的中文仓库似乎缺失了类这章节的翻译，以下为类以及 SOLID 这个章节的翻译并添加个人理解。</p><a id="more"></a><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="最好使用-ES2015-ES6-classes-而非-ES5-的函数"><a href="#最好使用-ES2015-ES6-classes-而非-ES5-的函数" class="headerlink" title="最好使用  ES2015/ES6 classes 而非 ES5 的函数"></a>最好使用  ES2015/ES6 classes 而非 ES5 的函数</h3><p>传统的 ES5 类的继承，构造，以及内部方法可读性非常差，在需要继承（当然你也可以无需继承）的场景下，推荐使用  ES2015/ES6 classes。如果你需要一个大型且极度复杂的对象，那么可以使用 function 替代 class。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const Animal &#x3D; function(age) &#123;  if (!(this instanceof Animal)) &#123;    throw new Error(&quot;Instantiate Animal with &#96;new&#96;&quot;);  &#125;  this.age &#x3D; age;&#125;;Animal.prototype.move &#x3D; function move() &#123;&#125;;const Mammal &#x3D; function(age, furColor) &#123;  if (!(this instanceof Mammal)) &#123;    throw new Error(&quot;Instantiate Mammal with &#96;new&#96;&quot;);  &#125;&#x2F;&#x2F; 调用父类的构造函数，初始化当前子类的 this 的 age 属性  Animal.call(this, age);  &#x2F;&#x2F; 初始化子类的 this 的 furColor 属性  this.furColor &#x3D; furColor;&#125;;&#x2F;&#x2F; 将子类的 prototype 修改为父类的 prototypeMammal.prototype &#x3D; Object.create(Animal.prototype);&#x2F;&#x2F; 修改子类的 prototype.constructor 的指向Mammal.prototype.constructor &#x3D; Mammal;&#x2F;&#x2F; 给子类的 prototype 添加额外的函数Mammal.prototype.liveBirth &#x3D; function liveBirth() &#123;&#125;;const Human &#x3D; function(age, furColor, languageSpoken) &#123;  if (!(this instanceof Human)) &#123;    throw new Error(&quot;Instantiate Human with &#96;new&#96;&quot;);  &#125;  Mammal.call(this, age, furColor);  this.languageSpoken &#x3D; languageSpoken;&#125;;Human.prototype &#x3D; Object.create(Mammal.prototype);Human.prototype.constructor &#x3D; Human;Human.prototype.speak &#x3D; function speak() &#123;&#125;;</code></pre><p>上述的继承实际上就是最常见的组合寄生式继承：</p><ol><li>在子类中调用父类的构造函数用于继承属性</li><li>设置子类自己的属性</li><li>将子类的 prototype 修改为父类的 prototype 用于继承父类的方法</li><li>修改 子类的 prototype.constructor 的指向为子类</li><li>添加子类自己的方法 </li></ol><p>可以看到这个过程极为繁琐。</p><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Animal &#123;  constructor(age) &#123;    this.age &#x3D; age;  &#125;  move() &#123;    &#x2F;* ... *&#x2F;  &#125;&#125;class Mammal extends Animal &#123;  constructor(age, furColor) &#123;    &#x2F;&#x2F; 执行父类的构造函数，继承父类属性值以及方法    super(age);    this.furColor &#x3D; furColor;  &#125;  liveBirth() &#123;    &#x2F;* ... *&#x2F;  &#125;&#125;class Human extends Mammal &#123;  constructor(age, furColor, languageSpoken) &#123;    super(age, furColor);    this.languageSpoken &#x3D; languageSpoken;  &#125;  speak() &#123;    &#x2F;* ... *&#x2F;  &#125;&#125;</code></pre><p>可以看到使用 class 则简单的多，只需要 extends 关键字，并且在子类中的 constructor 的 super 来实现继承。</p><p>这里有个注意点是：子类如果写了 constructor， 而不写 super 或是在调用 this 后再调用 super，则会报错，这是因为 constructor 不写则默认为父类的 constructor，如果写了 constructor，但是没有调用 super，则无法生成 this，这点与 ES5 也是有区别的。即 ES5 子类继承前就有 this 了，而 ES6 的 class 子类则是 super 之后才有的 this。</p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>这种模式在 JavaScript 中非常有用，在诸如 JQuery, Lodash 之类的仓库中，非常常见。这种模式可以让你的代码看起来简洁明了。基于上述原因，我可以直言，使用链式调用然后看看你的代码将是如此优雅。在方法中，返回 this，就可以实现。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Car &#123;  constructor(make, model, color) &#123;    this.make &#x3D; make;    this.model &#x3D; model;    this.color &#x3D; color;  &#125;  setMake(make) &#123;    this.make &#x3D; make;  &#125;  setModel(model) &#123;    this.model &#x3D; model;  &#125;  setColor(color) &#123;    this.color &#x3D; color;  &#125;  save() &#123;    console.log(this.make, this.model, this.color);  &#125;&#125;const car &#x3D; new Car(&quot;Ford&quot;, &quot;F-150&quot;, &quot;red&quot;);car.setColor(&quot;pink&quot;);car.save();</code></pre><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Car &#123;  constructor(make, model, color) &#123;    this.make &#x3D; make;    this.model &#x3D; model;    this.color &#x3D; color;  &#125;  setMake(make) &#123;    this.make &#x3D; make;    &#x2F;&#x2F; NOTE: 返回 this    return this;  &#125;  setModel(model) &#123;    this.model &#x3D; model;    &#x2F;&#x2F; NOTE: 返回 this    return this;  &#125;  setColor(color) &#123;    this.color &#x3D; color;     &#x2F;&#x2F; NOTE: 返回 this    return this;  &#125;  save() &#123;    console.log(this.make, this.model, this.color);     &#x2F;&#x2F; NOTE: 返回 this    return this;  &#125;&#125;const car &#x3D; new Car(&quot;Ford&quot;, &quot;F-150&quot;, &quot;red&quot;).setColor(&quot;pink&quot;).save();</code></pre><h3 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h3><p>据在四人帮的设计模式，我们应该尽可能使用组合而非继承。有很多理由使用继承，同时也有很多理由使用组合。这里最重要的一点是，如果直觉告诉你要使用继承，那么可以试试看使用组合是否能更好地解决问题？</p><p>那你可能会想，什么时候用继承会比较好？这需要视情况而定，但下面罗列了一些继承优于组合的场景：</p><ol><li>你的继承代表 “is-a” 而非 “has-a”（人 是一种 动物 vs 用户 有 用户详情）</li><li>你需要重用基类的代码（人可以像所有动物一样移动）</li><li>你希望修改基类的代码以全局变更所有子类的行为（所有动物移动时都需要消耗热量）</li></ol><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Employee &#123;  constructor(name, email) &#123;    this.name &#x3D; name;    this.email &#x3D; email;  &#125;  &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; 反例：因为员工 有 税收，而不是说 税收是一种 员工class EmployeeTaxData extends Employee &#123;  constructor(ssn, salary) &#123;    super();    this.ssn &#x3D; ssn;    this.salary &#x3D; salary;  &#125;  &#x2F;&#x2F; ...&#125;</code></pre><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class EmployeeTaxData &#123;  constructor(ssn, salary) &#123;    this.ssn &#x3D; ssn;    this.salary &#x3D; salary;  &#125;  &#x2F;&#x2F; ...&#125;class Employee &#123;  constructor(name, email) &#123;    this.name &#x3D; name;    this.email &#x3D; email;  &#125;  setTaxData(ssn, salary) &#123;    this.taxData &#x3D; new EmployeeTaxData(ssn, salary);  &#125;  &#x2F;&#x2F; ...&#125;</code></pre><p>实际上 React 的设计哲学也是提倡组合优于继承,详情可以参考 <a href="https://reactjs.org/docs/composition-vs-inheritance.html#gatsby-focus-wrapper">Composition vs Inheritance</a></p><h2 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h2><p>SOLID 是设计模式需要遵循的几个原则简称：</p><ol><li>单一职责（Single Responsibility Principle, SRP）</li><li>开闭原则（Open/Closed Principle, OCP）</li><li>里氏替换（Liskov Substitution Principle，LSP）</li><li>接口隔离（Interface Segregation Principle，ISP）</li><li>依赖倒置（Dependency Inversion Principle，DIP）</li></ol><p>###单一职责</p><p>如代码整洁之道所说，修改一个类的理由不应该超过一个 。如同一个航班只能带一个行李箱，因此我们将所有行李都塞入这个箱子，我们总是倾向于在一个类里实现许多功能。然而这么做的问题在于你的类无法做到概念上的内聚，并且经常不得不进行修改。最小化一个类的修改次数是非常重要的，这是因为如果一个类充斥过多的功能，当我们对其中一部分修改时，无法预测到这个修改会对依赖这个类的其他模块带来什么影响。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class UserSettings &#123;  constructor(user) &#123;    this.user &#x3D; user;  &#125;  changeSettings(settings) &#123;    if (this.verifyCredentials()) &#123;      &#x2F;&#x2F; ...    &#125;  &#125;  verifyCredentials() &#123;    &#x2F;&#x2F; ...  &#125;&#125;</code></pre><p>UserSettings 类负责修改设置，同时还负责了鉴权，而鉴权应该要从 UserSettings 分离出来。</p><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class UserAuth &#123;  constructor(user) &#123;    this.user &#x3D; user;  &#125;  verifyCredentials() &#123;    &#x2F;&#x2F; ...  &#125;&#125;class UserSettings &#123;  constructor(user) &#123;    this.user &#x3D; user;    this.auth &#x3D; new UserAuth(user);  &#125;  changeSettings(settings) &#123;    if (this.auth.verifyCredentials()) &#123;      &#x2F;&#x2F; ...    &#125;  &#125;&#125;</code></pre><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>“代码实体（类，模块，方法等）应该对拓展开放，对修改闭合”。</p><p>简单来说就是：以增代改。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class AjaxAdapter extends Adapter &#123;  constructor() &#123;    super();    this.name &#x3D; &quot;ajaxAdapter&quot;;  &#125;&#125;class NodeAdapter extends Adapter &#123;  constructor() &#123;    super();    this.name &#x3D; &quot;nodeAdapter&quot;;  &#125;&#125;class HttpRequester &#123;  constructor(adapter) &#123;    this.adapter &#x3D; adapter;  &#125;  fetch(url) &#123;    if (this.adapter.name &#x3D;&#x3D;&#x3D; &quot;ajaxAdapter&quot;) &#123;      return makeAjaxCall(url).then(response &#x3D;&gt; &#123;        &#x2F;&#x2F; transform response and return      &#125;);    &#125; else if (this.adapter.name &#x3D;&#x3D;&#x3D; &quot;nodeAdapter&quot;) &#123;      return makeHttpCall(url).then(response &#x3D;&gt; &#123;        &#x2F;&#x2F; transform response and return      &#125;);    &#125;  &#125;&#125;function makeAjaxCall(url) &#123;  &#x2F;&#x2F; request and return promise&#125;function makeHttpCall(url) &#123;  &#x2F;&#x2F; request and return promise&#125;</code></pre><p>假设将来我们需要添加一个 customAdapter, 那么我们需要：</p><ol><li>添加一个 CustomAdapter 类</li><li>在 HttpRequester 中添加一个 makCustomCall 方法</li><li>修改 fetch 方法，判断 adpater.name</li></ol><p>但是实际上我们只不过是想添加一个自定义的请求方法，却要对 HttpRequester 进行修改。实际上 HttpRequester 应该不关心具体 request 过程。修改如下：</p><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class AjaxAdapter extends Adapter &#123;  constructor() &#123;    super();    this.name &#x3D; &quot;ajaxAdapter&quot;;  &#125;  request(url) &#123;    &#x2F;&#x2F; request and return promise  &#125;&#125;class NodeAdapter extends Adapter &#123;  constructor() &#123;    super();    this.name &#x3D; &quot;nodeAdapter&quot;;  &#125;  request(url) &#123;    &#x2F;&#x2F; request and return promise  &#125;&#125;class HttpRequester &#123;  constructor(adapter) &#123;    this.adapter &#x3D; adapter;  &#125;  fetch(url) &#123;    return this.adapter.request(url).then(response &#x3D;&gt; &#123;      &#x2F;&#x2F; transform response and return    &#125;);  &#125;&#125;</code></pre><p>经过这样调整，不管拓展多少个新 Adapter 都不需要对 HttpRequester 进行修改。</p><h3 id="里氏替换"><a href="#里氏替换" class="headerlink" title="里氏替换"></a>里氏替换</h3><p>“子类对象应该可以直接替换其超类对象被使用”</p><p>对于这个原则有一个比较好的解释是：如果你有一个父类和一个子类，那么用子类任意替换掉父类而不会出错。下面是一个经典的例子，数学上来说，正方形是一种长方形，但是如果你真的使用 “is-a” 来构造的话，很快你就会发现问题所在。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Rectangle &#123;  constructor() &#123;    this.width &#x3D; 0;    this.height &#x3D; 0;  &#125;  setColor(color) &#123;    &#x2F;&#x2F; ...  &#125;  render(area) &#123;    &#x2F;&#x2F; ...  &#125;  setWidth(width) &#123;    this.width &#x3D; width;  &#125;  setHeight(height) &#123;    this.height &#x3D; height;  &#125;  getArea() &#123;    return this.width * this.height;  &#125;&#125;class Square extends Rectangle &#123;  setWidth(width) &#123;    this.width &#x3D; width;    this.height &#x3D; width;  &#125;  setHeight(height) &#123;    this.width &#x3D; height;    this.height &#x3D; height;  &#125;&#125;function renderLargeRectangles(rectangles) &#123;  rectangles.forEach(rectangle &#x3D;&gt; &#123;    rectangle.setWidth(4);    rectangle.setHeight(5);    &#x2F;&#x2F; 这里，如果我们传入的是一个 square，那么计算结果将会是 25，与预期的 20 不符    const area &#x3D; rectangle.getArea();    rectangle.render(area);  &#125;);&#125;const rectangles &#x3D; [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles(rectangles);</code></pre><p>可以看到在设置宽高以及面积时，实际上正方形与长方形的行为时不一致的，那么这里 正方形不应该从 长方形继承。我们可以抽象出一个更高的层级 Shape，长方形与正方形相同的方法可以放在 Shape 基类中，而不同点则各自实现。</p><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Shape &#123;  setColor(color) &#123;    &#x2F;&#x2F; ...  &#125;  render(area) &#123;    &#x2F;&#x2F; ...  &#125;&#125;class Rectangle extends Shape &#123;  constructor(width, height) &#123;    super();    this.width &#x3D; width;    this.height &#x3D; height;  &#125;  getArea() &#123;    return this.width * this.height;  &#125;&#125;class Square extends Shape &#123;  constructor(length) &#123;    super();    this.length &#x3D; length;  &#125;  getArea() &#123;    return this.length * this.length;  &#125;&#125;function renderLargeShapes(shapes) &#123;  shapes.forEach(shape &#x3D;&gt; &#123;    const area &#x3D; shape.getArea();    shape.render(area);  &#125;);&#125;const shapes &#x3D; [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];renderLargeShapes(shapes);</code></pre><h3 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h3><p>JavaScript 没有接口这个概念，因此这一条不像其他语言一样会被严格执行（不过 TypeScript 可以参考一下）。但即便如此，即使是 JavaScript 这样缺少类型系统的语言中，这条原则也是极为重要的。</p><p>接口隔离指的是：客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。</p><p>一个比较好的例子是：一个包含很多设置项的 class。客户端无需设置大量的可选项，因为大部分情况是无需设置所有的选项，将这些选项设为可选就可以避免 “胖接口”。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class DOMTraverser &#123;  constructor(settings) &#123;    this.settings &#x3D; settings;    this.setup();  &#125;  setup() &#123;    this.rootNode &#x3D; this.settings.rootNode;    this.settings.animationModule.setup();  &#125;  traverse() &#123;    &#x2F;&#x2F; ...  &#125;&#125;const $ &#x3D; new DOMTraverser(&#123;  rootNode: document.getElementsByTagName(&quot;body&quot;),  animationModule() &#123;&#125; &#x2F;&#x2F; 多数时候我们并不需要 animationModule  &#x2F;&#x2F; ...&#125;);</code></pre><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class DOMTraverser &#123;  constructor(settings) &#123;    this.settings &#x3D; settings;    this.options &#x3D; settings.options;    this.setup();  &#125;  setup() &#123;    this.rootNode &#x3D; this.settings.rootNode;    this.setupOptions();  &#125;  setupOptions() &#123;    if (this.options.animationModule) &#123;      &#x2F;&#x2F; ...    &#125;  &#125;  traverse() &#123;    &#x2F;&#x2F; ...  &#125;&#125;const $ &#x3D; new DOMTraverser(&#123;  rootNode: document.getElementsByTagName(&quot;body&quot;),  options: &#123;    animationModule() &#123;&#125;  &#125;&#125;);</code></pre><h3 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h3><p>这个原则有两个核心点：</p><ol><li>高层模块不应该依赖低层模块的实现，他们都应该依赖于抽象接口。</li><li>抽象接口不应该依赖具体实现，具体实现应该依赖抽象接口。</li></ol><p>简单来说即高层模块负责定义接口，而低层模块负责实现接口。</p><p>依赖倒置经常会与控制反转（IoC）联系在一起，IoC 是实现 DIP 的一种方式，而要实现 IoC 一种常见的方法是  Dependency Injection (DI，依赖注入) 。</p><p>这两者实际上不是一个概念，DIP 指的是高层模块不应该知道低层模块的具体实现。而依赖注入则是将低层模块的实现提供给高层模块的具体方法。</p><p>这种做法最大的好处是可以减少模块之间的耦合度。</p><p>如刚刚说的，JavaScript 没有接口的概念，因此抽象接口的依赖是隐式的，即对象向外部暴露的方法和属性。下面例子中将 InventoryTracker  视为高层模块，InventoryRequester  为低层模块，接口指的是 InventoryTracker 模块依赖到 InventoryRequester 模块暴露的 requestItem，即隐式要求所有的 InventoryRequester 都应该有 requestItem 方法。那么具体实现其实就是说不应该在 InventoryTracker  去实例化一个 InventoryRequester，而应该通过构造函数注入进来。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class InventoryRequester &#123;  constructor() &#123;    this.REQ_METHODS &#x3D; [&quot;HTTP&quot;];  &#125;  requestItem(item) &#123;    &#x2F;&#x2F; ...  &#125;&#125;class InventoryTracker &#123;  constructor(items) &#123;    this.items &#x3D; items;   &#x2F;&#x2F; 这里我们不应该去实例化一个具体的 Requester，我们应该只使用 Requester 实例的 requestItem    this.requester &#x3D; new InventoryRequester();  &#125;  requestItems() &#123;    this.items.forEach(item &#x3D;&gt; &#123;      this.requester.requestItem(item);    &#125;);  &#125;&#125;const inventoryTracker &#x3D; new InventoryTracker([&quot;apples&quot;, &quot;bananas&quot;]);inventoryTracker.requestItems();</code></pre><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class InventoryTracker &#123;  constructor(items, requester) &#123;    this.items &#x3D; items;    this.requester &#x3D; requester;  &#125;  requestItems() &#123;    this.items.forEach(item &#x3D;&gt; &#123;      this.requester.requestItem(item);    &#125;);  &#125;&#125;class InventoryRequesterV1 &#123;  constructor() &#123;    this.REQ_METHODS &#x3D; [&quot;HTTP&quot;];  &#125;  requestItem(item) &#123;    &#x2F;&#x2F; ...  &#125;&#125;class InventoryRequesterV2 &#123;  constructor() &#123;    this.REQ_METHODS &#x3D; [&quot;WS&quot;];  &#125;  requestItem(item) &#123;    &#x2F;&#x2F; ...  &#125;&#125;&#x2F;&#x2F; 这里我们在外部实例化 InventoryRequester 并且注入，我们就可以简单就将 InventoryRequesterV1 替换 InventoryRequesterV2const inventoryTracker &#x3D; new InventoryTracker(  [&quot;apples&quot;, &quot;bananas&quot;],  new InventoryRequesterV2());inventoryTracker.requestItems();</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactNative 文字折叠</title>
      <link href="/2021/01/22/ReactNative-%E6%96%87%E5%AD%97%E6%8A%98%E5%8F%A0/"/>
      <url>/2021/01/22/ReactNative-%E6%96%87%E5%AD%97%E6%8A%98%E5%8F%A0/</url>
      
        <content type="html"><![CDATA[<p> h5 的单行/多行文字溢出截断实现如下</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;&#x2F; 单行div &#123;  white-space: nowrap;  overflow: hidden;  text-overflow: ellipsis;&#125;&#x2F;&#x2F; 多行div &#123;  display: -webkit-box;  overflow: hidden;  -webkit-line-clamp: 2;  -webkit-box-orient: vertical;  text-overflow: ellipsis;&#125;</code></pre><p>在 h5 中，多行文字截断的兼容性并不好，而在 RN 中，实现文字截断则简单的多，只需要给 Text 组件添加 <code>numberOfLines</code> 属性即可。</p><p>但是通常我们还会遇到如下需求：</p><p>文字在不超出 N 行时，全部展示，超出 N 行时截断，并显示 阅读更多 按钮，用于点击展开，展开后 阅读更多 按钮显示为 收起，点击后折叠文字。</p><a id="more"></a><p>如果我们能得知文字初始时是否处于折叠状态，那么就很好办了，通过修改 <code>numberOfLines</code>  的值 0 / N，来变更 展开与折叠 状态。</p><p>但是很可惜，RN 并没有提供 api 来告知文字是否处于折叠状态，因此只能另寻他法。</p><h5 id="尝试一"><a href="#尝试一" class="headerlink" title="尝试一"></a>尝试一</h5><p>参考 github 上的 <a href="https://github.com/facebook/react-native/issues/2496">issue</a> 可以看到这个问题由来已久，有个解法是在 onLayout 时获取 Text 的高度, 对比理论折叠值( N * lineHeight)，如果比理论折叠值大，则说明文字处于折叠状态。</p><p>上面这个方案我尝试了下，在 ios 上表现良好，但是在 安卓 机器上，onLayout 时获取到的 Text 高度却是折叠后的高度，这意味着上述方法将失效。</p><h5 id="尝试二"><a href="#尝试二" class="headerlink" title="尝试二"></a>尝试二</h5><p>接着我又注意到一个 api <code>onTextLayout</code>。<code>onTextLayout</code> 在 Text layout 的时候会被调用，可以获取到 lines，这是个对象数组，包含了每行文字的宽高等信息。我打算尝试一下这个 api 具体的表现如何。奇怪的是<code>onTextLayout</code> 虽然可以使用，但是 TS 的申明文件中 Text 组件却没有这个属性。再则在安卓机上 <code>onTextLayout</code>  返回的 lines 为未折叠时的行数，而在 ios 上则为折叠后的行数（最后一行将包括折叠后未能放下的文字）。看来仅通过 <code>onTextLayout</code>  也是无法判断到是否文字处于折叠状态。</p><h5 id="尝试三"><a href="#尝试三" class="headerlink" title="尝试三"></a>尝试三</h5><p>不过上述的尝试启发了我，如果我们可以得知文字在全部展开时的行数，如果超过 N ，则将 <code>numberOfLines</code>  设置为 N，否则为 0，此时的初始化状态必定是折叠的。那么问题是如何得知文字在全部展开时的行数？如果将文字 <code>numberOfLines</code>  初始值设置为 0，表现将会是一开始全部展开，之后再收起，显然不符合需求。那么我们需要在一个不会被看到的地方暗戳戳地渲染 <code>numberOfLines</code>  为 0 的 Text。这里我是构建了一个 height 为 0 的 ScrollView，在这个 ScrollView 中渲染 <code>numberOfLines</code>  为 0 的 Text，并且通过该 Text 的 onTextLayout 可以获取到文字的行数，并且与 N 进行对比，就可以知道文字是否可折叠。</p><p>最终代码实现如下：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&#x2F;* 该组件的主要用途是测量具有 numberOfLines 属性的 Text 是否会被裁剪，以用于自定义展开更多按钮 原理是在一个高度为 0 的 ScrollView 中进行渲染，获取到渲染后的行数*&#x2F;import React, &#123; Children, isValidElement, cloneElement &#125; from &#39;react&#39;;import &#123; View, ViewStyle, ScrollView &#125; from &#39;react-native&#39;;interface IProps &#123;&#x2F;&#x2F; 最多行数，超出折叠  limitLineNumber: number;  children: React.ReactElement;  onReady: (truncated: boolean) &#x3D;&gt; void;  style: ViewStyle;&#125;const ReadMore &#x3D; (&#123; children, limitLineNumber, onReady, style &#125;: IProps) &#x3D;&gt; &#123;  &#x2F;* 复制出一个不带有 numberOfLines 的 children *&#x2F;  const childrenTemp &#x3D; Children.map(children, (child) &#x3D;&gt; &#123;    if (isValidElement(child)) &#123;      return cloneElement(child as React.ReactElement&lt;any&gt;, &#123;        numberOfLines: 0,        onTextLayout: (e: any) &#x3D;&gt; &#123;          &#x2F;&#x2F; onTextLayout事件：ios 与 安卓 在文字折叠情况时会略微不同，体现在 lines 属性上          &#x2F;&#x2F; ios 是返回折叠后的，而安卓则返回的是折叠之前的          &#x2F;&#x2F; onTextLayout 在 0.59 的文档上并未体现，且 ts 类型也没有，但实际上是可以使用的          onReady(e.nativeEvent.lines?.length &gt; limitLineNumber);        &#125;,      &#125;);    &#125;    return child;  &#125;);  return (    &lt;View style&#x3D;&#123;style&#125;&gt;      &lt;ScrollView style&#x3D;&#123;&#123; height: 0 &#125;&#125;&gt;&#123;childrenTemp&#125;&lt;&#x2F;ScrollView&gt;      &#123;children&#125;    &lt;&#x2F;View&gt;  );&#125;;export default ReadMore;</code></pre><p>使用时:</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const Demo &#x3D; () &#x3D;&gt; &#123;  const onReadMoreReady &#x3D; (truncated: boolean) &#x3D;&gt; &#123;      &#x2F;&#x2F; 根据是否可折叠，判断展示按钮的文字等状态  &#125;;    return &lt;ReadMore onReady&#x3D;&#123;onReadMoreReady&#125; limitLineNumber&#x3D;&#123;2&#125; &gt;    &lt;Text&gt;      any content you need...    &lt;&#x2F;Text&gt;  &lt;&#x2F;ReadMore&gt;&#125;</code></pre><p>⚠️ 以上全部基于 RN 0.59 版本</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次踩坑：webp与ios</title>
      <link href="/2020/12/31/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91%EF%BC%9Awebp%E4%B8%8Eios/"/>
      <url>/2020/12/31/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91%EF%BC%9Awebp%E4%B8%8Eios/</url>
      
        <content type="html"><![CDATA[<p>最近有同事遇到一个问题，有个页面的图片（<a href="http://www.xxx.jpg）在安卓和">www.xxx.jpg）在安卓和</a> pc 都能正常显示，但是用 ios 就展示不了。通常出现在这种情况是因为 WKWebview 不支持 webp 的图片导致的。通过 <a href="https://caniuse.com/?search=webp，可以看到">https://caniuse.com/?search=webp，可以看到</a> safari 在 14.0 之后才支持 webp。</p><a id="more"></a><p>虽然这个场景里的图片后缀名是 jpg，但文件的后缀名并不能准确反映文件的实际格式。因此在 pc 端打开链接后，查看 <code>Content-Type</code> 看到属性为 <code>image/webp</code>, 因此可以确定这个图片文件实际上是 webp。</p><p>这个图片是在后台系统上传的，那么有可能是操作人员从网络下载了一张 webp 的图片，之后修改后缀名并上传。</p><p>上传组件是通过 antdesign 提供的<code>Upload</code>（该组件本质上也是封装了 input 组件）。 在 <code>beforeUpload</code> 可以获取到上传的 file， 上传前通过 <code>file.type</code> 校验过文件的 MIME type 必须是 <code>image/jpeg</code>。</p><p>奇怪的这里 webp 文件，如果后缀名改成 jpg, 则 file.type 显示的是 <code>image/jpeg</code> 而非 <code>image/webp</code>, 即 file.type 获取到类型会收到后缀名的影响，并不是准确的文件类型。</p><p>根据 MDN 的描述</p><blockquote><p> Based on the current implementation, browsers won’t actually read the bytestream of a file to determine its media type. It is assumed based on the file extension; a PNG image file renamed to .txt would give “<em>text/plain</em>“ and not “<em>image/png</em>“. Moreover, <code>file.type</code> is generally reliable only for common file types like images, HTML documents, audio and video. Uncommon file extensions would return an empty string. Client configuration (for instance, the Windows Registry) may result in unexpected values even for common types. <strong>Developers are advised not to rely on this property as a sole validation scheme.</strong></p></blockquote><p>确实浏览器会依据后缀名来判断 File.type 而非真正去读取文件流内容。</p><p>那么如何判断文件的类型是否为我们需要的类型呢？有同事给了段代码:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var reader &#x3D; new FileReader();reader.onload &#x3D; function() &#123;  const isJPG &#x3D; z &#x3D;&gt; [255,216,255].every((v, k) &#x3D;&gt; z.charCodeAt(k)&#x3D;&#x3D;&#x3D;v);  const isWEBP &#x3D; z &#x3D;&gt; [87,69,66,80].every((v, k) &#x3D;&gt; z.charCodeAt(k+8)&#x3D;&#x3D;&#x3D;v);  const isPNG &#x3D; z &#x3D;&gt; [137,80,78,71,13,10,26,10].every((v, k) &#x3D;&gt; z.charCodeAt(k) &#x3D;&#x3D;&#x3D; v);  const isGIF &#x3D; z &#x3D;&gt; [71,73,70].every((v, k) &#x3D;&gt; z.charCodeAt(k) &#x3D;&#x3D;&#x3D; v);  var res &#x3D; reader.result;  console.log(isJPG(res));  console.log(isWEBP(res));  console.log(isPNG(res));  console.log(isGIF(res));&#125;;reader.readAsBinaryString($0.files[0]);</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给 RN 添加 mobx</title>
      <link href="/2020/12/14/%E7%BB%99-RN-%E6%B7%BB%E5%8A%A0-mobx/"/>
      <url>/2020/12/14/%E7%BB%99-RN-%E6%B7%BB%E5%8A%A0-mobx/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>项目组中 RN 之前使用的状态管理是小伙伴自行封装 redux， redux-saga 的一个组件库，然而由于文档不全，使用起来不方便等原因，经过讨论，决定替换成 mobx。主要参考官方文档： <a href="https://mobx.js.org/react-integration.html#react-integration。本文记录我将">https://mobx.js.org/react-integration.html#react-integration。本文记录我将</a> mobx 加入 RN 的过程以及使用 mobx 的一些注意事项（实际上与普通的 React 项目差不多）</p><a id="more"></a><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li><p>在 src 目录下新增一个 stores 文件夹用于存放 mobx 相关的代码</p></li><li><p>编写 observable state，这里我写了一个 Counter.ts 并且新建 stores.ts 管理所有的状态：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Counter.tsimport &#123; makeAutoObservable &#125; from &#39;mobx&#39;;class Counter &#123;  count &#x3D; 0;  constructor() &#123;    makeAutoObservable(this);  &#125;  &#x2F;&#x2F; 注意要使用箭头函数，否则需要用 action.bound 来绑定 this，否则指向 React 组件  increase &#x3D; () &#x3D;&gt; &#123;    this.count +&#x3D; 1;  &#125;;  decrease &#x3D; () &#x3D;&gt; &#123;    this.count -&#x3D; 1;  &#125;;&#125;export default Counter;&#x2F;&#x2F; stores.tsimport Counter from &#39;.&#x2F;Counter&#39;;export default &#123;  counter: new Counter(),&#125;;</code></pre></li><li><p>根据 mobx 文档，组件要使用外部状态有三种写法：</p><ol><li>通过 props 将 状态传递到组件</li><li>直接通过 import 进来</li><li>通过 React context 引入到组件</li></ol><p>为了方便使用，考虑 2，3 中写法，文档中推荐使用 context，那么就这里尝试使用 context。</p></li><li><p>编写 withStores.ts 函数，这是一个高阶组件，主要的作用是给根元素用 Provider 包裹起来，并且根元素通常也是需要 observe 的，因此这里也顺便将其转成可观测的组件：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; withStores.tsimport React, &#123; createContext &#125; from &#39;react&#39;;import &#123; observer &#125; from &#39;mobx-react-lite&#39;;import stores from &#39;.&#x2F;stores&#39;;&#x2F;&#x2F; 初始化 Contextexport const StoresContext &#x3D; createContext&lt;typeof stores&gt;(stores);const withStores &#x3D; &lt;P extends object&gt;(  WrappedComponent: React.FunctionComponent&lt;P&gt;,) &#x3D;&gt; (props: P) &#x3D;&gt; &#123;  &#x2F;&#x2F; 转成可观测的组件  const ObserverWrappedComponent &#x3D; observer(WrappedComponent);  return (    &lt;StoresContext.Provider value&#x3D;&#123;stores&#125;&gt;      &lt;ObserverWrappedComponent &#123;...props&#125; &#x2F;&gt;    &lt;&#x2F;StoresContext.Provider&gt;  );&#125;;export default withStores;</code></pre></li><li><p>接下来的使用就简单了：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useContext &#125; from &#39;react&#39;;import &#123; TouchableOpacity, View, Text &#125; from &#39;react-native&#39;;import &#123; withStores, StoresContext &#125; from &#39;@&#x2F;stores&#39;;import Child from &#39;.&#x2F;Child&#39;;const MobxDemo &#x3D; () &#x3D;&gt; &#123;  const &#123; counter &#125; &#x3D; useContext(StoresContext);  return (    &lt;View&gt;      &lt;Text&gt;count: &#123;counter.count&#125;&lt;&#x2F;Text&gt;      &lt;TouchableOpacity onPress&#x3D;&#123;counter.increase&#125;&gt;        &lt;Text&gt;increase: +&lt;&#x2F;Text&gt;      &lt;&#x2F;TouchableOpacity&gt;      &lt;TouchableOpacity onPress&#x3D;&#123;counter.decrease&#125;&gt;        &lt;Text&gt;decrease: -&lt;&#x2F;Text&gt;      &lt;&#x2F;TouchableOpacity&gt;      &lt;Child &#x2F;&gt;    &lt;&#x2F;View&gt;  );&#125;;export default withStores(MobxDemo);&#x2F;&#x2F; Child.tsximport React, &#123; useContext &#125; from &#39;react&#39;;import &#123; observer &#125; from &#39;mobx-react-lite&#39;;import &#123; Text &#125; from &#39;react-native&#39;;import &#123; StoresContext &#125; from &#39;@&#x2F;stores&#39;;export const Child &#x3D; () &#x3D;&gt; &#123;  const &#123; counter &#125; &#x3D; useContext(StoresContext);  return &lt;Text&gt;child: &#123;counter.count&#125;&lt;&#x2F;Text&gt;;&#125;;export default observer(Child);</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svg 与字体</title>
      <link href="/2020/12/10/svg-%E4%B8%8E%E5%AD%97%E4%BD%93/"/>
      <url>/2020/12/10/svg-%E4%B8%8E%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>继上一篇 《svg 图片的上传与下载》后，产品要求下载的 svg 需要使用 “OCR-B 10 BT” 这个字体。下面记录下遇到的坑。</p><a id="more"></a><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><code>jsbarcode</code> 这个库提供了一个 <code>font</code> 配置项。例如这里配置 </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">JsBarcode(svg, barcode, &#123;  font: &#39;Arial&#39;&#125;);</code></pre><p>这个配置的作用是在 svg 的 text 节点的 style 属性上添加<code>font:Arial</code></p><p>那么问题如果是 OCR-B 10 BT，我们直接配置成</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">JsBarcode(svg, barcode, &#123;  font: &#39;OCR-B 10 BT&#39;&#125;);</code></pre><p>那么结果会变成:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;text style&#x3D;&quot;font: OCR-B 10 BT&quot;&gt;xxx&lt;&#x2F;text&gt;</code></pre><p>这将会导致无法识别出 font 的属性，而 jsbarcode 并没有单独提供 font-family 配置。正确的写法可以如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">JsBarcode(svg, barcode, &#123;  font: &#96;&quot;OCR-B 10 BT&quot;&#96;&#125;);</code></pre><p>到了这一步并没有完全解决问题，对于系统有安装过 OCR-B 10 BT 字体的用户是可以正常展示下载的 svg，然而对于没有安装过这个字体的则会展示默认字体。这里分成两种场景：1. 在我们的网站上展示 2. 下载后的 svg 展示</p><p>对于第一个场景，在 web 通过 font-face 引入字体文件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">@font-face &#123;    font-family: &#39;OCR-B 10 BT&#39;;    src: url(&#39;fonts&#x2F;webfont.eot&#39;);    src:url(&#39;fonts&#x2F;webfont.woff&#39;) format(&#39;woff&#39;),       url(&#39;fonts&#x2F;webfont.woff2&#39;) format(&#39;woff2&#39;),        url(&#39;fonts&#x2F;webfont.ttf&#39;) format(&#39;truetype&#39;);    font-weight: normal;    font-style: normal;&#125;</code></pre><p>然而在第二个场景则需要将字体文件放到 svg 里面，注意这个会导致 svg 体积增大。</p><p>首先我们需要在 svg 中定义 style：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const defs &#x3D; document.createElementNS(&#39;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&#39;, &#39;defs&#39;);const style &#x3D; document.createElementNS(&#39;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&#39;, &#39;style&#39;);style.type &#x3D; &#39;text&#x2F;css&#39;;&#x2F;&#x2F; myFontStyle 是我们定义的样式，实际上就是一段定义 font-face 的字符串style.innerHTML &#x3D; myFontStyle;defs.appendChild(style);svgElement.appendChild(defs);</code></pre><p>可以通过 <a href="https://www.fontsquirrel.com/tools/webfont-generator">https://www.fontsquirrel.com/tools/webfont-generator</a> 这里选择 EXPERT 模式，在 css 的勾选栏选中 Base64 编码，生成的 zip 包中的 css 文件内容就包含我们编码成 base64 后的样式。将 myFontStyle 替换成 文件内容即可。</p><p>至此给 svg 定义字体的需求就算是完成了，不过真的不推荐将字体塞进 svg 中，否则文件体积将会飙升 ☠️</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾项目中实践的 graphql</title>
      <link href="/2020/11/16/%E5%9B%9E%E9%A1%BE%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E8%B7%B5%E7%9A%84-graphql/"/>
      <url>/2020/11/16/%E5%9B%9E%E9%A1%BE%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E8%B7%B5%E7%9A%84-graphql/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>早些时候在公司内部的做过一个内部项目 <code>api-docs</code>，该项目是提供一个 Api 管理文档平台，类似于 YApi 。项目是半路接过来的，前端使用 <code>vue</code>，服务端使用 <code>eggjs</code> 提供符合 restful 规范的接口，数据库则选择的是 <code>mongodb</code>。</p><p>在不断的迭代中，遇到以下一些问题</p><ol><li>首页和测试模块都展示了 api 列表，但是首页与测试模块所展示的字段存在一些异同点，基于此，有两种做法：<ol><li>提供两个不同的接口</li><li>提供同一个接口，根据请求参数判断需要下发的字段</li></ol></li><li>需要对外开放查询接口，不同部门需求的字段信息不同</li><li>由于是内部使用，接口 ( 需求 ) 改动比较频繁，仅仅是修改前端展示的数据却需要频繁修改服务端接口，当然可以将页面需要的字段全部下发，不过这么做有点浪费带宽。</li></ol><p>因此我引入了 <code>graphql</code> 来解决上述的问题。基本想法是前端自行构建需要的字段，服务端无需变更。</p><p>本文尝试去还原引入的过程是防止遗忘( 实际上时间隔得比较久了，一些细节确实已经模糊了 )。由于当时也是摸石头过河，可能会有一些不是最佳实践的地方，还望指教。</p><a id="more"></a><p>文中涉及到的库版本：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 服务端dataloader: 1.4.0egg: 2.0.0egg-graphql: 2.3.0graphql-type-json: 0.2.1&#x2F;&#x2F; 前端graphql：14.5.8apollo-boost：0.1.23</code></pre><h4 id="前端处理"><a href="#前端处理" class="headerlink" title="前端处理"></a>前端处理</h4><p>前端我是使用了 apollo 来发送请求的，引入 apollo</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import Vue from &quot;vue&quot;;import VueApollo from &quot;vue-apollo&quot;;import ApolloClient from &quot;apollo-boost&quot;;import API from &quot;@&#x2F;config&#x2F;api&quot;;const apolloClient &#x3D; new ApolloClient(&#123;  uri: &#39;&#x2F;graphql&#39;&#125;);const apolloProvider &#x3D; new VueApollo(&#123;  defaultClient: apolloClient&#125;);Vue.use(VueApollo);export default apolloProvider;</code></pre><p>构造一个查询 api 列表的语句</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import gql from &quot;graphql-tag&quot;;const apiListQuery &#x3D; gql&#96;    query($pageInfo: PageInfo)&#123;      apis(pageInfo: $pageInfo)&#123;        nodes&#123;          _id          name        &#125;        total      &#125;    &#125;  &#96;</code></pre><p>还可以通过开发者工具 graphiql 快速构造正确的查询语句，这个后面会结合 eggjs 介绍。</p><p>发送请求</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">function getList &#x3D; async () &#x3D;&gt; &#123;  const pageInfo &#x3D; &#123;    pageSize: 20,    currentPage: 1&#125;;  await apolloProvider.defaultClient.query(&#123;    query: apiListQuery,    variables: &#123;      pageInfo    &#125;  &#125;);&#125;</code></pre><p>或者简单通过 axios 发送</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">axios(&#123;  url: &#39;http:&#x2F;&#x2F;xxxxx&#x2F;graphql&#39;,  method: &#39;POST&#39;,  data: &#123;    query: &#96;            query ($filter: Api_Filter, $pageInfo: PageInfo) &#123;              apis(filter: $filter, pageInfo: $pageInfo) &#123;                  nodes &#123;                      _id                      name                  &#125;                  total              &#125;          &#125;&#96;,    variables: &#123;      pageInfo: &#123;        pageSize: 20,        currentPage: 1,      &#125;    &#125;,  &#125;,&#125;);</code></pre><h4 id="服务端处理"><a href="#服务端处理" class="headerlink" title="服务端处理"></a>服务端处理</h4><p>仅改造旧接口中有上述需求的 get 请求，对于其他没有必要全部转为 graphql 的接口不做变更。</p><p>egg 对 graphql 做了一定的支持: <a href="https://github.com/eggjs/egg-graphql，其中的配置可以参考文档。">https://github.com/eggjs/egg-graphql，其中的配置可以参考文档。</a></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; congfig.jsgraphql: &#123;  router: &#39;&#x2F;graphql&#39;,  &#x2F;&#x2F; 是否加载到 app 上，默认开启  app: true,  &#x2F;&#x2F; 是否加载到 agent 上，默认关闭  agent: false,  &#x2F;&#x2F; 是否加载开发者工具 graphiql, 默认开启。路由同 router 字段。使用浏览器打开该可见。  graphiql: true&#125;&#x2F;&#x2F; pluginexports.graphql &#x3D; &#123;  enable: true,  package: &#39;egg-graphql&#39;&#125;</code></pre><p>目录结构：</p><pre class="line-numbers language-none"><code class="language-none">.├── app│   ├── graphql│   │   ├── project│   │   │   └── schema.graphql│   │   ├── api  &#x2F;&#x2F; api 模型│   │   │   ├── connector.js  │   │   │   ├── resolver.js│   │   │   └── schema.graphql│   ├── model│   │   └── api.js│   ├── public│   └── router.js</code></pre><p>在 app 下新增一个 graphql 文件夹。</p><p>下面再新建一个 api 文件夹，根据 GraphQL 的规范，将 GraphQL 相关逻辑分成 Schema, Resolvers, Models, 和 Connectors。</p><p> schema.graphql 中描述数据模型，有点像 typescript 中的 interface。</p><p>graphql 的数据模型入口在 project/schema.graphql</p><pre class="line-numbers language-none"><code class="language-none">type Apis &#123;  nodes: [Api],  total: Int&#125;type Query &#123;  apis(filter: Api_Filter, pageInfo: PageInfo): Apis&#125;</code></pre><p>api / schema.graphql 的内容如下</p><pre class="line-numbers language-none"><code class="language-none">type Api_Options &#123;&#x2F;&#x2F; 。。。&#125;type Api &#123;  _id: String  name: String  options: Api_Options&#125;</code></pre><p>声明的 type 可以被别的 type 引用。</p><p>resolver 是对接到用户查询</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module.exports &#x3D; &#123;  Query: &#123;    apis (root, params, ctx) &#123;      return ctx.connector.api.find(params)    &#125;,  &#125;,&#125;</code></pre><p>上面我们看到 ctx 有个 connector 属性，实际上对应的就是我们的 connector 文件，connector 主要负责取数逻辑，类似于 controller 的职能。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">class ApiConnector &#123;  constructor (ctx) &#123;    this.ctx &#x3D; ctx  &#125;  async find (params) &#123;    &#x2F;&#x2F; 获取到参数    const &#123; pageInfo &#125; &#x3D; params    const &#123; currentPage, pageSize &#125; &#x3D; pageInfo    const apis &#x3D; await this.ctx.model.Api.find()      .sort(&#123;        createTime: -1      &#125;)      .skip((Number(currentPage) - 1) * Number(pageSize))      .limit(Number(pageSize))      .exec()    const total &#x3D; await this.ctx.model.Api.find()      .count()      .exec()    return &#123;      nodes: apis,      total    &#125;  &#125;&#125;module.exports &#x3D; ApiConnector</code></pre><p>至此完成了一个简单的发 graphql 请求，到服务端处理的并返回的过程。</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>DataLoader：graphql 支持嵌套查询，有时候会出现严重的N+1查询性能问题。为了解决这个问题，facebook 提出 dataloader 这个方案。</p><ol><li>具体可以看 <a href="https://zhuanlan.zhihu.com/p/30604868">https://zhuanlan.zhihu.com/p/30604868</a> 的说明。</li><li>dataloader 要求返回的结果和传入的 key 一致，而 mongo find 与 $in 是不保证顺序的，请注意要转成正确的顺序。</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GraphQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode merge-diffs 插件开发</title>
      <link href="/2020/10/30/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2020/10/30/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>当前的项目由于不是严格按照敏捷开发进行的，经常有功能分支需要分别上到 测试，预发以及开发环境。这个就导致了功能分支比较多，且开发要在临上线前整理需上线的分支，在上到正式环境之前需要合并到一个临时分支，之后再统一上到 master 分支。因此经常会遗漏掉一些分支。用 git log 可以对比出两个分支合并分支的区别，从而知道有哪些分支合并到测试分支，但是并没合并到 master。 那么这些分支就有可能是需要上线到 master 的。我个人比较习惯使用命令行 + vscode 来使用 git，但是命令行不太直观，且交互比较麻烦，因此打算写个 VSCode 插件。</p><a id="more"></a><p>关于个人项目（排除单纯为了折腾技术的目的）我有一个经验是追求的不应该是技术方案完美，而是能尽快作出需要的功能（否则极可能中途放弃），之后再不断迭代直至自己满意，因此这个过程中可能会有一些不够十全十美的地方，还望见谅。</p><p>代码地址：<a href="https://github.com/KNighD/merge-diffs">https://github.com/KNighD/merge-diffs</a></p><h4 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h4><p>这里我选择使用 Typescript 来实现插件，要说原因，主要是可以提示参数类型吧，毕竟不太熟悉文档。</p><p>由于存在输入时间之类的交互，因此还是需要使用到 webview 的，html 部分考虑使用 vue3 来实现（虽然react 写起来更熟悉，但是想折腾一下）</p><p>总体的想法是在页面输入查询条件，然后在与 node 端进行通信，执行命令查询出结果处理完成后回传给页面并做展示。界面 UI 的话就参考 Git History。</p><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;&#x2F; 安装脚手架npm install -g yo generator-code&#x2F;&#x2F; 生成模板代码yo code</code></pre><p>题外话：github 上的主分支已经改叫 main 了。。</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>初始代码模板入口是 <code>src/extension.ts</code>，功能就是在命令面板输入 <code>Hello World</code>，将会弹出一句提示。</p><p>用 vscode 打开生成的项目，按 F5 将会弹出一个新窗口，在新窗口的命令面板输入 <code>Hello World</code>，如果弹出一句提示，就表明项目初始化成功了。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; package.json&#123;  &quot;activationEvents&quot;: [  &#x2F;&#x2F; 当命令运行时启动      &quot;onCommand:merge-logs.showMergeLogs&quot;    ],    &quot;contributes&quot;: &#123;      &quot;commands&quot;: [      &#x2F;&#x2F; 定义命令        &#123;          &quot;command&quot;: &quot;merge-logs.showMergeLogs&quot;,          &#x2F;&#x2F; 命令面板上展示的          &quot;title&quot;: &quot;MergeLogs: show&quot;        &#125;      ]    &#125;&#125;</code></pre><h4 id="打开一个-webview"><a href="#打开一个-webview" class="headerlink" title="打开一个 webview"></a>打开一个 webview</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let show &#x3D; vscode.commands.registerCommand(&#39;merge-logs.showMergeLogs&#39;, () &#x3D;&gt; &#123;    const panel &#x3D; vscode.window.createWebviewPanel(      &#39;testWebview&#39;,      &#x2F;&#x2F; title      &#39;MergeLogs&#39;,      &#x2F;&#x2F; 显示在编辑器的哪个部位      vscode.ViewColumn.One,      &#123;        &#x2F;&#x2F; 启用JS，默认禁用        enableScripts: true,        &#x2F;&#x2F; webview被隐藏时保持状态，避免被重置        retainContextWhenHidden: true,      &#125;    )    panel.webview.html &#x3D; &#96;&lt;html&gt;&lt;body&gt;test merge logs&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#96;  &#125;)  context.subscriptions.push(show)</code></pre><p>WebView 加载的资源路径可以通过以下方法获取</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const getRelativeResource &#x3D; (webview: Webview, relativePath: string) &#x3D;&gt; &#123;  return webview.asWebviewUri(Uri.file(path.join(context.extensionPath, relativePath)));&#125;;panel.webview.html &#x3D; &#96;&lt;html&gt;&lt;head&gt;&lt;script src&#x3D;&#39;$&#123;getRelativeResource(panel.webview, &#39;.&#x2F;test.js&#39;)&#125;&#39;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;test merge logs&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#96;;&#125;);</code></pre><p>调试的时候需要在开发窗口打开命令面板，输入 <code>Open Webview Developer Tools</code> </p><h4 id="开发-web-页面"><a href="#开发-web-页面" class="headerlink" title="开发 web 页面"></a>开发 web 页面</h4><p>我将 web 页面放在 /client 目录下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm init vite-app client cd clientnpm i</code></pre><p>项目是基于 Typescript 的，而 client 是 vue，此时根目录的 eslint 会报错，我们先将 client 目录下的文件忽略掉,将来在 client 中单独添加 eslint。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; .eslint.json&quot;ignorePatterns&quot;: [&quot;&#x2F;client&quot;]</code></pre><p>项目打包后资源文件会带上 hash 值，按照 webpack 的经验，应该可以采取两种处理方式：</p><ol><li>修改打包配置将 public path 替换成 getRelativeResource 后获取到的地址, 动态读取打包后的 html</li><li>webview 写死 html 模板，修改打包配置，让打包后的资源不带 hash,见 <a href="https://github.com/vitejs/vite/issues/378">https://github.com/vitejs/vite/issues/378</a></li></ol><p>这里采用第二种方案，在 client 下添加 <code>vite.config.js</code> </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; vite.config.jsexport default &#123;  rollupOutputOptions: &#123;    entryFileNames: &#96;[name].js&#96;,    chunkFileNames: &#96;[name].js&#96;,    assetFileNames: &#96;[name].[ext]&#96;,  &#125;,&#125;</code></pre><p>🤔不过还有一个问题，调试起来非常麻烦，每次修改完都需要 build 一下</p><h4 id="实现简单通信"><a href="#实现简单通信" class="headerlink" title="实现简单通信"></a>实现简单通信</h4><p>在页面上添加一个简单的按钮，点击这个按钮后，将会发一个 getLogs 的命令给插件端，插件端接收之后，执行 <code>git log</code>,并返回结果。</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; App.vue&lt;template&gt;  &lt;button @click&#x3D;&quot;sendMessage&quot;&gt;sendMessage&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      vscode: null,    &#125;  &#125;,  mounted() &#123;    &#x2F;&#x2F; 初始化 vscode 对象    this.vscode &#x3D; acquireVsCodeApi()    &#x2F;&#x2F; 监听来自 vscode 插件的信息    window.addEventListener(&#39;message&#39;, (event) &#x3D;&gt; &#123;      const message &#x3D; event.data      console.log(message)    &#125;)  &#125;,  methods: &#123;    sendMessage() &#123;      &#x2F;&#x2F; 发送消息给插件      this.vscode.postMessage(&#39;getLogs&#39;)    &#125;,  &#125;,&#125;&lt;&#x2F;script&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 插件端接收到消息panel.webview.onDidReceiveMessage(  async (message) &#x3D;&gt; &#123;    if (message &#x3D;&#x3D;&#x3D; &#39;getLogs&#39;) &#123;      try &#123;        const logs &#x3D; await getLogs();        panel.webview.postMessage(logs);      &#125; catch (error) &#123;        panel.webview.postMessage(error);      &#125;    &#125;  &#125;,  undefined,  context.subscriptions);&#125;</code></pre><p>使用 <code>child_process</code> 并执行 node 命令，并封装成 Promise：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const getLogs &#x3D; () &#x3D;&gt; &#123;  return new Promise((resolve, reject) &#x3D;&gt; &#123;    cp.exec(      &#96;git log&#96;,      (err: Error, stdout: string, stderr: string) &#x3D;&gt; &#123;        if (stderr || err) &#123;          return reject(stderr || err);        &#125;        return resolve(stdout);      &#125;    );  &#125;);&#125;;</code></pre><p>⚠️ 由于 exec 会衍生子 shell，因此在每次执行 shell 命令时要确认当前的路径是否正确。</p><p>至此一个大体的框架就完成了。</p><p>后续的开发主要是用 <code>git branch --merged</code> 查询分支合并情况，然后分别对比两个分支的合并分支的异同，并展示到页面上，这里不进行赘述。</p><h4 id="添加-UI-组件库"><a href="#添加-UI-组件库" class="headerlink" title="添加 UI 组件库"></a>添加 UI 组件库</h4><p>组件库这里看到 ant-desin-vue 支持 vue3 了，打算试试。版本需要 2.0.0-beta.5 及以上。</p><p>按需引入，原先是是用 babel-plugin-import 来处理的，不过还没研究如何在 vite 中添加，就打算使用 <code>import Button from &#39;ant-design-vue/lib/button&#39;;</code> 这样的写法，然而运行的时候，vite 会提示:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[vite] Avoid deep import &quot;ant-design-vue&#x2F;lib&#x2F;button&quot; (imported by &#x2F;src&#x2F;main.js)because &quot;ant-design-vue&quot; has been pre-optimized by vite into a single file.Prefer importing directly from the module entry:import &#123; ... &#125; from &quot;ant-design-vue&quot; If the dependency requires deep import to function properly, add the deep path to optimizeDeps.include in vite.config.js.</code></pre><p>意思是 vite 已经做了按需引入的优化了，那么应该直接导入就好了。</p><h4 id="vue3-的-eslint-配置"><a href="#vue3-的-eslint-配置" class="headerlink" title="vue3 的 eslint 配置"></a>vue3 的 eslint 配置</h4><p>填之前的坑，顺便补上 prettier 配置，最终根目录的 eslint 配置如下</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;root&quot;: true,  &quot;parser&quot;: &quot;vue-eslint-parser&quot;,  &quot;parserOptions&quot;: &#123;    &quot;parser&quot;: &quot;@typescript-eslint&#x2F;parser&quot;,    &quot;ecmaVersion&quot;: 6,    &quot;sourceType&quot;: &quot;module&quot;  &#125;,  &quot;extends&quot;: [&quot;plugin:vue&#x2F;vue3-recommended&quot;],  &quot;plugins&quot;: [&quot;@typescript-eslint&quot;, &quot;prettier&quot;],  &quot;rules&quot;: &#123;    &quot;@typescript-eslint&#x2F;naming-convention&quot;: &quot;warn&quot;,    &quot;curly&quot;: &quot;warn&quot;,    &quot;eqeqeq&quot;: &quot;warn&quot;,    &quot;no-throw-literal&quot;: &quot;warn&quot;,    &quot;semi&quot;: &quot;off&quot;,    &quot;vue&#x2F;singleline-html-element-content-newline&quot;: &quot;off&quot;  &#125;&#125;</code></pre><h4 id="vite-别名"><a href="#vite-别名" class="headerlink" title="vite 别名"></a>vite 别名</h4><p>目前似乎没有支持多目录 vue 项目的 vscode 插件，见 <a href="https://github.com/vuejs/vetur/issues/424。我这里使用的是">https://github.com/vuejs/vetur/issues/424。我这里使用的是</a> vetur，为了避免报错，在 vite 中配置 alias。（吐槽一下：总觉得 vscode / ts 对 react 的支持还是比 vue 要好上不少的）</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">alias: &#123;  &#x2F;&#x2F; import useInit from &#39;&#x2F;@&#x2F;composables&#x2F;useInit&#39;  &#39;&#x2F;@&#x2F;&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#x2F;&#39;),&#125;</code></pre><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>由于输出安装包时无需用到 client 的源码，因此可以在 .vscodeignore 中加入 client，同时修改 vite 的输出目录，以及插件中引用 client 资源的目录。</p><p>如果此前没有发布过，可以参考 <a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension#publishing-extensions。">https://code.visualstudio.com/api/working-with-extensions/publishing-extension#publishing-extensions。</a></p><p>需要在 package.json 中添加 <code>publisher name</code> 和 <code>repository</code>，运行 <code>vsce package</code> 可以打出一个 .vsix 的拓展包用于安装。</p><p>如果此前有发布过插件，那么有可能个人访问令牌已经失效了，需要到 <a href="https://aka.ms/SignupAzureDevOps">https://aka.ms/SignupAzureDevOps</a> 上重新创建新的个人访问令牌。</p><p>创建个人访问令牌要注意<code>Organization</code>要选择<code>all accessible organizations</code>，<code>Scopes</code>要选择<code>Full access</code>，否则发布会失败。</p><p>之后添加一下 icon ，再补全一下 README 就可以发布了</p><pre class="line-numbers language-none"><code class="language-none">vsce publish</code></pre><h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>以下为个人观点：总体上感觉 Vue3 的组合式 api 和 react 的 hooks 想做的都是同一件事：将原先跟生命周期绑定在一起的逻辑抽离出来，使得代码的关注点更为清晰，同时也更易于复用，作为 hoc / mixins 的一个替代方案。</p><p>不同点是 react 是越来越偏向函数式，比如 useEffect 完全脱离了生命周期的概念，声明式编程。而 vue 依然是命令式，提供了onMounted 之类的 api。</p><p>至于 vite 还没仔细去研究，不过配置确实是少了很多，更容易上手的样子，似乎是基于 rollup ？还有待踩坑。</p>]]></content>
      
      
      <categories>
          
          <category> VSCode插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN瀑布流</title>
      <link href="/2020/10/20/RN%E7%80%91%E5%B8%83%E6%B5%81/"/>
      <url>/2020/10/20/RN%E7%80%91%E5%B8%83%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>电商以及图片网站经常可以看到瀑布流的列表，即多列等宽的列表，但是每一列中的元素高度不一定一致。这在 web 是一个很常见的设计且有很多组件可供使用，而在 ReactNative 中，少有成熟的瀑布流组件，大多数组件要么是多年前维护的，要么 star 数较少，或者干脆有一些不维护了，总之就是用着不放心。因此在产品同学的要求下，实现了一个 RN 瀑布流组件。这里只记录思路，具体代码后面添加了较多业务相关的，就不贴了。</p><a id="more"></a><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ol><li><p>支持上拉加载，下拉刷新</p></li><li><p>支持多列可定制</p></li><li><p>性能尽量好</p></li><li><p>自定义元素</p></li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li><p>整个瀑布流通过 FlatList 来实现，通过设置 columnsNum 与 renderItem，将每一列又分别渲染成一个 FlatList。内层并列的 FlatList 将会撑开且不会产生多余的滚动条，滚动时是外层的 FlatList。</p></li><li><p>接收 data 时，判断每一项应该属于哪一列， 如果项的高度不能提前获得，那么要在项的 onLayout 时获取高度，之后判断下一项属于哪一列</p></li><li><p>下拉采用 RN 提供的 RefreshControl 就可以完成，而上拉的事件，单列表可以通过 onReachEnd 触发，而对于我们这种实现方式则只能通过 onScroll 自行判断是否到达底部</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 由于 onEndReached 在渲染 data 项时会多次触发，且 props 及 state 未变化时不会触发，因此自行实现const handleScroll &#x3D; (event: NativeSyntheticEvent&lt;NativeScrollEvent&gt;) &#x3D;&gt; &#123;  const &#123;    nativeEvent: &#123;      contentOffset: &#123; y: scrollTop &#125;,      contentSize: &#123; height: scrollHeight &#125;,      layoutMeasurement: &#123; height &#125;,    &#125;,  &#125; &#x3D; event;  if (scrollHeight - height - scrollTop &lt;&#x3D; onEndReachedThreshold) &#123;    if (onEndReached) &#123;      onEndReached(event);    &#125;  &#125;  if (props.onScroll) &#123;    props.onScroll(event);  &#125;&#125;;</code></pre></li></ol><p>这样一个简单的 瀑布流就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-native 通讯录字母列表</title>
      <link href="/2020/09/22/react-native-%E9%80%9A%E8%AE%AF%E5%BD%95%E5%AD%97%E6%AF%8D%E5%88%97%E8%A1%A8/"/>
      <url>/2020/09/22/react-native-%E9%80%9A%E8%AE%AF%E5%BD%95%E5%AD%97%E6%AF%8D%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>需求：实现一个选择快递的页面，操作类似于通讯录，设计图如下</p><img src="https://i.loli.net/2020/10/20/OwH5A3bRgSuiBKt.png" alt="image.png" style="zoom: 50%"><p>上半部分的搜索交互及实现这里就不赘述，重点探讨字母列表的实现。</p><a id="more"></a><p>需要实现的点：</p><ol><li>主列表分组，头部不吸顶</li><li>字母列表可以滑动或点击，变更当前选中的字母，且主列表跟随滑动定位</li><li>主列表滚动时，字母列表当前选中的字母对应变化</li></ol><p>搜索了目前已有的开源组件，要么最后一次更新的时间也比较久远，要么不适用于我们的场景，要么 star 数量不多 😂。因此打算重新造个轮子，即使将来有什么问题，也能自行维护。</p><h4 id="AlphabetList"><a href="#AlphabetList" class="headerlink" title="AlphabetList"></a>AlphabetList</h4><p>将我们的组件命名为 AlphabetList，它将接收一个 dataSource ：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;AlphabetList dataSource&#x3D;&#123;dataSource&#125; &#x2F;&gt;</code></pre><p>dataSource 的结构如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface IListItem &#123;  name: string;  value: string | number;&#125;interface ISectionItem &#123;sectionKey: string;data: &#123;name: string;value: string&#125;[]&#125;interface DataSource: SectionItem[]</code></pre><p>例如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">[  &#123;    sectionKey: &#39;常&#39;,    data: [      &#123;        name: &#39;顺丰物流&#39;,        value: &#39;1&#39;,      &#125;,      &#123;        name: &#39;京东快递&#39;,        value: &#39;2&#39;,      &#125;,    ],  &#125;,  &#123;    sectionKey: &#39;A&#39;,    data: [      &#123;        name: &#39;安能物流&#39;,        value: &#39;3&#39;,      &#125;,      &#123;        name: &#39;澳大利亚邮政&#39;,        value: &#39;4&#39;,      &#125;,    ],  &#125;]</code></pre><p>AlphabetList 的结构如下：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;View&gt;  &#123;&#x2F;* 主列表 *&#x2F;&#125;  &lt;MainList &#x2F;&gt;  &#123;&#x2F;* 右侧字母列表 *&#x2F;&#125;  &lt;SideBar &#x2F;&gt;&lt;&#x2F;View&gt;</code></pre><h4 id="MainList"><a href="#MainList" class="headerlink" title="MainList"></a>MainList</h4><p>主列表分组 Main，那么使用 SectionList 是一个不错的选择（当然也可以用 FlatList 来实现）</p><p>当滚动 MainList 时，通过 <code>onListViewableItemsChanged</code> 的回调可以得到当前窗口可视的分组，从而改变当前选中的字母</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const MainList &#x3D; (&#123;    dataSource,    onMainListViewableItemsChanged,  &#125;) &#x3D;&gt; &#123;  return (    &lt;SectionList      renderItem&#x3D;&#123;(&#123; item &#125;) &#x3D;&gt; (&lt;ListItem item&#x3D;&#123;item&#125; &#x2F;&gt;)&#125;      renderSectionHeader&#x3D;&#123;(&#123; section &#125;) &#x3D;&gt; &lt;SectionHeader section&#x3D;&#123;section&#125; &#x2F;&gt;&#125;      keyExtractor&#x3D;&#123;(item) &#x3D;&gt; &#96;$&#123;item.value&#125;&#96;&#125;      sections&#x3D;&#123;dataSource&#125;      stickySectionHeadersEnabled&#x3D;&#123;false&#125;      onViewableItemsChanged&#x3D;&#123;onMainListViewableItemsChanged&#125;    &#x2F;&gt;  );&#125;;export default MainList;</code></pre><p>在 AlphabetList 中：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const AlphabetList &#x3D; (&#123; dataSource &#125;: IProps) &#x3D;&gt; &#123;  &#x2F;&#x2F; 右侧字母表列表  const letterlist &#x3D; dataSource.map((item) &#x3D;&gt; &#123;    return item.sectionKey;  &#125;);  const [currentSectionKey, setCurrentSectionKey] &#x3D; useState(letterlist);  const onMainListViewableItemsChanged &#x3D; (info: &#123;    viewableItems: ViewToken[];  &#125;) &#x3D;&gt; &#123;    &#x2F;&#x2F; 将选中的字母设置为当前第一个可见 section 的 sectionKey    setCurrentSectionKey(info.viewableItems[0].section.sectionKey);  &#125;;  return (    &lt;View style&#x3D;&#123;styles.container&#125;&gt;      &#123;&#x2F;* 主列表 start *&#x2F;&#125;      &lt;MainList        dataSource&#x3D;&#123;dataSource&#125;        onMainListTouchStart&#x3D;&#123;() &#x3D;&gt; setCurrentResponder(&#39;mainList&#39;)&#125;        onMainListViewableItemsChanged&#x3D;&#123;onMainListViewableItemsChanged&#125;      &#x2F;&gt;      &#123;&#x2F;* 主列表 end *&#x2F;&#125;      &#123;&#x2F;* 右侧字母列表 start *&#x2F;&#125;      &lt;SideBar &#x2F;&gt;      &#123;&#x2F;* 右侧字母列表 end *&#x2F;&#125;    &lt;&#x2F;View&gt;  );&#125;;export default AlphabetList;</code></pre><h4 id="SideBar"><a href="#SideBar" class="headerlink" title="SideBar"></a>SideBar</h4><p>侧边栏的实现比起来则要复杂一些，这里使用一个绝对定位的 FlatList，实际上简单使用 View 去实现也是可以的。</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const SideBar &#x3D; (&#123;  letterlist,  &#x2F;&#x2F; 回调  handleSideBarItemRespond,  currentSectionKey&#125;: IProps) &#x3D;&gt; &#123;  return (    &lt;FlatList      style&#x3D;&#123;styles.wrap&#125;      scrollEnabled&#x3D;&#123;false&#125;      data&#x3D;&#123;letterlist&#125;      renderItem&#x3D;&#123;(&#123; item, index &#125;) &#x3D;&gt; (        &lt;Item          item&#x3D;&#123;item&#125;          handleSideBarItemRespond&#x3D;&#123;handleSideBarItemRespond&#125;          letterlist&#x3D;&#123;letterlist&#125;        &#x2F;&gt;      )&#125;      keyExtractor&#x3D;&#123;item &#x3D;&gt; item&#125;    &#x2F;&gt;  );&#125;;</code></pre><p>一开始我的想法是通过监听 Item 的 onPress | onPressIn ，从一项滑动到另一项的时候，依次触发事件，实验后发现，在释放手势之前，仅会有一个响应的元素。</p><p>这里就得提一下 RN 的手势系统了。</p><h5 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h5><p>在 React Native 中，响应手势的基本单位是<code>responder</code>，并且仅有一个 <code>responder</code> 拥有控制权。在 View 上有这些属性：</p><ol><li>onStartShouldSetResponder：点击时是否变成一个 responder</li><li>onMoveShouldSetResponder：滑动时是否变成一个 responder</li><li>onResponderGrant： 点击时的回调</li><li>onResponderMove：移动时的回调</li><li>onResponderTerminationRequest：当别的元素希望成为 responder 时，是否要释放当前的 responder？</li><li>onResponderRelease：当 reponder 释放时的回调</li><li>等等</li></ol><p>通过上述这些 API 我们就能很容易的实现一些手势。初次之外，RN 还提供了更高级的抽象 PanResponder，它可以给我们提供更多手势信息，这里不展开解释。</p><p>不过当我尝试在每个 Item 上设置手势响应，并且设置  onResponderTerminationRequest 为 <code>() =&gt; true</code>，手势依然没有在切换 Item 时释放原 responder。</p><p>因此只能通过计算高度来获取滑动时当前的字母</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; evt.nativeEvent.pageY: 触摸事件的 pageY&#x2F;&#x2F; sideBarTop: SideBar 的 pageY&#x2F;&#x2F; letterHeight：每个字母的高度const index &#x3D; Math.floor((evt.nativeEvent.pageY - sideBarTop) &#x2F; letterHeight);</code></pre><p>要获取元素距离屏幕的高度，可以在 onLayout 的时候，调用 measure 来获取：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const SideBar &#x3D; (&#123;  letterlist,  handleSideBarItemRespond,  currentSectionKey,  letterHeight,&#125;: IProps) &#x3D;&gt; &#123;  const [sideBarTop, setSideBarTop] &#x3D; useState(0);  const sideBarRef &#x3D; useRef&lt;View&gt;(null);  const measure &#x3D; () &#x3D;&gt; &#123;    if (sideBarRef.current) &#123;      sideBarRef.current.measure((x, y, width, height, pageX, pageY) &#x3D;&gt; &#123;        setSideBarTop(pageY);      &#125;);    &#125;  &#125;;  return (    &lt;View onLayout&#x3D;&#123;measure&#125; ref&#x3D;&#123;sideBarRef&#125;&gt;      &lt;FlatList&lt;string&gt;        &#x2F;&#x2F; ...      &#x2F;&gt;    &lt;&#x2F;View&gt;  );&#125;;</code></pre><p>然后就是 Item 的实现：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const Item &#x3D; (&#123;  item,  handleSideBarItemRespond,  isCurrentSectionKey,  letterlist,  letterHeight,  sideBarTop,&#125;: &#123;  item: string;  isFirst: boolean;  handleSideBarItemRespond: (item: string) &#x3D;&gt; void;  letterlist: string[];  letterHeight: number;  sideBarTop?: number;&#125;) &#x3D;&gt; &#123;  const panResponder &#x3D; PanResponder.create(&#123;    onStartShouldSetPanResponderCapture: () &#x3D;&gt; true,    onStartShouldSetPanResponder: () &#x3D;&gt; true,    &#x2F;&#x2F; 尝试通过 onResponderTerminationRequest 来终止手势，发现不生效，只能通过计算偏移量来获取当前选中    onPanResponderTerminationRequest: () &#x3D;&gt; true,    onPanResponderGrant: () &#x3D;&gt; &#123;      handleSideBarItemRespond(item);    &#125;,    onPanResponderMove: (evt, gs) &#x3D;&gt; &#123;      if (!sideBarTop) &#123;        return;      &#125;      const index &#x3D; Math.floor(        (evt.nativeEvent.pageY - sideBarTop) &#x2F; letterHeight,      );      if (index &gt;&#x3D; 0 &amp;&amp; index &lt; letterlist.length) &#123;        &#x2F;&#x2F; 触发侧边字母选中的回调        handleSideBarItemRespond(letterlist[index]);      &#125;    &#125;,  &#125;);  return (    &lt;View &#123;...panResponder.panHandlers&#125;&gt;      &lt;Text&gt;        &#123;item&#125;      &lt;&#x2F;Text&gt;    &lt;&#x2F;View&gt;  );&#125;;</code></pre><p>到此为止，侧边栏的逻辑已经完成。现在处理侧边栏事件的回调逻辑, 主要通过 scrollToLocation 来实现列表滚动到对应的位置</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const AlphabetList &#x3D; (&#123; dataSource, companyList, onCompanySelect &#125;: IProps) &#x3D;&gt; &#123;  &#x2F;&#x2F; ...  const mainListRef &#x3D; useRef&lt;SectionList&lt;IListItem&gt;&gt;(null);  const handleSideBarItemRespond &#x3D; (item: string) &#x3D;&gt; &#123;    if (!mainListRef.current) &#123;      return;    &#125;  &#x2F;&#x2F; 记录当前选中的字母    setCurrentSectionKey(item);    mainListRef.current.scrollToLocation(&#123;      sectionIndex: dataSource.findIndex((data) &#x3D;&gt; data.sectionKey &#x3D;&#x3D;&#x3D; item),      itemIndex: 0,      animated: false,    &#125;);  &#125;;  return (    &lt;View style&#x3D;&#123;styles.container&#125;&gt;      &#123;&#x2F;* 主列表 start *&#x2F;&#125;      &lt;MainList        &#x2F;&#x2F; ...        ref&#x3D;&#123;mainListRef&#125;      &#x2F;&gt;      &#x2F;&#x2F; ...    &lt;&#x2F;View&gt;  );&#125;;</code></pre><p>这里需要通过 React.forwardRef 获取到 MainList 的 ref</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const MainList: React.ForwardRefRenderFunction&lt;  SectionList&lt;IListItem&gt;,  IProps&gt; &#x3D; (  &#123;    dataSource,    &#x2F;&#x2F; ...  &#125;,  ref,) &#x3D;&gt; &#123; &#x2F;&#x2F; ...  return (    &lt;SectionList      &#x2F;&#x2F; ...      ref&#x3D;&#123;ref&#125;    &#x2F;&gt;  );&#125;;export default React.forwardRef(MainList)</code></pre><p>到这一步，已经基本完成了一个通讯录字母列表。</p><h4 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h4><p>在完成上述功能后，由于点击侧边栏会滚动主列表，此时也会触发 MainList 的 onViewableItemsChanged，因此需要一个标识来区分是什么动作触发的：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const AlphabetList &#x3D; (&#123; dataSource, companyList, onCompanySelect &#125;: IProps) &#x3D;&gt; &#123;  &#x2F;&#x2F; 标识位：用于区分当前的操作是由什么触发的  const [currentResponder, setCurrentResponder] &#x3D; useState(&#39;&#39;);  const mainListRef &#x3D; useRef&lt;SectionList&lt;IListItem&gt;&gt;(null);  &#x2F;&#x2F; 右侧字母表列表  const letterlist &#x3D; dataSource.map((item) &#x3D;&gt; &#123;    return item.sectionKey;  &#125;);  const [currentSectionKey, setCurrentSectionKey] &#x3D; useState(letterlist[0]);  const handleSideBarItemRespond &#x3D; (item: string) &#x3D;&gt; &#123;    if (!mainListRef.current) &#123;      return;    &#125;    setCurrentResponder(&#39;sideBar&#39;);  &#x2F;&#x2F; ...  &#125;;  const onMainListViewableItemsChanged &#x3D; (info: &#123;    viewableItems: ViewToken[];  &#125;) &#x3D;&gt; &#123;    if (      &#x2F;&#x2F; 侧边栏触发的滚动则不触发      currentResponder &#x3D;&#x3D;&#x3D; &#39;sideBar&#39; ||      !info.viewableItems[0].section.sectionKey    ) &#123;      return;    &#125;    setCurrentSectionKey(info.viewableItems[0].section.sectionKey);  &#125;;  return (    &lt;View style&#x3D;&#123;styles.container&#125;&gt;      &#123;&#x2F;* 主列表 start *&#x2F;&#125;      &lt;MainList       &#x2F;&#x2F; ...        onMainListTouchStart&#x3D;&#123;() &#x3D;&gt; setCurrentResponder(&#39;mainList&#39;)&#125;        &#x2F;&#x2F; ...      &#x2F;&gt;      &#123;&#x2F;* 主列表 end *&#x2F;&#125;      &#x2F;&#x2F; ...    &lt;&#x2F;View&gt;  );&#125;;</code></pre><h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><p>功能是基本上完成了，然而由于这里的数据量比较多，大概有 600 条数据，且由于 SectionList 也是基于 VirtualList，因此导致了以下长列表固有的几个问题：</p><ol><li>快速滚动 MainList，当 SectionList 来不及渲染时，会导致屏幕空白</li><li>当使用 scrollToLocation 时，如果定位到来不及渲染的区域，将会报错，提示需要设置 getItemLayout 属性，这个属性是用于计算主列表每一项高度以及偏移量的</li></ol><p>在尝试了一些优化的手段后，如 React.memo, initialNumToRender，getItemLayout 等属性依然无法有效解决上述问题。。</p><p>RN 的 list 真的是让人一言难尽。。不知道是否原生组件或者 flutter 对长列表的支持会更好一点呢 😂</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> TypeScript 的 enum 类型收窄问题</title>
      <link href="/2020/09/21/TypeScript-%E7%9A%84-enum-%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/09/21/TypeScript-%E7%9A%84-enum-%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在项目中看到一段小伙伴写的代码，简化后大概如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">enum A &#123;  &quot;ONE&quot; &#x3D; 1,  &quot;TWO&quot; &#x3D; 2&#125;const a &#x3D; Math.random() &gt; 0.5 ? A.ONE : A.TWOconst b &#x3D; Math.random() &gt; 0.5 ? a : 0if(b &#x3D;&#x3D;&#x3D; 1 || b &#x3D;&#x3D;&#x3D; 2) &#123;&#125;</code></pre><p>此时，b === 2 处 ts 会提示:</p><pre class="line-numbers language-none"><code class="language-none">This condition will always return &#39;false&#39; since the types &#39;0&#39; and &#39;2&#39; have no overlap.ts(2367)</code></pre><p>为何 TypeScript 会提示 0 与 2 没有重合的地方呢？</p><a id="more"></a><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>鼠标悬浮在 b === 1 时，提示 b 的类型为 A ｜ 0 的联合类型，而到了 b === 2 时，却变成了 <code>b: 0</code>。那么也就是说 TypeScript 在判断 b !== 1 时，就判定 b 不可能为类型 A，此时将类型收窄为 0。而 0 不可能 assgin 给 2，因此报错。上网搜索似乎也没有得到为何时这种收窄策略的原因，仅有一个可能有关联的 <a href="https://github.com/Microsoft/TypeScript/issues/9998">https://github.com/Microsoft/TypeScript/issues/9998</a> , 然而至今还是 open 的。</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>那我们要怎么解决这个报错呢？实际上我们将判断的右值改成 enum 即可，且逻辑更清晰，维护更简单：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">if(b &#x3D;&#x3D;&#x3D; A.ONE || b &#x3D;&#x3D;&#x3D; A.TWO) &#123;&#x2F;&#x2F; no error&#125;</code></pre><p>或者下面这种也可以（不是很推荐，没有发挥出 enum 应有的作用）</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">if(b as A &#x3D;&#x3D;&#x3D; 1 || b &#x3D;&#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; no error&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次bug排查</title>
      <link href="/2020/09/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1bug%E6%8E%92%E6%9F%A5/"/>
      <url>/2020/09/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1bug%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>测试同学提了一个测试环境表格无法切换每页条数的 bug。</p><h4 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h4><p>在测试环境操作后发现，确实存在该问题，但是切换到对应测试分支，本地运行，未能重现。</p><a id="more"></a><p>在测试环境的操作发现实际上切换每页条数的回调 onShowSizeChange 确实会触发，但是此后又变回原每页条数。</p><p>对于测试环境与本地开发的表现不一致，在排除了各种可能性之后，猜测是依赖版本不一致导致的。</p><p>版本不一致出现问题此前已经出现过一次：我本地的有段代码提示了一个 eslint 的 no-throw-literal，但是别的同事都没有报错， eslintrc 的配置是一样的。最终发现是我的 umi 版本比较高，其中依赖的 @typescript-eslint/eslint-plugin 在 2.13.0 新增了 no-throw-literal 这个配置，而别的小伙伴们的版本低于此，故不会报错。</p><p>因此执行命令 <code>npm ci</code> ，该命令会按照 packge-lock.json 中记录的版本进行安装,下面是这个命令的说明</p><blockquote><p>This command is similar to <code>npm-install</code>, except it’s meant to be used in automated environments such as test platforms, continuous integration, and deployment – or any situation where you want to make sure you’re doing a clean install of your dependencies. It can be significantly faster than a regular npm install by skipping certain user-oriented features. It is also more strict than a regular install, which can help catch errors or inconsistencies caused by the incrementally-installed local environments of most npm users.</p></blockquote><p>重新安装依赖之后果然本地可以重现该问题。</p><p>此后经过 debug 发现，切换 pageSize 会先后触发 onShowSizeChange 和表格的 onChange，表格的 onChange 重新将 pageSize 设置回去。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最终如何解决上述 bug 就不赘述了。</p><p>主要想总结的是：遇到 bug，如果出现代码和运行环境之类的各种条件都一致，但是表现就是不一致的情况，那么很有可能是依赖包的版本不一致导致的 👻</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易 redux</title>
      <link href="/2020/09/14/%E7%AE%80%E6%98%93-redux/"/>
      <url>/2020/09/14/%E7%AE%80%E6%98%93-redux/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Redux 常常配合 react-redux 作为状态管理应用在 React 的项目中，并且基于 redux 发展出了 dva 之类的诸多状态管理工具。</p><p>说来惭愧，虽然在项目中常常使用到，但是并未阅读过 redux 的源码，了解其原理。本文作为学习笔记，并根据 redux 的比较核心的 createStore 这部分代码实现一个简易版本的 redux，以便将来回顾。</p><a id="more"></a><h4 id="redux-demo"><a href="#redux-demo" class="headerlink" title="redux demo"></a>redux demo</h4><p>redux 提供了使用 demo 如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; createStore &#125; from &#39;redux&#39;&#x2F;** * 这是个 reducer，纯函数，用于描述状态是如何转变的 * reducer 接收 state 和 action 作为参数 *&#x2F;function counter(state &#x3D; 0, action) &#123;  switch (action.type) &#123;    case &#39;INCREMENT&#39;:      return state + 1    case &#39;DECREMENT&#39;:      return state - 1    default:      return state  &#125;&#125;&#x2F;&#x2F; createStore：接收 reducer 作为参数，以此构建一个 storelet store &#x3D; createStore(counter)&#x2F;&#x2F; 订阅 store, 每次 dispatch 的时候，都将触发回调store.subscribe(() &#x3D;&gt; console.log(store.getState()))&#x2F;&#x2F; dispath 一个 actionstore.dispatch(&#123; type: &#39;INCREMENT&#39; &#125;)</code></pre><h4 id="简化的数据流"><a href="#简化的数据流" class="headerlink" title="简化的数据流"></a>简化的数据流</h4><img src="https://i.loli.net/2020/11/09/UscH6njLXxCVDvu.png" alt="fiber" style="zoom:50%;" /><p>以上的数据流简化了 combineReducers 等过程</p><h4 id="简易-redux"><a href="#简易-redux" class="headerlink" title="简易 redux"></a>简易 redux</h4><p>可以看出 redux 实际上就是一个发布订阅模式，简易版实现如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const createStore &#x3D; (reducer) &#x3D;&gt; &#123;  let state  &#x2F;&#x2F; 订阅的回调  let listeners &#x3D; []  &#x2F;&#x2F; 获取 state  const getState &#x3D; () &#x3D;&gt; &#123;    return state  &#125;  const dispatch &#x3D; (action) &#x3D;&gt; &#123;    &#x2F;&#x2F; 更新 state    state &#x3D; reducer(state, action)    &#x2F;&#x2F; 一旦 dispatch 就执行所有订阅的回调    listeners.forEach((listener) &#x3D;&gt; listener())  &#125;  const subscribe &#x3D; (listener) &#x3D;&gt; &#123;    &#x2F;&#x2F; 收集回调    listeners.push(listener)    return () &#x3D;&gt; &#123;      &#x2F;&#x2F; 取消订阅      listeners &#x3D; listeners.filter((l) &#x3D;&gt; l !&#x3D;&#x3D; listener)    &#125;  &#125;  return &#123;    getState,    dispatch,    subscribe,  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>告别魔法数字</title>
      <link href="/2020/09/12/%E5%91%8A%E5%88%AB%E9%AD%94%E6%B3%95%E6%95%B0%E5%AD%97/"/>
      <url>/2020/09/12/%E5%91%8A%E5%88%AB%E9%AD%94%E6%B3%95%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>在以往的开发中往往会出现类似以下的代码</p> <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if(status &#x3D;&#x3D;&#x3D; 1) &#123;   &#x2F;&#x2F; do something&#125; else if(status &#x3D;&#x3D;&#x3D; 2) &#123;   &#x2F;&#x2F; do something&#125; else if (status &#x3D;&#x3D;&#x3D; 3) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><p>上面代码中的 <code>1</code>，<code>2</code>，<code>3</code>就是所谓的魔法数字，即没有注释的情况下我们很难知道 1，2，3 代表的到底是什么 status。</p><a id="more"></a><h4 id="常量对象"><a href="#常量对象" class="headerlink" title="常量对象"></a>常量对象</h4><p>在 javascript 中，我们可以将这些数字维护在一个常量对象中</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const STATUS &#x3D; &#123;  ERROR: 1,  NORMAL: 2,  SUCCESS: 3&#125;</code></pre><p>使用时就可以使用 STATUS.ERROR 来替换掉 1。</p><p>这样可以很清晰就分清楚 1，2，3 这些数值对应的是什么含义。同时如果将来 ERROR 不再是 1，我们也只需要维护 STATUS 即可。</p><h4 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h4><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>而在 TypeScript 中，我们则可以使用枚举类型来维护这些数值。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">enum STATUS &#123;  ERROR &#x3D; 1,  NORMAL,  SUCCESS&#125;</code></pre><p>使用时同样是 STATUS.ERROR 替换掉 1 即可。</p><p>关于 enums 的使用<a href="https://www.tslang.cn/docs/handbook/enums.html">文档</a>里描述的已经很清楚，这里不再赘述。</p><h4 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h4><p>值得一提的是 enums 提供了常量对象不具备的反向映射（value<code>-&gt;</code>name ）。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const STATUS &#x3D; &#123;  ERROR: 1,  NORMAL: 2,  SUCCESS: 3&#125;&#x2F;&#x2F; 输出：&quot;ERROR&quot;STATUS[1]</code></pre><p>这是因为 ts 将上述的 enums 编译成以下代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var STATUS;(function (STATUS) &#123;  STATUS[STATUS[&quot;ERROR&quot;] &#x3D; 1] &#x3D; &quot;ERROR&quot;;  STATUS[STATUS[&quot;NORMAL&quot;] &#x3D; 2] &#x3D; &quot;NORMAL&quot;;  STATUS[STATUS[&quot;SUCCESS&quot;] &#x3D; 3] &#x3D; &quot;SUCCESS&quot;;&#125;)(STATUS || (STATUS &#x3D; &#123;&#125;));</code></pre><p>⚠️ 但如果是字符串枚举成员则不会生成反向映射。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">enum STATUS &#123;  ERROR &#x3D; &quot;1&quot;,  NORMAL &#x3D; &quot;2&quot;,  SUCCESS &#x3D; &quot;3&quot;&#125;&#x2F;&#x2F; 编译后var STATUS;(function (STATUS) &#123;  STATUS[&quot;ERROR2&quot;] &#x3D; &quot;1&quot;;  STATUS[&quot;NORMAL&quot;] &#x3D; &quot;2&quot;;  sSTATUS[&quot;SUCCESS&quot;] &#x3D; &quot;3&quot;;&#125;)(STATUS || (STATUS &#x3D; &#123;&#125;));</code></pre><p>并且对于重复定义的枚举类型，将会合并成员：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">enum STATUS &#123;  ERROR &#x3D; 1,&#125;enum STATUS &#123;  NORMAL &#x3D; 2,&#125;&#x2F;&#x2F; 等效于enum STATUS &#123;  ERROR &#x3D; 1,  NORMAL &#x3D; 2,&#125;</code></pre><h4 id="const-枚举"><a href="#const-枚举" class="headerlink" title="const 枚举"></a>const 枚举</h4><p>关于枚举，还有一种不是常见的写法</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const enum STATUS &#123;  ERROR &#x3D; 1,&#125;</code></pre><p>即声明前有个关键字 const。</p><p>与常规枚举不同的地方在于</p><ol><li>const 枚举不会编译出额外的代码</li></ol><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const enum STATUS &#123;  ERROR &#x3D; 1,&#125;console.log(STATUS.ERROR)&#x2F;&#x2F; 最终的编译出的代码不包含 STATUSconsole.log(1 &#x2F;* ERROR *&#x2F;);</code></pre><ol start="2"><li>也正因为编译阶段就会确定下枚举的成员，const 枚举不可以包含计算成员</li></ol><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const geterror &#x3D; () &#x3D;&gt; 3const enum STATUS &#123;  &#x2F;&#x2F; In &#39;const&#39; enum declarations member initializer must be constant expression.  ERROR &#x3D; geterror()&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 泛型组件</title>
      <link href="/2020/09/08/React%20%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/09/08/React%20%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>场景：封装一个 antd 的 Radio 组件时，需要从父组件获取到 value 的类型。其 props 接口定义如下</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface CustomRadioProps&lt;ValueType&gt; &#123;  options: Option&lt;ValueType&gt;[];  value: ValueType;  onChange: (value: ValueType) &#x3D;&gt; void;&#125;</code></pre><p>使用时这里假设传进去的是个 number 类型</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;CustomRadio&lt;number&gt;  onChange&#x3D;&#123;handleTypeChange&#125;  options&#x3D;&#123;[    &#123;      label: &#39;1&#39;,      value: 1,    &#125;,    &#123;      label: &#39;1&#39;,      value: 2,    &#125;,  ]&#125;  value&#x3D;&#123;1&#125;&#x2F;&gt;</code></pre><p>那么这个 CustomRadioProps 称为泛型组件。</p><p>那么如何定义一个泛型组件？</p><a id="more"></a><h4 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h4><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">class CustomRadio&lt;T&gt; extends React.Component&lt;Props&lt;T&gt;&gt; &#123; &#x2F;&#x2F; ...&#125;</code></pre><h4 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h4><p>对于用 function 声明的函数式组件实际上于泛型函数是一样的写法：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function CustomRadio&lt;T&gt;(props: IProps&lt;T&gt;) &#123;&#x2F;&#x2F; ...&#125;</code></pre><p>然而对于用箭头函数不可以这么写：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const CustomRadio: React.FunctionComponent&lt;IProps&lt;T&gt;&gt; &#x3D; props &#x3D;&gt; &#123; &#x2F;*...*&#x2F; &#125; </code></pre><p>箭头函数组件正确的写法：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const IconRadioGroup &#x3D; &lt;T extends any&gt;(props: IProps&lt;T&gt;) &#x3D;&gt; &#123;&#x2F;&#x2F; ...&#125;</code></pre><p>这里 T 必须要使用 extends, 用 <code>T extends any</code> 来表明接收任意类型，如果只能 number 或者 string类型，则改成  <code>T extends number｜string</code> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js获取后缀名</title>
      <link href="/2020/09/02/js%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/"/>
      <url>/2020/09/02/js%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Code Review 的时候看到小伙伴提交了一段用于提取文件拓展名的代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 截取图片后缀信息&#x2F;&#x2F; example: &#39;www.baidu.com&#x2F;somepic.jpg?h&#x2F;w&#x2F;&#39;&#x2F;&#x2F; return: &#39;.jpg&#39;const getExtension &#x3D; (url &#x3D; &#39;&#39;) &#x3D;&gt; &#123;  const end &#x3D; url.indexOf(&#39;?&#39;) || undefined;  const start &#x3D; url.lastIndexOf(&#39;.&#39;, end);  return url.substring(start, end);&#125;;</code></pre><p>这种写法固然没错，那么是否有别的写法嘞?</p><a id="more"></a><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const getExtension &#x3D; (url &#x3D; &#39;&#39;) &#x3D;&gt; &#123;  const extensionName &#x3D; url.split(&#39;.&#39;).pop()  return extensionName ? &#96;.$&#123;extensionName&#125;&#96; : &#39;&#39;&#125;</code></pre><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>正则表达式</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const getExtension &#x3D; (url &#x3D; &#39;&#39;) &#x3D;&gt; &#123;  const matches &#x3D; url.match(&#x2F;.*(\.[^?]+)&#x2F;)  return matches ? matches[1] : &#39;&#39;&#125;</code></pre><p>可能有些同学对正则不太熟悉，以下对这个正则做一下解释：</p><ol><li><code>.*</code>： . 表示非换行符号， * 用于消耗尽可能多的字符</li><li><code>()</code> 括号表示捕获组，这里 <code>()</code> 中的表达式就是用于捕获后缀名。</li><li><code>\.</code> 表示 . 的转义</li><li><code>[^\?+]</code>: ^ 表示非， + 表示一个或者多个。因此 <code>[^?+]</code> 即表示非 ？的多个字符</li></ol><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>如果是在 node 的环境，本地的文件名可以通过 path 模块提供的 extname 获取：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const &#123; extname &#125; &#x3D; require(&#39;path&#39;)console.log(extname(&#39;some-pic.jpg&#39;))&#x2F;&#x2F; .jpg</code></pre><p>那如果是远程地址呢？可以通过 url 模块得到 pathname 之后再用 extname 来获取：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const &#123; extname &#125; &#x3D; require(&#39;path&#39;)const &#123; parse &#125; &#x3D; require(&#39;url&#39;);const getExtension &#x3D; (url &#x3D; &#39;&#39;) &#x3D;&gt; extname(parse(url).pathname)</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript中的const断言</title>
      <link href="/2020/08/26/TypeScript%E4%B8%AD%E7%9A%84const%E6%96%AD%E8%A8%80/"/>
      <url>/2020/08/26/TypeScript%E4%B8%AD%E7%9A%84const%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近在使用 ant design 的 Table 组件，遇到一个问题，定义 Table 的 columns 属性如下：</p><a id="more"></a><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const columns: ColumnProps&lt;MyRecord&gt;[] &#x3D; [&#123;  title: &#39;ID&#39;,  dataIndex: &#39;id&#39;,  align: &#39;center&#39;,&#125;]</code></pre><p>此时 TS 提示：</p><pre class="line-numbers language-none"><code class="language-none">Types of property &#39;align&#39; are incompatible.        Type &#39;string&#39; is not assignable to type &#39;&quot;right&quot; | &quot;left&quot; | &quot;center&quot; | undefined&#39;.  TS2322</code></pre><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>经过查看代码发现， ColumnProps 的 align 属性的实际继承自 ColumnSharedType：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface ColumnSharedType&lt;RecordType&gt; &#123;    &#x2F;&#x2F; ...    align?: AlignType;&#125;export declare type AlignType &#x3D; &#39;left&#39; | &#39;center&#39; | &#39;right&#39;;</code></pre><p>也就是 column 中的 align 的类型为 string，而 string 无法 cast 到 AlignType。即：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type AlignType &#x3D; &#39;left&#39; | &#39;center&#39; | &#39;right&#39;;let align: AlignType | undefinedlet myAlign &#x3D; &quot;center&quot;&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;&quot;left&quot; | &quot;right&quot; | &quot;center&quot; | undefined&#39;.ts(2322)align &#x3D; myAlign</code></pre><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>TypeScript 3.4 版本以上提供了 const 断言，可以通过 as const 来消除以上报错：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const columns: ColumnProps&lt;MyRecord&gt;[] &#x3D; [&#123;  title: &#39;ID&#39;,  dataIndex: &#39;id&#39;,  align: &#39;center&#39; as const,&#125;]</code></pre><h4 id="const-assertions"><a href="#const-assertions" class="headerlink" title="const assertions"></a>const assertions</h4><p>以下内容翻译自 <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-4-rc/">https://devblogs.microsoft.com/typescript/announcing-typescript-3-4-rc/</a> 中的 <code>const</code> assertions。(翻译不动的地方会贴上原文)</p><p>当声明一个可变的变量或者属性时，TypeScript 经常拓宽值以确保我们可以在不写明确切的类型的情况下进行赋值。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let x &#x3D; &quot;hello&quot;;&#x2F;&#x2F; 我们可以给 x 赋值x &#x3D; &quot;world&quot;;</code></pre><p>严格来说，每一个字面量都有其字面类型。上面的 x 在类型推断时，由 <code>&quot;hello&quot;</code> 类型转为更为 widen 的 <code>string</code> 类型。</p><p>相对而言，如果 x 原始字面量类型为 “hello”， 那么我们就无法将 x 赋值为 “world”:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let x: &quot;hello&quot; &#x3D; &quot;hello&quot;;&#x2F;&#x2F; error!x &#x3D; &quot;world&quot;;</code></pre><p>上面的情况看起来比较极端，但是在一些情况下比较有用的，例如，我们经常创建一个联合属性的对象：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Shape &#x3D;    | &#123; kind: &quot;circle&quot;, radius: number &#125;    | &#123; kind: &quot;square&quot;, sideLength: number &#125;function getShapes(): readonly Shape[] &#123;    let result &#x3D; [        &#123; kind: &quot;circle&quot;, radius: 100, &#125;,        &#123; kind: &quot;square&quot;, sideLength: 50, &#125;,    ];        &#x2F;&#x2F; Some terrible error message because TypeScript inferred    &#x2F;&#x2F; &#39;kind&#39; to have the type &#39;string&#39; instead of    &#x2F;&#x2F; either &#39;&quot;circle&quot;&#39; or &#39;&quot;square&quot;&#39;.    return result;&#125;</code></pre><p>可修改性是 TypeScript 断定什么时候 widen 类型的重要因素，而非分析所有代码。（Mutability is one of the best heuristics of intent which TypeScript can use to determine when to widen (rather than analyzing our entire program).）</p><p>正如上述例子，不幸的是，JavaScript 中的属性默认可修改。这意味着经常会有不必要的 widen 类型，我们需要在特定的地方对类型进行确切的声明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getShapes(): readonly Shape[] &#123;  &#x2F;&#x2F; This explicit annotation gives a hint  &#x2F;&#x2F; to avoid widening in the first place.  let result: readonly Shape[] &#x3D; [  &#123; kind: &quot;circle&quot;, radius: 100, &#125;,  &#123; kind: &quot;square&quot;, sideLength: 50, &#125;,  ];  return result;&#125;</code></pre><p>上述的方法可以解决问题，但是当数据结构越来越复杂的时候，这种方式将会显的笨重。</p><p>为了解决这个问题，TypeScript 3.4 为字面值引入了 const 断言。它的语法是一种类型断言，例如 <code>123 as const</code>。当我们这么使用的时候，意味着：</p><ol><li>字面量类型不会被 widen，如不会从 “hello” 变成 string</li><li>对象字面量的属性值为只读</li><li>数组字面量变成只读元组</li></ol><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Type &#39;10&#39;let x &#x3D; 10 as const;&#x2F;&#x2F; Type &#39;readonly [10, 20]&#39;let y &#x3D; [10, 20] as const;&#x2F;&#x2F; Type &#39;&#123; readonly text: &quot;hello&quot; &#125;&#39;let z &#x3D; &#123; text: &quot;hello&quot; &#125; as const;</code></pre><p>在 tsx 文件以外，还可以这么使用：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Type &#39;10&#39;let x &#x3D; &lt;const&gt;10;&#x2F;&#x2F; Type &#39;readonly [10, 20]&#39;let y &#x3D; &lt;const&gt;[10, 20];&#x2F;&#x2F; Type &#39;&#123; readonly text: &quot;hello&quot; &#125;&#39;let z &#x3D; &lt;const&gt;&#123; text: &quot;hello&quot; &#125;;</code></pre><p>This feature often means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Works with no types referenced or declared.&#x2F;&#x2F; We only needed a single const assertion.function getShapes() &#123;    let result &#x3D; [        &#123; kind: &quot;circle&quot;, radius: 100, &#125;,        &#123; kind: &quot;square&quot;, sideLength: 50, &#125;,    ] as const;        return result;&#125;for (const shape of getShapes()) &#123;    &#x2F;&#x2F; Narrows perfectly!    if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;        console.log(&quot;Circle radius&quot;, shape.radius);    &#125;    else &#123;        console.log(&quot;Square side length&quot;, shape.sideLength);    &#125;&#125;</code></pre><p>注意上面无需类型声明，const 断言允许 ts 使用最精确的表达式类型。</p><h5 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h5><p>需要注意的是，const 断言只能使用在简单的字面表达式：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Error!&#x2F;&#x2F;   A &#39;const&#39; assertion can only be applied to a string, number, boolean, array, or object literal.let a &#x3D; (Math.random() &lt; 0.5 ? 0 : 1) as const;&#x2F;&#x2F; Works!let b &#x3D; Math.random() &lt; 0.5 ?    0 as const :    1 as const;</code></pre><p>另外需要注意的是，const 不会将表达式转变为完全不可变：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">et arr &#x3D; [1, 2, 3, 4];let foo &#x3D; &#123;    name: &quot;foo&quot;,    contents: arr,&#125;;foo.name &#x3D; &quot;bar&quot;;   &#x2F;&#x2F; error!foo.contents &#x3D; [];  &#x2F;&#x2F; error!foo.contents.push(5); &#x2F;&#x2F; ...works!</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不变的承诺 Promise</title>
      <link href="/2020/08/25/%E4%B8%8D%E5%8F%98%E7%9A%84%E6%89%BF%E8%AF%BA%20Promise/"/>
      <url>/2020/08/25/%E4%B8%8D%E5%8F%98%E7%9A%84%E6%89%BF%E8%AF%BA%20Promise/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Promise 是异步编程的一种解决方案，可以解决前端的回调地狱。以下根据 <a href="https://es6.ruanyifeng.com/?search=promise&x=0&y=0#docs/promise">ES6 入门</a> 简单过一下 Promise 的基础及个人的一些见解补充，同时尝试实现一个符合 PromiseA+ 规范的 Promise。</p> <a id="more"></a><h4 id="Promise-基础"><a href="#Promise-基础" class="headerlink" title="Promise 基础"></a>Promise 基础</h4><h5 id="Promise-的状态"><a href="#Promise-的状态" class="headerlink" title="Promise 的状态"></a>Promise 的状态</h5><p>Promise 只有三种状态：<code>pending</code>（进行中），<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。</p><p>Promise 的状态改变只有两种情况：</p><p><code>pending</code> 到 <code>fulfilled</code> 以及 <code>pending</code> 到 <code>rejected</code>。当状态变成  <code>fulfilled</code> 或 <code>rejected</code>时，我们就称这个 Promise  <code>resolved</code>。</p><p>⚠️ 我们通常说的 resolved 仅指代 <code>fulfilled</code>，不包括 <code>rejected</code>。</p><h5 id="构造一个-Promise"><a href="#构造一个-Promise" class="headerlink" title="构造一个 Promise"></a>构造一个 Promise</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const promise &#x3D; new Promise(function(resolve, reject) &#123;  &#x2F;&#x2F; ... some code  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;    resolve(value);  &#125; else &#123;    reject(error);  &#125;&#125;);</code></pre><h5 id="promise-then"><a href="#promise-then" class="headerlink" title="promise.then"></a>promise.then</h5><p>Promise 的实例拥有 then 方法：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">promise.then(function(value) &#123;  &#x2F;&#x2F; success&#125;, function(error) &#123;  &#x2F;&#x2F; failure&#125;);</code></pre><p>⚠️  Promise 新建后立即执行，而 then 方法则属于微任务的回调，执行时机为宏任务执行之后，具体的事件循环机制后面开新坑总结。</p><h5 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h5><p>构造 Promise 时，第一个参数 resolve 函数所接收的参数，可以是一个普通的值，也可以是一个 promise。如果接收的是一个 promise 实例，那么 promise 的状态取决于 resolve 接收的 promise 的状态：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const p1 &#x3D; new Promise(function (resolve, reject) &#123;  setTimeout(() &#x3D;&gt; reject(new Error(&#39;fail&#39;)), 3000)&#125;)const p2 &#x3D; new Promise(function (resolve, reject) &#123;  setTimeout(() &#x3D;&gt; resolve(p1), 1000)&#125;)p2  .then(result &#x3D;&gt; console.log(result))  .catch(error &#x3D;&gt; console.log(error))&#x2F;&#x2F; 3s 后输出：Error: fail</code></pre><p>这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><h5 id="resolve-与-return"><a href="#resolve-与-return" class="headerlink" title="resolve 与 return"></a>resolve 与 return</h5><p>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">new Promise((resolve, reject) &#x3D;&gt; &#123;  resolve(1);  console.log(2);&#125;).then(r &#x3D;&gt; &#123;  console.log(r);&#125;);&#x2F;&#x2F; 2&#x2F;&#x2F; 1</code></pre><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">new Promise((resolve, reject) &#x3D;&gt; &#123;  return resolve(1);  &#x2F;&#x2F; 后面的语句不会执行  console.log(2);&#125;)</code></pre><h5 id="catch"><a href="#catch" class="headerlink" title=".catch"></a>.catch</h5><ol><li><p><code>Promise.prototype.catch()</code>方法是<code>.then(null | undefined, rejection)</code>，用于指定发生错误时的回调函数。</p></li><li><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止，即错误总是会被下一个<code>catch</code>语句捕获。</p></li><li><p><code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>与 <code>catch()</code> 方法。</p></li><li><p>promise 内部的错误不会抛到外层，因此 <code>try/catch</code> 无法捕获：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">try &#123;   const p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;        throw &#39;err&#39;    &#125;)    console.log(&#39;out&#39;)&#125; catch(e) &#123;    console.log(&#39;catch you&#39;, e)&#125;&#x2F;&#x2F; out&#x2F;&#x2F; 未捕获的异常：Uncaught (in promise) err</code></pre><p>因此最好 promise 后都用 catch 来捕获。</p></li></ol><h5 id="finally"><a href="#finally" class="headerlink" title=".finally()"></a>.finally()</h5><ul><li>ES2018 引入，即不管 Promise 对象最后状态如何，都会执行的操作。</li><li><code>finally</code>方法的回调函数不接受任何参数</li></ul><h4 id="手写一个简易的-Promise"><a href="#手写一个简易的-Promise" class="headerlink" title="手写一个简易的 Promise"></a>手写一个简易的 Promise</h4><p>手写一个符合 PromiseA+ 规范的 Promise 并不简单，可以先简单根据上述 promise 的基本功能实现一个<strong>简易版本</strong>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const PENDING &#x3D; &#39;pending&#39;const RESOLVED &#x3D; &#39;resolved&#39;const REJECTED &#x3D; &#39;rejected&#39;class MyPromise &#123;  constructor(fn) &#123;    this.state &#x3D; PENDING    &#x2F;&#x2F; 收集 .then 中的 resolve 的回调函数    this.resolveCallbacks &#x3D; []    &#x2F;&#x2F; 收集 .then 中的 reject 的回调函数    this.rejectCallbacks &#x3D; []    &#x2F;&#x2F; resolve(result)    this.result &#x3D; null    &#x2F;&#x2F; reject(reason)    this.reason &#x3D; null    &#x2F;&#x2F; 由于 fn 有可能异常，需要捕获    try &#123;      &#x2F;&#x2F; Promise 一实例化就执行传入的 fn      &#x2F;&#x2F; 注意此处将函数当作参数传入，需要 bind 绑定上下文      &#x2F;&#x2F; 或者 resolve &#x2F; reject 用箭头函数实现      fn(this.resolve.bind(this), this.reject.bind(this))    &#125; catch (error) &#123;      this.reject(error)    &#125;  &#125;  resolve(result) &#123;    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      &#x2F;&#x2F; 修改状态      this.state &#x3D; RESOLVED      this.result &#x3D; result      &#x2F;&#x2F; 执行 then 中的 resolve 回调函数      this.resolveCallbacks.forEach((cb) &#x3D;&gt; cb(result))    &#125;  &#125;  reject(reason) &#123;    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      &#x2F;&#x2F; 修改状态      this.state &#x3D; REJECTED      this.reason &#x3D; reason      &#x2F;&#x2F; 执行 then 中的 reject 回调函数      this.rejectCallbacks.forEach((cb) &#x3D;&gt; cb(reason))    &#125;  &#125;  then(onFulfilled, onRejected) &#123;    &#x2F;&#x2F; 调用 .then 时如果还在 pending 则将回调先存起来，等待 resolve 后执行    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      &#x2F;&#x2F; 收集回调      this.resolveCallbacks.push(onFulfilled)      this.rejectCallbacks.push(onRejected)    &#125;    &#x2F;&#x2F; 如果调用 .then 时已经 resolve &#x2F; reject, 那么直接执行对应的回调    if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;      onFulfilled(this.result)    &#125;    if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;      onRejected(this.reason)    &#125;  &#125;&#125;</code></pre><p>测试代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const myPromise &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;  setTimeout(() &#x3D;&gt; &#123;    resolve(&#39;resolved&#39;)  &#125;, 3000)&#125;)myPromise.then(  (result) &#x3D;&gt; &#123;    console.log(result)  &#125;,  (reason) &#x3D;&gt; &#123;    console.log(reason)  &#125;)</code></pre><p>Promise 的设计思路实际上就是观察者模式：收集回调函数，触发通知，依次执行回调。</p><p>上述版本还未能达到 Promise / A+ 的规范，比如 链式调用 等。</p><h4 id="符合-Promise-A-的-Promise"><a href="#符合-Promise-A-的-Promise" class="headerlink" title="符合 Promise / A+ 的 Promise"></a>符合 Promise / A+ 的 Promise</h4><p>参考 <a href="https://promisesaplus.com/">Promise / A+</a> ，以下还需要补充下面几点：</p><ol><li>then 方法的参数可选</li><li><code>onFulfilled</code> 和 <code>onRejected</code>是异步执行的，可以使用如 <code>setTimeout</code> 或 <code>setImmediate</code> 之类的“宏任务”机制，或者使用诸如 <code>MutationObserver</code> 或 <code>process.nextTick</code> 之类的“微任务”机制来实现。</li><li>链式调用 与 promise 解决步骤</li></ol><h5 id="值穿透"><a href="#值穿透" class="headerlink" title="值穿透"></a>值穿透</h5><p>针对 then 的参数可选这一点，如果 <code>onFulfilled</code>  和 <code>onRejectd</code> 不是函数，则会被忽略，并且将值传递给下一个 then。即所谓的值穿透，对 <code>then</code> 进行改造:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">then(onFulfilled, onRejected) &#123;  &#x2F;&#x2F; 如果不是函数，传递 result    onFulfilled &#x3D;      typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : (result) &#x3D;&gt; result  &#x2F;&#x2F; 如果不是函数，抛出 reason    onRejected &#x3D;      typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39;        ? onRejected        : (reason) &#x3D;&gt; &#123;            throw reason          &#125;  &#x2F;&#x2F; ... if (this.state &#x3D;&#x3D;&#x3D; PENDING) ... &#125;</code></pre><p>当然当前的简易版 promise 还不支持链式调用，值穿透也就无从谈起。</p><h5 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h5><p>在实现链式调用之前，我们完善代码，使得<code>onFulfilled</code> 和 <code>onRejected</code>是异步执行的。</p><p>当前执行以下代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var myPromise &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;  resolve(1)&#125;)myPromise.then(  (val) &#x3D;&gt; &#123;    console.log(val)  &#125;,  (val) &#x3D;&gt; &#123;    console.log(val)  &#125;)console.log(2)</code></pre><p>现输出 1 再输出 2，显然不是异步的。根据 Promise/ A+ 的规范，这里我们可以通过 setTimeout 来改造 resolve 和 reject ：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; ...resolve(result) &#123;  &#x2F;&#x2F; 通过 setTimeout 模拟异步  setTimeout(() &#x3D;&gt; &#123;    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      &#x2F;&#x2F; ...    &#125;  &#125;)&#125;reject(reason) &#123;    &#x2F;&#x2F; 通过 setTimeout 模拟异步  setTimeout(() &#x3D;&gt; &#123;    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;       &#x2F;&#x2F; ...    &#125;  &#125;)&#125;&#x2F;&#x2F; ...</code></pre><p>至此，输出顺序将是 2, 1。 符合预期</p><h5 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h5><p>现在来实现链式调用：</p><ol><li><code>then</code> 需要返回一个 Promise</li><li><code>then</code> 拿到上一次 then 的返回值</li><li>如果 then 返回的是一个 Promise 则需要等待该 promise 状态发生变化后再执行下一个 then</li></ol><p>promise2: 我们将 then 返回的 promise 命名为 promise2, 即 <code>promise2 = promise1.then(onFulfilled, onRejected);</code></p><p>x: 将 onFulfilled 或者 onRejected 的返回值命名为 x，这个 x 可以是一个 thenable。</p><p>resolutionProcedure: promise 解决步骤。如果 <code>x</code> 具有 thenable 特性，我们就假设 <code>x</code> 的行为至少有点像 promise，它将试图使 promise 接收 <code>x</code> 的状态。否则，它使用值 <code>x</code> 执行 <code>promise</code>。之所以是 thenable 是为了可以兼容别的 promise（例如 fetch）。实际上这个方法在 Promise / A+ 中有很多情况分叉，我们先简化成以下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更, 否则直接resolvex instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</code></pre><p>现在的 Promise 完整代码如下，<strong>接近完全体版本</strong>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const PENDING &#x3D; &#39;pending&#39;const RESOLVED &#x3D; &#39;resolved&#39;const REJECTED &#x3D; &#39;rejected&#39;class MyPromise &#123;  constructor(fn) &#123;    this.state &#x3D; PENDING    &#x2F;&#x2F; 收集 .then 中的 resolve 的回调函数    this.resolveCallbacks &#x3D; []    &#x2F;&#x2F; 收集 .then 中的 reject 的回调函数    this.rejectCallbacks &#x3D; []    &#x2F;&#x2F; resolve(result)    this.result &#x3D; null    &#x2F;&#x2F; reject(reason)    this.reason &#x3D; null    &#x2F;&#x2F; 由于 fn 有可能异常，需要捕获    try &#123;      &#x2F;&#x2F; Promise 一实例化就执行传入的 fn      &#x2F;&#x2F; 注意此处将函数当作参数传入，需要 bind 绑定上下文      &#x2F;&#x2F; 或者 resolve &#x2F; reject 用箭头函数实现      fn(this.resolve.bind(this), this.reject.bind(this))    &#125; catch (error) &#123;      this.reject(error)    &#125;  &#125;  resolve(result) &#123;    setTimeout(() &#x3D;&gt; &#123;      if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;        &#x2F;&#x2F; 修改状态        this.state &#x3D; RESOLVED        this.result &#x3D; result        &#x2F;&#x2F; 执行 then 中的 resolve 回调函数        this.resolveCallbacks.forEach((cb) &#x3D;&gt; cb(result))      &#125;    &#125;)  &#125;  reject(reason) &#123;    setTimeout(() &#x3D;&gt; &#123;      if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;        &#x2F;&#x2F; 修改状态        this.state &#x3D; REJECTED        this.reason &#x3D; reason        &#x2F;&#x2F; 执行 then 中的 reject 回调函数        this.rejectCallbacks.forEach((cb) &#x3D;&gt; cb(reason))      &#125;    &#125;)  &#125;  then(onFulfilled, onRejected) &#123;    &#x2F;&#x2F; 如果不是函数，传递 result    onFulfilled &#x3D;      typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : (result) &#x3D;&gt; result    &#x2F;&#x2F; 如果不是函数，抛出 reason    onRejected &#x3D;      typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39;        ? onRejected        : (reason) &#x3D;&gt; &#123;            throw reason          &#125;    &#x2F;&#x2F; 调用 .then 时如果还在 pending 则将回调先存起来，等待 resolve 后执行    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      const promise2 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;        const resolvedCallBack &#x3D; () &#x3D;&gt; &#123;          try &#123;            const x &#x3D; onFulfilled(this.result)            &#x2F;&#x2F; 简化逻辑的 resolutionProcedure            x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)            &#x2F;&#x2F; resolutionProcedure(promise2, x, resolve, reject)          &#125; catch (error) &#123;            reject(error)          &#125;        &#125;        const rejectCallBack &#x3D; () &#x3D;&gt; &#123;          try &#123;            const x &#x3D; onRejected(this.result)            &#x2F;&#x2F; 简化逻辑的 resolutionProcedure            x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)            &#x2F;&#x2F; resolutionProcedure(promise2, x, resolve, reject)          &#125; catch (error) &#123;            reject(error)          &#125;        &#125;        &#x2F;&#x2F; 收集回调        this.resolveCallbacks.push(resolvedCallBack)        this.rejectCallbacks.push(onRejected)      &#125;)      return promise2    &#125;    &#x2F;&#x2F; 如果调用 .then 时已经 resolve &#x2F; reject, 那么直接执行对应的回调    if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;      onFulfilled(this.result)    &#125;    if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;      onRejected(this.reason)    &#125;  &#125;&#125;</code></pre><h5 id="resolutionProcedure"><a href="#resolutionProcedure" class="headerlink" title="resolutionProcedure"></a>resolutionProcedure</h5><p>最后根据 Promise / A+ 的规范来完善 resolutionProcedure，实际上就是一系列的判断：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const resolutionProcedure &#x3D; (promise2, x, resolve, reject) &#x3D;&gt; &#123;  if (promise2 &#x3D;&#x3D;&#x3D; x) &#123;    return reject(new TypeError(&#39;Error&#39;))  &#125;  if (x instanceof MyPromise) &#123;    x.then(function(value) &#123;        resolutionProcedure(promise2, value, resolve, reject)    &#125;, reject)&#125;  let called &#x3D; false  if (x !&#x3D;&#x3D; null &amp;&amp; (typeof x &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof x &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;    try &#123;      let then &#x3D; x.then      if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;        then.call(          x,          y &#x3D;&gt; &#123;            if (called) return            called &#x3D; true            resolutionProcedure(promise2, y, resolve, reject)          &#125;,          e &#x3D;&gt; &#123;            if (called) return            called &#x3D; true            reject(e)          &#125;        )      &#125; else &#123;        resolve(x)      &#125;    &#125; catch (e) &#123;      if (called) return      called &#x3D; true      reject(e)    &#125;  &#125; else &#123;    resolve(x)  &#125;&#125;</code></pre><h4 id="符合-Promise-A-的-Promise-1"><a href="#符合-Promise-A-的-Promise-1" class="headerlink" title="符合 Promise / A+ 的 Promise"></a>符合 Promise / A+ 的 Promise</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const PENDING &#x3D; &#39;pending&#39;const RESOLVED &#x3D; &#39;resolved&#39;const REJECTED &#x3D; &#39;rejected&#39;const resolutionProcedure &#x3D; (promise2, x, resolve, reject) &#x3D;&gt; &#123;  if (promise2 &#x3D;&#x3D;&#x3D; x) &#123;    return reject(new TypeError(&#39;Error&#39;))  &#125;  if (x instanceof MyPromise) &#123;    x.then(function (value) &#123;      resolutionProcedure(promise2, value, resolve, reject)    &#125;, reject)  &#125;  let called &#x3D; false  if (x !&#x3D;&#x3D; null &amp;&amp; (typeof x &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof x &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;    try &#123;      let then &#x3D; x.then      if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;        then.call(          x,          (y) &#x3D;&gt; &#123;            if (called) return            called &#x3D; true            resolutionProcedure(promise2, y, resolve, reject)          &#125;,          (e) &#x3D;&gt; &#123;            if (called) return            called &#x3D; true            reject(e)          &#125;        )      &#125; else &#123;        resolve(x)      &#125;    &#125; catch (e) &#123;      if (called) return      called &#x3D; true      reject(e)    &#125;  &#125; else &#123;    resolve(x)  &#125;&#125;class MyPromise &#123;  constructor(fn) &#123;    this.state &#x3D; PENDING    &#x2F;&#x2F; 收集 .then 中的 resolve 的回调函数    this.resolveCallbacks &#x3D; []    &#x2F;&#x2F; 收集 .then 中的 reject 的回调函数    this.rejectCallbacks &#x3D; []    &#x2F;&#x2F; resolve(result)    this.result &#x3D; null    &#x2F;&#x2F; reject(reason)    this.reason &#x3D; null    &#x2F;&#x2F; 由于 fn 有可能异常，需要捕获    try &#123;      &#x2F;&#x2F; Promise 一实例化就执行传入的 fn      &#x2F;&#x2F; 注意此处将函数当作参数传入，需要 bind 绑定上下文      &#x2F;&#x2F; 或者 resolve &#x2F; reject 用箭头函数实现      fn(this.resolve.bind(this), this.reject.bind(this))    &#125; catch (error) &#123;      this.reject(error)    &#125;  &#125;  resolve(result) &#123;    setTimeout(() &#x3D;&gt; &#123;      if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;        &#x2F;&#x2F; 修改状态        this.state &#x3D; RESOLVED        this.result &#x3D; result        &#x2F;&#x2F; 执行 then 中的 resolve 回调函数        this.resolveCallbacks.forEach((cb) &#x3D;&gt; cb(result))      &#125;    &#125;)  &#125;  reject(reason) &#123;    setTimeout(() &#x3D;&gt; &#123;      if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;        &#x2F;&#x2F; 修改状态        this.state &#x3D; REJECTED        this.reason &#x3D; reason        &#x2F;&#x2F; 执行 then 中的 reject 回调函数        this.rejectCallbacks.forEach((cb) &#x3D;&gt; cb(reason))      &#125;    &#125;)  &#125;  then(onFulfilled, onRejected) &#123;    &#x2F;&#x2F; 如果不是函数，传递 result    onFulfilled &#x3D;      typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : (result) &#x3D;&gt; result    &#x2F;&#x2F; 如果不是函数，抛出 reason    onRejected &#x3D;      typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39;        ? onRejected        : (reason) &#x3D;&gt; &#123;            throw reason          &#125;    &#x2F;&#x2F; 调用 .then 时如果还在 pending 则将回调先存起来，等待 resolve 后执行    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      const promise2 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;        const resolvedCallBack &#x3D; () &#x3D;&gt; &#123;          try &#123;            const x &#x3D; onFulfilled(this.result)            resolutionProcedure(promise2, x, resolve, reject)          &#125; catch (error) &#123;            reject(error)          &#125;        &#125;        const rejectCallBack &#x3D; () &#x3D;&gt; &#123;          try &#123;            const x &#x3D; onRejected(this.result)            resolutionProcedure(promise2, x, resolve, reject)          &#125; catch (error) &#123;            reject(error)          &#125;        &#125;        &#x2F;&#x2F; 收集回调        this.resolveCallbacks.push(resolvedCallBack)        this.rejectCallbacks.push(onRejected)      &#125;)      return promise2    &#125;    &#x2F;&#x2F; 如果调用 .then 时已经 resolve &#x2F; reject, 那么直接执行对应的回调    if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;      onFulfilled(this.result)    &#125;    if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;      onRejected(this.reason)    &#125;  &#125;&#125;</code></pre><p>至此我们完成了一个 符合 Promise / A+ 的 Promise，实际上 Promise 还会提供一些如 <code>.all</code>, <code>.race</code> 之类的 api，这里也实现一下。</p><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>Promise.all 接收多个 Promise 实例，返回一个新的 Promise 实例。例如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const p &#x3D; Promise.all([p1, p2, p3])</code></pre><p>上述的 p1, p2, p3 都是 Promise 实例，如果不是则会用 Promise.resolve 转成 promise。此外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><p>实现如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class MyPromise &#123;  &#x2F;&#x2F; ...  all(arr) &#123;    &#x2F;&#x2F; 用于存储返回值    let list &#x3D; []    &#x2F;&#x2F; 记录 resolve 了多少个 promise    let length &#x3D; 0    &#x2F;&#x2F; 执行 promise 的过程中是否有异常    let hasError &#x3D; false    &#x2F;&#x2F; 返回一个新的 Promise    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;      for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;        &#x2F;&#x2F; 判断元素是否为 MyPromise， 否则 resolve        const p &#x3D;          arr[i] instanceof MyPromise ? arr[i] : MyPromise.resolve(arr[i])        p.then((data) &#x3D;&gt; &#123;          list[i] &#x3D; data          length++          if (length &#x3D;&#x3D;&#x3D; arr.length) &#123;            &#x2F;&#x2F; 如果全部 promise 都 resolved            resolve(list)          &#125;        &#125;).catch((error) &#x3D;&gt; &#123;          if (!hasError) &#123;            &#x2F;&#x2F; 第一个被 reject 的实例的返回值，会传递给 p 的回调函数            reject(error)          &#125;          hasErr &#x3D; true        &#125;)      &#125;    &#125;)  &#125;  &#x2F;&#x2F; ...&#125;</code></pre><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const p &#x3D; Promise.race([p1, p2, p3]);</code></pre><p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class MyPromise &#123;  &#x2F;&#x2F; ...  race(arr) &#123;    &#x2F;&#x2F; 是否有结果    let hasResult &#x3D; false    &#x2F;&#x2F; 返回一个新的 Promise    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;      for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;        &#x2F;&#x2F; 判断元素是否为 MyPromise， 否则 resolve        const p &#x3D;          arr[i] instanceof MyPromise ? arr[i] : MyPromise.resolve(arr[i])        p.then((data) &#x3D;&gt; &#123;          if (!hasResult) &#123;            resolve(data)          &#125;          hasResult &#x3D; true        &#125;).catch((error) &#x3D;&gt; &#123;          if (!hasResult) &#123;            reject(error)          &#125;          hasResult &#x3D; true        &#125;)      &#125;    &#125;)  &#125;  &#x2F;&#x2F; ...&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svg 图片的上传下载</title>
      <link href="/2020/08/17/svg%20%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2020/08/17/svg%20%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近有个需求：</p><ol><li>根据传入的 code 生成条形码 svg 图片</li><li>将 svg 图片上传至 cdn</li><li>展示图片时需要点击按钮后保存至本地</li></ol><a id="more"></a><h4 id="生成条形码"><a href="#生成条形码" class="headerlink" title="生成条形码"></a>生成条形码</h4><p>这里借助一个开源的仓库</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import JsBarcode from &#39;jsbarcode&#39;;const generateBarcode &#x3D; async (barcode, options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;  &#x2F;&#x2F; 创建一个 svg 元素  const svg &#x3D; document.createElementNS(&#39;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&#39;, &#39;svg&#39;);  &#x2F;&#x2F; 甚至宽高  svg.setAttribute(&#39;width&#39;, &#96;$&#123;width&#125;px&#96;);  svg.setAttribute(&#39;height&#39;, &#96;$&#123;height&#125;px&#96;);  &#x2F;&#x2F; 生成条形码 svg 的图片  JsBarcode(svg, barcode, options);  return svg&#125;</code></pre><h4 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h4><h5 id="svg-转-canvas"><a href="#svg-转-canvas" class="headerlink" title="svg 转 canvas"></a>svg 转 canvas</h5><p>由于服务端同学提供的接口只支持 canvas，因此首先要将 svg 转成 canvas：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const svgToCanvas &#x3D; (svg) &#x3D;&gt; &#123;  &#x2F;&#x2F; svg.outerHTML 获取 svg 元素的 html 字符串  &#x2F;&#x2F; btoa 将 svg 转成 base64const href &#x3D; &#96;data:image&#x2F;svg+xml;base64,$&#123;window.btoa(    unescape(encodeURIComponent(svg.outerHTML)),  )&#125;&#96;;  &#x2F;&#x2F; 构建一个 Image  const img &#x3D; new Image();  img.width &#x3D; width;  img.height &#x3D; height;    img.onload &#x3D; () &#x3D;&gt; &#123;    &#x2F;&#x2F; 构建一个 canvas    const canvas &#x3D; document.createElement(&#39;canvas&#39;);    const ctx &#x3D; canvas.getContext(&#39;2d&#39;);    ctx.fillRect(0, 0, width, height);    &#x2F;&#x2F; 将 图片画到 canvas 中    ctx.drawImage(img, 0, 0, width, height);    &#x2F;&#x2F; 转成 jpeg 的 base64 const dataURI &#x3D; canvas.toDataURL(&#39;image&#x2F;jpeg&#39;);    &#x2F;&#x2F; 上传    upload(dataURI);  &#125;   img.src &#x3D; href;&#125;</code></pre><h5 id="Data-URL"><a href="#Data-URL" class="headerlink" title="Data URL"></a>Data URL</h5><p>通过 `canvas.toDataURL 将 canvas 转成 Data URL，一段 Data URL 由 4 个部分组成：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;&#x2F;&#x2F; 例如： &quot;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC&quot;</code></pre><h5 id="Base64的解码与编码"><a href="#Base64的解码与编码" class="headerlink" title="Base64的解码与编码"></a>Base64的解码与编码</h5><p><code>atob()</code> 函数能够解码通过base-64编码的字符串数据。</p><p><code>btoa()</code> 函数能够从二进制数据“字符串”创建一个base-64编码的ASCII字符串。</p><h5 id="Base64-转-Blob"><a href="#Base64-转-Blob" class="headerlink" title="Base64 转 Blob"></a>Base64 转 Blob</h5><p>上传图片文件需要将 base64 转成 Blob 对象，有两种方法：</p><p>######Base64 转 Blob 第一种方法：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function dataURItoBlob(dataURI: string) &#123;  &#x2F;&#x2F; 通过 atob 转回 string  const byteString &#x3D; atob(dataURI.split(&#39;,&#39;)[1]);  &#x2F;&#x2F; 获得文件类型  const mimeString &#x3D; dataURI.split(&#39;,&#39;)[0].split(&#39;:&#39;)[1].split(&#39;;&#39;)[0];  &#x2F;&#x2F; 转成   const ab &#x3D; new ArrayBuffer(byteString.length);  const ia &#x3D; new Uint8Array(ab);  for (let i &#x3D; 0; i &lt; byteString.length; i++) &#123;    ia[i] &#x3D; byteString.charCodeAt(i);  &#125;&#x2F;&#x2F; 转成 blob  const bb &#x3D; new Blob([ab], &#123; type: mimeString &#125;);  return bb;&#125;</code></pre><p> 思路：</p><ol><li>拆解 data uri，通过 atob 将 base64 解码成字符串</li><li>拆解 data uri，获得图片的格式</li><li>创建一个 arraybuffer</li><li>通过TypedArray（这里使用 Uint8Array）将字符串的内容写入 arraybuffer </li><li>将 array buffer 转成 blob</li></ol><h6 id="Base64-转-Blob-第二种方法："><a href="#Base64-转-Blob-第二种方法：" class="headerlink" title="Base64 转 Blob 第二种方法："></a>Base64 转 Blob 第二种方法：</h6><p>通过 <code>fetch</code> 将 dataURI 转成 blob：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const bb &#x3D; await fetch(dataURI).then((res) &#x3D;&gt; res.blob())</code></pre><h5 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h5><p>构造 FormData 上传图片文件：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const upload &#x3D; (dataURI: string) &#x3D;&gt; &#123;  &#x2F;&#x2F; 创建form对象const formData &#x3D; new FormData();  &#x2F;&#x2F; 通过 append 向 form 对象添加数据  formData.append(&#39;file&#39;, dataURItoBlob(dataURI));  const &#123; data &#125; &#x3D; await axios.post(&#39;&#x2F;api&#x2F;upload&#39;, formData, &#123;    headers: &#123;      &#39;Content-Type&#39;: &#39;multipart&#x2F;form-data&#39;,      &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;,    &#125;,  &#125;);&#125;</code></pre><h5 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h5><p>保存图片到本地：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const download &#x3D; (fileUrl, name) &#x3D;&gt; &#123;  const x &#x3D; new XMLHttpRequest();  x.open(&#39;GET&#39;, fileUrl, true);  x.responseType &#x3D; &#39;blob&#39;;  x.onload &#x3D; () &#x3D;&gt; &#123;    &#x2F;&#x2F; 转为 objectUrl    const url &#x3D; window.URL.createObjectURL(x.response);    &#x2F;&#x2F; 构建一个 a 标签    const a &#x3D; document.createElement(&#39;a&#39;);    a.href &#x3D; url;    a.download &#x3D; name;    a.click();  &#125;;  x.send();&#125;;</code></pre><p>利用 a 标签的 download 属性可以实现图片的下载，但是有个限制是 href 必须是同源的地址，否则无法下载。</p><p>因此这里通过 get 请求获得图片的 Blob 格式，并用 window.URL.createObjectURL 将 Blob 转成 objectUrl 解决了跨域问题。之后就可以用 a 标签的 download 属性下载文件。</p><h4 id="补充几个概念"><a href="#补充几个概念" class="headerlink" title="补充几个概念"></a>补充几个概念</h4><h5 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h5><p>上传图片时，我们实现了一个函数 dataURItoBlob， 通过这个函数来将 base64 转为 Blob，最终上传给接口的 formData 中的 file 也是一个 Blob 对象。</p><p>什么是 Blob 对象？</p><blockquote><p>一个 <strong>Blob</strong>对象表示一个不可变的, 原始数据的类似文件对象。Blob 表示的不一定是JavaScript原生格式的数据。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File"><code>File</code></a> 接口基于<code>Blob</code>，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p></blockquote><p>Blob 属于 web 提供的 api，因此 mdn 上说的 Blob 表示的不一定是JavaScript原生格式的数据。</p><h5 id="File"><a href="#File" class="headerlink" title="File"></a>File</h5><p>File 继承自 Blob，可以看作是特殊的 Blob。常见的获得 File 对象的方法有 <code>input</code> 标签上选择文件后返回的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileList"><code>FileList</code></a> 对象。</p><h5 id="Blob-转-URL"><a href="#Blob-转-URL" class="headerlink" title="Blob 转 URL"></a>Blob 转 URL</h5><p>在下载时，我们通过 get 请求获得了图片的 blob 格式，之后通过 URL.createObjectURL 转成 objectUrl，这样就可以像普通的 url，赋值给 img 的 src 属性或者 a 标签的 href 属性。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码层面解读Vue响应式原理</title>
      <link href="/2020/08/11/%E6%BA%90%E7%A0%81%E5%B1%82%E9%9D%A2%E8%A7%A3%E8%AF%BBVue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2020/08/11/%E6%BA%90%E7%A0%81%E5%B1%82%E9%9D%A2%E8%A7%A3%E8%AF%BBVue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在 Vue（以下均指的是 2.x 版本） 中，数据模型仅仅是普通的 JavaScript 对象，当你修改它们时，视图会进行更新，这就是 Vue 的响应式系统，其设计模式就是观察者模式。</p><a id="more"></a><h4 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h4><p>以下为阅读源码时，对响应式实现原理的理解，为了思路更清晰，仅考虑最简单的情况，并且可能会省略或修改部分代码。</p><p>首先，顺着 vue 的生命周期开始：</p><h5 id="beforeCreate-与-created"><a href="#beforeCreate-与-created" class="headerlink" title="beforeCreate 与 created"></a>beforeCreate 与 created</h5><p>首先 在 _init 方法中执行 beforeCreate 与 created ：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Vue.prototype._init &#x3D; function (options?: Object) &#123;  &#x2F;&#x2F; ...  callHook(vm, &#39;beforeCreate&#39;)  &#x2F;&#x2F; ...  initState(vm)  &#x2F;&#x2F; ...  callHook(vm, &#39;created&#39;)  &#x2F;&#x2F; ...&#125;</code></pre><p>记住这里执行了一个方法： <code>initState</code></p><p>#####initState</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export function initState (vm: Component) &#123;&#x2F;&#x2F; 略：...初始化 props，methods 等  if (opts.data) &#123;    initData(vm)  &#125; else &#123;    observe(vm._data &#x3D; &#123;&#125;, true &#x2F;* asRootData *&#x2F;)  &#125;  &#x2F;&#x2F; 略：...初始化 computed，watch 等&#125;</code></pre><p>这里的 initData 代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function initData (vm: Component) &#123;  &#x2F;&#x2F; 略：...将 data 的每个属性都挂在 vm 上,这样可以通过 this.xx 直接访问到  &#x2F;&#x2F; observe data  observe(data, true &#x2F;* asRootData *&#x2F;)&#125;</code></pre><p>记住 <code>observe</code> 这个方法。</p><h5 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h5><p><code>observe</code>  用于创建一个 observer 实例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;  let ob: Observer | void  &#x2F;&#x2F; 判断是否已经 observe 过，是的话直接返回  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) &#123;    &#x2F;&#x2F; observer 最终会挂在 value 的 __ob__ 属性上，因此可以这么判断是否  observe 过，详情看 Observer 的代码    ob &#x3D; value.__ob__  &#125; else if (...) &#123;    &#x2F;&#x2F; 否则满足一系列条件的情况下就会重新实例化一个 observer    ob &#x3D; new Observer(value)  &#125;  return ob&#125;</code></pre><p>实例化  observer 的过程中实际上会将传入对象的每个属性通过 <code>defineReactive</code> 方法转成响应式：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export class Observer &#123;  constructor (value: any) &#123;    this.value &#x3D; value    &#x2F;&#x2F; 初始化数据模型的 dep 实例    this.dep &#x3D; new Dep()    &#x2F;&#x2F; observer 最终会挂在 value 的 __ob__ 属性上    def(value, &#39;__ob__&#39;, this)    if (Array.isArray(value)) &#123;      &#x2F;&#x2F; 略：...重写 value 的一些数组方法      &#x2F;&#x2F; 略：...遍历数组元素并 observe    &#125; else &#123;      this.walk(value)    &#125;  &#125;    walk (obj: Object) &#123;    const keys &#x3D; Object.keys(obj)    for (let i &#x3D; 0; i &lt; keys.length; i++) &#123;       &#x2F;&#x2F; 遍历传入的每个属性，并用 defineReactive 转成响应式      defineReactive(obj, keys[i])    &#125;  &#125;&#125;</code></pre><h5 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h5><p>上面代码中最核心的一个函数是 <code>defineReactive</code>，做了以下几件事情：</p><ol><li>初始化目标属性的 dep 实例，这实际上是一个发布者</li><li>对该属性的子对象递归调用 observe</li><li>通过<code>Object.defineProperty</code>劫持该属性的 getter 与 setter：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export function defineReactive (  obj: Object,  key: string,  val: any,) &#123;  &#x2F;&#x2F; 初始化目标属性的 dep 实例  const dep &#x3D; new Dep()&#x2F;&#x2F; 略：... 一些容错判断  &#x2F;&#x2F; 略：... 一些初始化    &#x2F;&#x2F; 递归 observe  let childOb &#x3D; !shallow &amp;&amp; observe(val)  &#x2F;&#x2F; 劫持 get 与 set  Object.defineProperty(obj, key, &#123;    enumerable: true,    configurable: true,    get: function reactiveGetter () &#123;      &#x2F;&#x2F; ...一旦获取该属性就会进行依赖收集    &#125;,    set: function reactiveSetter (newVal) &#123;      &#x2F;&#x2F; ...一旦设置了新值就会派发更新    &#125;  &#125;)&#125;</code></pre><p>这里就用到了观察者模式：当这个属性更新时，会通过发布者通知到观察者，这些观察者收到通知后更新视图。这里发布者实际上是<code>Dep</code> 实例，观察者实际上是 <code>Watcher</code> 实例，它的 <code>update</code> 方法可以更新视图。</p><p>所以，依赖收集实际上就是将<code>Wathcer</code> 实例添加到 <code>Dep</code> 实例的观察者列表。</p><p>reactiveGetter 和 reactiveSetter 这两个方法的具体实现我们先放一边，这里只需要知道大概的作用即可，后面会详细介绍。我们现在来看看什么时候会触发 get 呢？答案是在挂载组件的时候。</p><h5 id="beforeMount-与-mounted"><a href="#beforeMount-与-mounted" class="headerlink" title="beforeMount 与 mounted"></a>beforeMount 与 mounted</h5><p>然后是在 mountComponent 中执行  beforeMount 以及 mounted：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export function mountComponent (  vm: Component,  el: ?Element,  hydrating?: boolean): Component &#123;  &#x2F;&#x2F; ...  callHook(vm, &#39;beforeMount&#39;)  &#x2F;&#x2F; 略：...这里有个非生产环境的判断，这里不考虑简化成如下：  let updateComponent &#x3D; () &#x3D;&gt; &#123;      vm._update(vm._render(), hydrating)   &#125;  &#x2F;&#x2F; 这里实例化 Watcher：可以看作是更新视图用的观察者，这里省略一些参数  new Watcher(vm, updateComponent)  &#x2F;&#x2F; ...仅考虑 new Vue 的情况，代码简化如下  callHook(vm, &#39;mounted&#39;)  return vm&#125;</code></pre><p>挂载组件的时候就会实例化一个 <code>Watcher</code></p><h5 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h5><p>当我们实例化 Watcher 的时候：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let uid &#x3D; 0export default class Watcher &#123;  constructor (    vm: Component,    expOrFn: string | Function,  ) &#123;    &#x2F;&#x2F; 略：...一些初始化    this.deps &#x3D; []    this.newDeps &#x3D; []    this.depIds &#x3D; new Set()    this.newDepIds &#x3D; new Set()    &#x2F;&#x2F; 略：...一些初始化    &#x2F;&#x2F; 略：...对 this.getter 的一些初始化    if (this.computed) &#123;      &#x2F;&#x2F; computed 的情况，本文暂不考虑    &#125; else &#123;      &#x2F;&#x2F; 初始化时就会执行 get 方法      this.value &#x3D; this.get()    &#125;  &#125;  get () &#123;    &#x2F;&#x2F; pushTarget 用于将 watcher 实例挂到 Dep 的 target 这个静态属性上    pushTarget(this)    let value    const vm &#x3D; this.vm    try &#123;      &#x2F;&#x2F; 此时的 this.getter 实际上就是 updateComponent      value &#x3D; this.getter.call(vm, vm)    &#125; catch (e) &#123;      &#x2F;&#x2F; 略：...错误处理    &#125; finally &#123;      &#x2F;&#x2F; 略：...递归访问 value，触发它所有子项的 getter      this.cleanupDeps()    &#125;    return value  &#125;  &#x2F;&#x2F; ...&#125;</code></pre><p><code>pushTarget</code> 将 <code>watcher</code> 实例挂到 <code>Dep</code> 的 <code>target</code> 这个静态属性, 用于 <code>Dep</code> 内部可以访问到：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function pushTarget (_target: ?Watcher) &#123;&#x2F;&#x2F; ...  Dep.target &#x3D; _target&#125;</code></pre><p>接着调用 <code>this.getter</code>, 这里的 <code>this.getter</code> 实际上就是 <code>updateComponent</code>:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">vm._update(vm._render(), hydrating)</code></pre><p><code>vm._render()</code> 会生成 VNode，这个过程会访问 vm 上的数据，至此就会触发数据对象的 getter，进行依赖收集。</p><h5 id="思路小结"><a href="#思路小结" class="headerlink" title="思路小结"></a>思路小结</h5><p>至此我们先梳理一下这一整个过程，以免遗忘：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">beforeCreate &#x3D;&gt; initState -&gt; observe -&gt; new Observer  -&gt; defineReactive：实例化 Dep，劫持对象属性 getter 与 setter&#x3D;&gt; created&#x3D;&gt; beforeMount  实例化 Watcher -&gt; 将 watcher 实例绑定到 Dep.target，并触发对象属性的 getter，收集依赖&#x3D;&gt; mounted&#x3D;&gt; 当数据模型变更时，触发 setter，更新视图</code></pre><p>在 defineReactive 中有个关键的步骤是实例化 <code>Dep</code>。</p><h5 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h5><p>上面说过 Dep 实例是一个发布者，其代码其实很简单：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default class Dep &#123;  constructor () &#123;    this.subs &#x3D; []  &#125;    addSub (sub: Watcher) &#123;    this.subs.push(sub)  &#125;  removeSub (sub: Watcher) &#123;    remove(this.subs, sub)  &#125;  depend () &#123;    if (Dep.target) &#123;      &#x2F;&#x2F; 这里将 Dep.target 即 watcher 添加到 subs 里      Dep.target.addDep(this)    &#125;  &#125;  notify () &#123;    &#x2F;&#x2F; 发布通知    const subs &#x3D; this.subs.slice()    for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123;      subs[i].update()    &#125;  &#125;&#125;</code></pre><p>我们最终调用的是 <code>depend</code>方法来添加观察者，即<code>Dep.target.addDep</code>，我们知道此时 Dep.target 实际上就是 watcher 实例。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; ...addDep (dep: Dep) &#123;  const id &#x3D; dep.id  if (!this.newDepIds.has(id)) &#123;    &#x2F;&#x2F; 将发布者 id 添加到 this.newDepIds    this.newDepIds.add(id)    &#x2F;&#x2F; 将发布者 添加到 this.newDeps    this.newDeps.push(dep)    if (!this.depIds.has(id)) &#123;      &#x2F;&#x2F; 如果旧的 发布者id 列表中没有这个发布者 id，那么就添加到发布者的观察者列表中      dep.addSub(this)    &#125;  &#125;&#125;&#x2F;&#x2F; ...</code></pre><p>而在 watcher 中，最终还是调用了传入的 dep 实例的 addSub 来添加到 dep 的观察者列表中。之所以这么设计，其原因是为了能在 watcher 中维护一个自己订阅的发布者列表。</p><p>那么 watcher 中的发布者列表有什么用呢？还记得 Watcher 实例化的最后会调用  <code>this.cleanupDeps()</code> 吗？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cleanupDeps () &#123;  let i &#x3D; this.deps.length  while (i--) &#123;    const dep &#x3D; this.deps[i]    if (!this.newDepIds.has(dep.id)) &#123;      dep.removeSub(this)    &#125;  &#125;  let tmp &#x3D; this.depIds  this.depIds &#x3D; this.newDepIds  this.newDepIds &#x3D; tmp  this.newDepIds.clear()  tmp &#x3D; this.deps  this.deps &#x3D; this.newDeps  this.newDeps &#x3D; tmp  this.newDeps.length &#x3D; 0&#125;</code></pre><p>这个函数实际上的作用是：</p><ol><li><p>如果无需再观察，则从发布者的观察者列表中移除</p></li><li><p>将本次的发布者 id 列表记录在 this.depsIds 中，清空 this.newDepIds</p></li><li><p>将本次的发布者列表记录在 this.deps 中，清空 this.newDeps</p><p>那么具体是如何将对象属性转为响应式的呢，我们看看其具体实现：</p></li></ol><h5 id="reactiveGetter"><a href="#reactiveGetter" class="headerlink" title="reactiveGetter"></a>reactiveGetter</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function reactiveGetter () &#123;  &#x2F;&#x2F; ...  &#x2F;&#x2F; 此时的 Dep.target 就是 watcher，关于 Dep 后面会详细解释  if (Dep.target) &#123;    &#x2F;&#x2F; 这里会将 watcher 实例添加进 dep 的 subs 中维护，即收集依赖    dep.depend()    if (childOb) &#123;      &#x2F;&#x2F; 子对象的依赖收集      childOb.dep.depend()      &#x2F;&#x2F; 略：...对数组的一些处理    &#125;  &#125;  &#x2F;&#x2F; 返回属性值  return value&#125;</code></pre><h5 id="reactiveSetter"><a href="#reactiveSetter" class="headerlink" title="reactiveSetter"></a>reactiveSetter</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function reactiveSetter (newVal) &#123;  &#x2F;&#x2F; value：属性值  const value &#x3D; ...  &#x2F;&#x2F; 略：...一些判断是否触发 setter 的条件  if (setter) &#123;    setter.call(obj, newVal)  &#125; else &#123;    val &#x3D; newVal  &#125;  &#x2F;&#x2F; 设置新值后需要重新 observe  childOb &#x3D; !shallow &amp;&amp; observe(newVal)  &#x2F;&#x2F; 发布通知  dep.notify()&#125;</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文简化了一些细节，但是 Vue 的响应式原理大致如此。当理解了原理之后，如果后面遗忘了的话，以下为重要的记忆点：</p><ol><li>observe：实例化 Observe，参数为数据模型，实例化过程会调用遍历对象属性调用 defineReactive</li><li>defineReactive：实例化 Dep，劫持对象属性的 getter 与 setter，getter 时进行依赖收集</li><li>在挂载组件的时候，会实例化 Watcher，此时会触发 getter</li><li>当更新对象属性时，会调用 Dep 实例的 notify，触发 watcher 的 update</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-JS中的观察者模式与发布订阅模式</title>
      <link href="/2020/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在上一篇文章《debounce与throttle》 中提到了 RxJS， RxJS 中有两个重要的概念: Observable（可被观察者） 和 Observer（观察者），RxJS 的 Observable 就是观察者模式和迭代器模式的组合。</p><p>在 javascript 中，观察者模式和发布订阅模式极为相似，因此本文将探讨这两种模式以及其应用。</p> <a id="more"></a><h4 id="观察者模式（Observer-pattern）"><a href="#观察者模式（Observer-pattern）" class="headerlink" title="观察者模式（Observer pattern）"></a>观察者模式（Observer pattern）</h4><blockquote><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 —— Graphic Design Patterns</p></blockquote><p>观察者模式有两个对象：一个是观察者，另一个上面提到的目标对象可以称为是发布者，基本的流程为：</p><ol><li>发布者维护一个观察者列表，可以添加或者删除观察者</li><li>当发布者发布通知时，遍历观察者列表，并调用观察者提供的方法</li></ol><p>发布者的实现如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 发布者class Publisher &#123;  constructor() &#123;    &#x2F;&#x2F; 维护一个观察者列表    this.observers &#x3D; []      &#125;      &#x2F;&#x2F; 添加观察者  addObserver(observer) &#123;    this.observers.push(observer)  &#125;  &#x2F;&#x2F; 移除观察者  removeObserver(observer) &#123;    this.observers &#x3D; this.observers.filter(item &#x3D;&gt; item !&#x3D;&#x3D; observer)  &#125;  &#x2F;&#x2F; 发布通知  notify() &#123;    this.observers.forEach((item) &#x3D;&gt; &#123;      &#x2F;&#x2F; 执行观察者提供的方法，这里假设为 update      item.update()    &#125;)  &#125;&#125;</code></pre><p>订阅者则比较简单，实现如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Observer &#123;  constructor(name) &#123;    this.name &#x3D; name  &#125;  update() &#123;    &#x2F;&#x2F; 更新状态    console.log(&#96;observer $&#123;this.name&#125; update&#96;)  &#125;&#125;</code></pre><p>最终：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const a &#x3D; new Observer(&#39;a&#39;)const b &#x3D; new Observer(&#39;b&#39;)const c &#x3D; new Observer(&#39;c&#39;)const publisher &#x3D; new Publisher()publisher.addObserver(a)publisher.addObserver(b)publisher.addObserver(c)&#x2F;&#x2F; 发布通知publisher.notify()&#x2F;&#x2F; a b c</code></pre><p>Vue 的响应式原理就是观察者模式的一个典型应用，关于 Vue 的响应式由于篇幅原因，将会另起一篇详细分析。</p><h4 id="发布订阅模式（Pub-sub-pattern）"><a href="#发布订阅模式（Pub-sub-pattern）" class="headerlink" title="发布订阅模式（Pub-sub pattern）"></a>发布订阅模式（Pub-sub pattern）</h4><p>发布订阅模式是从观察者模式发展而来，两者的区别在于：观察者模式中发布者与观察者是松耦合，而发布订阅则在发布者与订阅者中加入了事件中心实现发布者与观察者的完全解耦。</p><p>用发布订阅模式模拟事件绑定：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class EventCenter &#123;  constructor() &#123;    this.observers &#x3D; &#123;&#125;  &#125;  addListener(type, fn) &#123;    this.observers[type] &#x3D; [...(this.observers[type] || []), fn]  &#125;  removeListener(type, fn) &#123;    let listeners &#x3D; this.observers[type];    if (!listeners || !listeners.length) return;    this.observers[type] &#x3D; listeners.filter(v &#x3D;&gt; v !&#x3D;&#x3D; fn);  &#125;  dispatchEvent(type) &#123;    let listeners &#x3D; this.observers[type];    if (!listeners || !listeners.length) return;    listeners.forEach(fn &#x3D;&gt; fn());          &#125;&#125;const evtCenter &#x3D; new EventCenter()function handleClick () &#123;  console.log(&#39;click&#39;)&#125;&#x2F;&#x2F; 订阅 click 事件evtCenter.addListener(&#39;click&#39;, handleClick)&#x2F;&#x2F; 发布 click 事件evtCenter.dispatchEvent(&#39;click&#39;)&#x2F;&#x2F; 取消订阅evtCenter.removeListener(&#39;click&#39;, handleClick)</code></pre><p>可以看到与观察者模式不同，在发布订阅模式中，我们的发布和订阅都是通过事件中心来进行调度的。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debounce与throttle</title>
      <link href="/2020/08/06/debounce%E4%B8%8Ethrottle/"/>
      <url>/2020/08/06/debounce%E4%B8%8Ethrottle/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>测试同学提了个 bug，在搜索框中疯狂输入文字，不一会儿接口就报错了。这个 bug 实际上就是由于每输入一个字符时，就去请求接口引起的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const handleSearch &#x3D; () &#x3D;&gt; &#123;&#x2F;&#x2F; ...请求接口&#125;&lt;Input onChange&#x3D;&#123;handleSearch&#125; &#x2F;&gt;</code></pre><p>解决方法是通过 <code>debounce</code> 来控制输入的频率。</p><p>实际上 <code>debounce</code> 和 <code>throttle</code> 这两个概念经常是一起出现，在工作中也常常使用到。在早年接触前端的时候，项目里有 <code>lodash</code>，因此直接使用其提供的  <code>debounce</code> 和 <code>throttle</code> 。而在一些简单的项目里，往往不引入 <code>lodash</code>，这个时候就需要自己实现，于此做个记录。</p><a id="more"></a><h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><p><code>debounce</code> 也就是防抖，看看 lodash 中 debounce 的定义：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">_.debounce(func, [wait&#x3D;0], [options&#x3D;&#123;&#125;])</code></pre><p>返回一个函数，该函数会距离上次调用后，延迟 <code>wait</code> 毫秒后调用<code>func</code>。</p><p>在上面的 bug 中，对原搜索方法进行防抖处理后，仅当用户停止输入 300 毫秒后，才请求接口进行搜索：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 停止输入 300 ms 后，进行搜索_.debounce(handleSearch, 300)</code></pre><p>####throttle</p><p><code>throttle</code> 我们称之为截流，同样看看 loads 中 throttle 的定义：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">_.throttle(func, [wait&#x3D;0], [options&#x3D;&#123;&#125;])</code></pre><p>返回一个函数，该函数最多每 <code>wait</code> 毫秒调用一次 <code>func</code>。</p><p>如果对搜索方法进行截流，则无论用户输入多快，每 1 秒仅请求一次：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 停止输入 300 ms 后，进行搜索_.debounce(handleSearch, 1000)</code></pre><h4 id="手写一个-debounce"><a href="#手写一个-debounce" class="headerlink" title="手写一个 debounce"></a>手写一个 debounce</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function debounce(func, wait &#x3D; 0) &#123;  let timeout  return function(...args) &#123;    if(timeout) &#123;      clearTimeout(timeout)    &#125;    timeout &#x3D; setTimeout(() &#x3D;&gt; func.call(this, ...args), wait)  &#125;&#125;</code></pre><p>由于 func 被当作是参数传递进来，注意上面的 func 需要绑定 this。并且在使用时如果有 this 指向，需要显式指明 this，如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const o &#x3D; &#123;  a: 1,  b: function() &#123;      console.log(this.a);  &#125;&#125;const c &#x3D; debounce(o.b).bind(o);</code></pre><p>对 debounce 进一步拓展，如果需要在调用时立刻执行一次，则可以：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function debounce(func, wait &#x3D; 0, head) &#123;  let timeout;  return function (...args) &#123;    const callNow &#x3D; head &amp;&amp; !timeout;    timeout &amp;&amp; clearTimeout(timeout);    timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;      if(!callNow) &#123;        func.call(this, ...args);      &#125;      timeout &#x3D; null    &#125;, wait);    if (callNow) &#123;      func.call(this, ...args)    &#125;;  &#125;;&#125;</code></pre><h4 id="手写一个-throttle"><a href="#手写一个-throttle" class="headerlink" title="手写一个 throttle"></a>手写一个 throttle</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function throttle(func, timeFrame &#x3D; 0) &#123;  let lastTime &#x3D; 0;  return function () &#123;      const now &#x3D; new Date();      if (now - lastTime &gt;&#x3D; timeFrame) &#123;          func.call(this, ...args);          lastTime &#x3D; now;      &#125;  &#125;;&#125;</code></pre><h4 id="what’s-more-rxjs"><a href="#what’s-more-rxjs" class="headerlink" title="what’s more: rxjs"></a>what’s more: rxjs</h4><p>截流和防抖很多时候是出现在事件中的，使用 rxjs 则可以使用 debounceTime 和 throttleTime：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; fromEvent &#125; from &#39;rxjs&#39;;import &#123; debounceTime &#125; from &#39;rxjs&#x2F;operators&#39;;const inputEle &#x3D; document.getElementById(&#39;input&#39;)const inputs &#x3D; fromEvent(inputEle, &#39;input&#39;);const result &#x3D; inputs.pipe(debounceTime(1000));&#x2F;&#x2F; 如果是节流可使用 throttleTime&#x2F;&#x2F; const result &#x3D; inputs.pipe(throttleTime(1000));result.subscribe(x &#x3D;&gt; console.log(x));</code></pre><h4 id="rxjs-react"><a href="#rxjs-react" class="headerlink" title="rxjs + react"></a>rxjs + react</h4><p>如果是 react 中的事件需要防抖，那么可以通过 <code>Subject</code> 来实现：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;import &quot;rxjs&#x2F;add&#x2F;operator&#x2F;debounceTime&quot;;const value$ &#x3D; new Subject().debounceTime(300);export default function App() &#123;  useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; value$.subscribe(console.log)      return () &#x3D;&gt; subscription.unsubscribe()  &#125;, [])  const onChange &#x3D; e &#x3D;&gt; &#123;    value$.next(e.target.value);  &#125;;  return (    &lt;div&gt;      &lt;input onChange&#x3D;&#123;onChange&#125; &#x2F;&gt;    &lt;&#x2F;div&gt;  );&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当我们说到打包时，我们在说什么</title>
      <link href="/2020/07/31/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E5%88%B0%E6%89%93%E5%8C%85%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/31/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E5%88%B0%E6%89%93%E5%8C%85%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>从早期的 grunt (我接触前端开发的时候这个已经趋于没落) 到 gulp，再到如今的 webpack，rollup ，parcel，以及 snowpack，vite，如今的前端已经脱离了刀耕火种的时代，各种打包工具层出不穷。前端项目基本离不开打包这个过程。那么当我们说到打包（bundle）时，我们在说的是什么？</p><p>这里不对 webpack 或者这些打包工具的使用进行具体说明，本文想探究的是打包的本质。</p><a id="more"></a><h4 id="从模块化说起"><a href="#从模块化说起" class="headerlink" title="从模块化说起"></a>从模块化说起</h4><p>在没有模块化之前，前端开发时需要格外注意命名冲突以及文件之间的相互依赖，参考 <a href="https://github.com/seajs/seajs/issues/547#issue-11105836。">https://github.com/seajs/seajs/issues/547#issue-11105836。</a></p><p>模块化实际上就是将程序分解成离散的功能块，使代码易于复用，维护和测试。如 less 中通过 @import 引入的样式，ES6 Module / CommonJs 引入的 Js 等都可以称为模块。</p><p>然而浏览器不支持模块化，因此我们需要一个打包工具，将代码中诸如 require, @import, import 进来的模块打包成一个或者多个文件(即 bundle)。</p><h4 id="打包的本质"><a href="#打包的本质" class="headerlink" title="打包的本质"></a>打包的本质</h4><p>参考 webpack 的定义：</p><blockquote><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p></blockquote><p>而至于这个过程中，对代码进行压缩，混淆等等则是锦上添花的功能。</p><h4 id="打包的过程"><a href="#打包的过程" class="headerlink" title="打包的过程"></a>打包的过程</h4><p>这里以 webpack 为例：</p><ol><li>初始化：从配置文件和 Shell 语句中读取并合并配置参数</li><li>开始编译：根据上面得到的参数初始化 Compiler，加载插件（Plugins），执行 Compiler 的 run 方法开始编译</li><li>入口文件：配置的 entry</li><li>从入口文件开始，针对不同的模块使用对应的 Loader 编译，再找到该模块所依赖的模块，递归这个步骤</li><li>完成编译：经过上述步骤后得到每个模块编译后的内容以及相互之间的依赖关系</li><li>输出：根据依赖关系，将模块组合成一个个代码块（Chunk），最后输出成文件</li></ol><h4 id="实现一个简易的打包工具"><a href="#实现一个简易的打包工具" class="headerlink" title="实现一个简易的打包工具"></a>实现一个简易的打包工具</h4><p>参考 <a href="https://github.com/ronami">ronami</a>/<strong><a href="https://github.com/ronami/minipack">minipack</a></strong> 实现一个支持 ES Module 的简易打包工具（这里不考虑循环依赖等情况）：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const fs &#x3D; require(&#39;fs&#39;)const path &#x3D; require(&#39;path&#39;)const babylon &#x3D; require(&#39;babylon&#39;)const traverse &#x3D; require(&#39;babel-traverse&#39;).defaultconst &#123; transformFromAst &#125; &#x3D; require(&#39;babel-core&#39;)</code></pre><p>引入上述相关依赖：</p><ul><li>babylon：生成 AST（抽象语法树）</li><li>babel-traverse：来分析文件的依赖</li><li>transformFromAst：将 AST 转为 ES5</li></ul><p><strong>首先</strong> 定义一个函数用于读取文件的内容和依赖：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * 读取文件内容和依赖 *&#x2F;function createAsset(filePath) &#123;&#x2F;&#x2F; 读取文件内容  const content &#x3D; fs.readFileSync(filePath, &#39;utf-8&#39;)  &#x2F;&#x2F; 生成 AST  const ast &#x3D; babylon.parse(content, &#123;    sourceType: &#39;module&#39;,  &#125;)  &#x2F;&#x2F; 当前文件的依赖关系  const dependencies &#x3D; []  traverse(ast, &#123;    &#x2F;&#x2F; 当遇到导入的声明时，将其内容 push 到 dependencies 里    ImportDeclaration: (&#123; node &#125;) &#x3D;&gt; &#123;      dependencies.push(node.source.value)    &#125;,  &#125;)  &#x2F;&#x2F; 将 AST 转为 ES5  const &#123; code &#125; &#x3D; transformFromAst(ast, null, &#123;    presets: [&#39;env&#39;],  &#125;)  return &#123;    filePath,    dependencies,    code,  &#125;&#125;</code></pre><p>Asset 接口如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Assets &#123;&#x2F;&#x2F; 文件路径  filePath: string;  &#x2F;&#x2F; 文件的依赖  dependencies: string[];  &#x2F;&#x2F; 转为 ES5 后的文件内容  code: string;  &#x2F;&#x2F; 相对路径  relativePath?: string;&#125;</code></pre><p>例如，我们现在有个文件 entry.js ，内容如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; entry.jsimport a from &#39;.&#x2F;a.js&#39;console.log(a)</code></pre><p>运行 <code>createAsset(&#39;./entry.js&#39;)</code> 将会返回：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;  filePath: &#39;.&#x2F;entry.js&#39;,  dependencies: [ &#39;.&#x2F;a.js&#39; ],  code: &#96;&quot;use strict&quot;;var _a &#x3D; require(&quot;.&#x2F;a.js&quot;);var _a2 &#x3D; _interopRequireDefault(_a);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;console.log(_a2.default);&#96;&#125;</code></pre><p><strong>接着</strong>定义一个函数用于构建依赖关系图( dependency graph )：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * 构建依赖关系图 *&#x2F;function createGraph(entry) &#123;  &#x2F;&#x2F; 从入口文件开始  const entryAsset &#x3D; createAsset(entry);  &#x2F;&#x2F; 初始时，queue 中只有 entryAsset, 之后分析依赖关系，会将新的 Asset push 到 queue 中用于分析，直到分析完全部依赖  const queue &#x3D; [entryAsset]  &#x2F;&#x2F; 遍历所有文件依赖关系  for (const asset of queue) &#123;    &#x2F;&#x2F; 获得文件目录    const dirname &#x3D; path.dirname(asset.filePath)    &#x2F;&#x2F; 遍历当前文件依赖关系    asset.dependencies.forEach((relativePath) &#x3D;&gt; &#123;      &#x2F;&#x2F; 获得绝对路径      const absolutePath &#x3D; path.join(dirname, relativePath)      const childAsset &#x3D; createAsset(absolutePath)      childAsset.relativePath &#x3D; relativePath      &#x2F;&#x2F; 将当前文件所依赖的文件的 Asset 也 push 到 queue 中用于遍历      queue.push(childAsset)    &#125;)  &#125;  return queue&#125;</code></pre><p>例如，在上面的基础上，有个 a.js 以及 b.js 文件, 运行 <code>createGraph</code>会返回：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; a.jsimport b from &#39;.&#x2F;b.js&#39;const a &#x3D; &#39;1&#39;export default a&#x2F;&#x2F; b.jsconst b &#x3D; &#39;2&#39;export default b&#x2F;&#x2F; createGraph(&#39;.&#x2F;entry.js&#39;)[  &#123;    filePath: &#39;.&#x2F;entry.js&#39;,    dependencies: [ &#39;.&#x2F;a.js&#39; ],    code: &#96;&quot;use strict&quot;;var _a &#x3D; require(&quot;.&#x2F;a.js&quot;);var _a2 &#x3D; _interopRequireDefault(_a);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;console.log(_a2.default);&#96;  &#125;,  &#123;    filePath: &#39;a.js&#39;,    dependencies: [ &#39;.&#x2F;b.js&#39; ],    code: &#96;&quot;use strict&quot;;Object.defineProperty(exports, &quot;__esModule&quot;, &#123;  value: true&#125;);var _b &#x3D; require(&quot;.&#x2F;b.js&quot;);var _b2 &#x3D; _interopRequireDefault(_b);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;var a &#x3D; &#39;1&#39;;exports.default &#x3D; a;&#96;,    relativePath: &#39;.&#x2F;a.js&#39;  &#125;,  &#123;    filePath: &#39;b.js&#39;,    dependencies: [],    code: &#96;&quot;use strict&quot;;Object.defineProperty(exports, &quot;__esModule&quot;, &#123;  value: true&#125;);var b &#x3D; &#39;2&#39;;exports.default &#x3D; b;&#96;,    relativePath: &#39;.&#x2F;b.js&#39;  &#125;]</code></pre><p><strong>最后</strong>实现一个打包函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function bundle(entry) &#123;  const graph &#x3D; createGraph(entry)  let modules &#x3D; &#39;&#39;  &#x2F;&#x2F; 构建函数参数  graph.forEach((mod) &#x3D;&gt; &#123;    const filePath &#x3D; mod.relativePath || entry    &#x2F;&#x2F; 拼装成 modules    modules +&#x3D; &#96;&#39;$&#123;filePath&#125;&#39;: (      function (module, exports, require) &#123; $&#123;mod.code&#125; &#125;    ),&#96;  &#125;)  &#x2F;&#x2F; 最终结果  const result &#x3D; &#96;    (function(modules) &#123;&#x2F;&#x2F; ast 转 es5 的代码是 commonjs 风格，而浏览器不支持 commonjs，因此自定义 require，以文件名作为 id      function require(id) &#123;        const module &#x3D; &#123; exports : &#123;&#125; &#125;        modules[id](module, module.exports, require)        return module.exports      &#125;&#x2F;&#x2F; 引入入口文件代码      require(&#39;$&#123;entry&#125;&#39;)    &#125;)(&#123;$&#123;modules&#125;&#125;)  &#96;  &#x2F;&#x2F; 当生成的内容写入到文件中  fs.writeFileSync(&#39;.&#x2F;bundle.js&#39;, result)&#125;　</code></pre><p>最终输出一个 IIFE：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">;(function (modules) &#123;  function require(id) &#123;    const module &#x3D; &#123; exports: &#123;&#125; &#125;    modules[id](module, module.exports, require)    return module.exports  &#125;  require(&#39;.&#x2F;entry.js&#39;)&#125;)(&#123;  &#39;.&#x2F;entry.js&#39;: function (module, exports, require) &#123;    &#39;use strict&#39;    var _a &#x3D; require(&#39;.&#x2F;a.js&#39;)    var _a2 &#x3D; _interopRequireDefault(_a)    function _interopRequireDefault(obj) &#123;      return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;    &#125;    console.log(_a2.default)  &#125;,  &#39;.&#x2F;a.js&#39;: function (module, exports, require) &#123;    &#39;use strict&#39;    Object.defineProperty(exports, &#39;__esModule&#39;, &#123;      value: true,    &#125;)    var _b &#x3D; require(&#39;.&#x2F;b.js&#39;)    var _b2 &#x3D; _interopRequireDefault(_b)    function _interopRequireDefault(obj) &#123;      return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;    &#125;    var a &#x3D; &#39;1&#39;    exports.default &#x3D; a  &#125;,  &#39;.&#x2F;b.js&#39;: function (module, exports, require) &#123;    &#39;use strict&#39;    Object.defineProperty(exports, &#39;__esModule&#39;, &#123;      value: true,    &#125;)    var b &#x3D; &#39;2&#39;    exports.default &#x3D; b  &#125;,&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-JS中的单例模式</title>
      <link href="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>此前项目有个 im  模块，需要用到 websocket。使用 websocket 需要建立连接：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const initWs &#x3D; () &#x3D;&gt; &#123;  const ws &#x3D; new WebSocket(&#39;wss:&#x2F;&#x2F;xxx.com&#39;);  ws.onopen(() &#x3D;&gt; &#123;    console.log(&#39;opened&#39;)  &#125;)  ws.onmessage((evt) &#x3D;&gt; &#123;    console.log(&#39;Received evt&#39;, evt.data)  &#125;)  &#x2F;&#x2F;....  return ws&#125;</code></pre><p>我们肯定不希望在每个用到 ws 的地方都重复初始化，即我们只需要一个 WebSocket 的实例。</p><a id="more"></a><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const wsA &#x3D; new SingleWs()const wsB &#x3D; new SingleWs()&#x2F;&#x2F; 有没有办法使得:wsA instanceof WebSocket &amp;&amp; wsB instanceof WebSocket &amp;&amp; wsA &#x3D;&#x3D;&#x3D; wsB</code></pre><p>那么要如何做到这一点？实际上就可以用到单例模式。下面列举几个实现的方法：</p><h4 id="使用全局变量"><a href="#使用全局变量" class="headerlink" title="使用全局变量"></a>使用全局变量</h4><p>这个可能是最容易想到的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.ws &#x3D; window.ws || initWs()</code></pre><p>将 ws 挂在 window 对象上，使用时也用 window.ws，显然这个解决方案有个问题是需要小心 window.ws 被覆盖。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包可以保持局部变量保持在内存中不被销毁，通过这个特性可以就可以避免污染全局变量，如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const SingleWs &#x3D; (function() &#123; let ws &#x3D; null; &#x2F;&#x2F; const initWs &#x3D; .... return &#123;   getWs() &#123;     if(!ws) &#123;       ws &#x3D; initWs()     &#125;     return ws   &#125;  &#125;&#125;)()const wsA &#x3D; SingleWs.getWs()const wsB &#x3D; SingleWs.getWs()console.log(wsA instanceof WebSocket &amp;&amp; wsB instanceof WebSocket &amp;&amp; wsA &#x3D;&#x3D;&#x3D; wsB)</code></pre><p>然而上面的写法也有一些缺点，如 getWs 可以被改写。</p><p>写法还可以进一步改写：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const SingleWs &#x3D; (function() &#123; let ws &#x3D; null; &#x2F;&#x2F; const initWs &#x3D; ....  return () &#x3D;&gt; &#123;    if(!ws) &#123;      ws &#x3D; initWs()    &#125;    return ws  &#125;&#125;)()&#x2F;&#x2F; 这里的 new 可以不写const wsA &#x3D; new SingleWs()const wsB &#x3D; new SingleWs()wsA instanceof WebSocket &amp;&amp; wsB instanceof WebSocket &amp;&amp; wsA &#x3D;&#x3D;&#x3D; wsB</code></pre><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>通过模块化也能实现上述的效果：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; ws.jslet ws &#x3D; null&#x2F;&#x2F; const initWs &#x3D; ....function SingleWs() &#123;  if (ws) &#123;    return ws  &#125;  ws &#x3D; initWs()  return ws&#125;export default SingleWs</code></pre><h4 id="通过-class-的静态属性来实现"><a href="#通过-class-的静态属性来实现" class="headerlink" title="通过 class 的静态属性来实现"></a>通过 class 的静态属性来实现</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class SingleWs &#123;  constructor() &#123;    if (!SingleWs.instance) &#123;      SingleWs.instance &#x3D; this.initWs()    &#125;    return SingleWs.instance  &#125;  initWs() &#123;    &#x2F;&#x2F; ...      &#125;&#125;const wsA &#x3D; new SingleWs()const wsB &#x3D; new SingleWs()console.log(wsA instanceof WebSocket &amp;&amp; wsB instanceof WebSocket &amp;&amp; wsA &#x3D;&#x3D;&#x3D; wsB)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>JS 中的单例模式：</p><ol><li>实例化时，判断是否已经存在实例。</li><li>如果不存在，则初始化，并将生成的实例存储起来。</li><li>存储的方法可以是全局变量，闭包，模块以及类的静态属性。</li><li>如果已经存在实例，那么就直接返回该实例。</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】ReactHooks-并非黑魔法，本质是数组</title>
      <link href="/2020/07/26/%E3%80%90%E8%AF%91%E3%80%91ReactHooks-%E5%B9%B6%E9%9D%9E%E9%BB%91%E9%AD%94%E6%B3%95%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B0%E7%BB%84/"/>
      <url>/2020/07/26/%E3%80%90%E8%AF%91%E3%80%91ReactHooks-%E5%B9%B6%E9%9D%9E%E9%BB%91%E9%AD%94%E6%B3%95%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本文翻译自 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">React hooks: not magic, just arrays</a>，该文章很好的阐释了 react hooks 原理，我将保持原文的意思进行翻译，如有自己感觉不清楚的地方将会在括号中注明。以下为翻译内容。</p><p>我是 hooks api 的忠实粉丝。然而 hooks 在使用时却有一些<a href="https://reactjs.org/docs/hooks-rules.html">奇怪的约束</a>。在这里，我给尝试去理解这些规则由来的人提供一个了模型，用于思考如何去使用这些新 api。</p><a id="more"></a><h4 id="hooks-的规则"><a href="#hooks-的规则" class="headerlink" title="hooks 的规则"></a>hooks 的规则</h4><p>在 <a href="https://reactjs.org/docs/hooks-rules.html">hooks proposal documentation</a> 的提纲中，React 核心团队规定了两条开发者在使用 hooks 时需要遵守的主要规则：</p><ul><li>不要在循环，条件或者是嵌套函数中使用 hooks</li><li>只能在 React Functions 中才能使用 hooks</li></ul><p>后者我认为是显而易见的。要将行为附加到函数式组件上，你需要能够以某种方式将该行为与组件关联起来。（原文为： To attach behaviour to a functional component you need to be able to associate that behaviour with the component somehow. 不太理解作者想表达的意思）</p><p>前者我认为会比较让人困惑，因为像这样使用 api 可能看起来不太自然。而这正是我今天想要探讨的内容。</p><h4 id="hooks-的状态管理都是基于数组"><a href="#hooks-的状态管理都是基于数组" class="headerlink" title="hooks 的状态管理都是基于数组"></a>hooks 的状态管理都是基于数组</h4><p>为了更清晰地理解心智模型，让我们来看一下如何实现一个简单的 hooks api。</p><p><strong>注意这只是 API 的一种可能的实现方式及猜想，用于让你理解，而非 API 真正的内部实现方式</strong></p><h4 id="我们如何实现-useState"><a href="#我们如何实现-useState" class="headerlink" title="我们如何实现 useState?"></a>我们如何实现 <code>useState</code>?</h4><p>让我们打开一个实例来演示如何实现一个 state hook。</p><p>首先，我们定义一个组件：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">function RenderFunctionComponent() &#123;  const [firstName, setFirstName] &#x3D; useState(&quot;Rudi&quot;);  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;);  return (    &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;  );&#125;</code></pre><p>这个 Hooks api 背后的思想是，你可以用 hook 函数返回的数组的第二个元素作为 setter 方法，这个 setter 方法可以控制被 hook 管理的状态。</p><h4 id="那么-React-是如何做到这个的呢？"><a href="#那么-React-是如何做到这个的呢？" class="headerlink" title="那么 React 是如何做到这个的呢？"></a>那么 React 是如何做到这个的呢？</h4><p>让我们看看这个在 React 内部是如何运作的。以下内容将在特定组件的上下文中运行。这就是说数据存储在要渲染的组件的上一层。这个 state 不与其他组件共享，但是维护在一个可以用于该组件后续渲染的作用域内。（原文：The following would work within the execution context for rendering a particular component. That means that the data stored here lives one level outside of the component being rendered. This state is not shared with other components but it is maintained in a scope that is accessible to subsequent rendering of the specific component）</p><ol><li><p>初始化</p><p>创建两个空数组：<code>setter</code> 和 <code>state</code></p><p>将指针设置为 0</p><p><img src="https://miro.medium.com/max/1280/1*LAZDuAEm7nbcx0vWVKJJ2w.png" alt="Image for post"></p></li><li><p>首次渲染</p><p>首次运行该组件。</p><p>每次调用 <code>useState</code> ，如果是首次运行，则 push 一个 setter 方法（绑定到指针的位置）到 setters 数组中，并且 push 一些 state 到 state 数组中。</p><p><img src="https://miro.medium.com/max/1260/1*8TpWnrL-Jqh7PymLWKXbWg.png" alt="Image for post"></p></li><li><p>后续渲染</p><p>每次后续渲染，指针将被重置，然后从各个数组中读取对应的值。</p><p><img src="https://miro.medium.com/max/1254/1*qtwvPWj-K3PkLQ6SzE2u8w.png" alt="Image for post"></p></li><li><p>事件处理</p><p>每一个 setter 都保存一个对应的指针位置的引用，因此触发任意一个 <code>setter</code> 都可以修改 state 数组中对应指针位置的 state。</p><p><img src="https://miro.medium.com/max/1260/1*3L8YJnn5eV5ev1FuN6rKSQ.png" alt="Image for post"></p></li></ol><h4 id="简单的实现-And-the-naive-implementation"><a href="#简单的实现-And-the-naive-implementation" class="headerlink" title="简单的实现(And the naive implementation)"></a>简单的实现(And the naive implementation)</h4><p>下面是简单的代码演示：</p><p><strong>注意：这不代表 hooks 的实际实现，但是应该能给你一个理解 hooks 工作原理的思路。这就是我为什么使用块级变量的原因（原文： That is why we are using module level vars etc）</strong></p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">let state &#x3D; [];let setters &#x3D; [];let firstRun &#x3D; true;let cursor &#x3D; 0;function createSetter(cursor) &#123;  return function setterWithCursor(newVal) &#123;    state[cursor] &#x3D; newVal;  &#125;;&#125;&#x2F;&#x2F; This is the pseudocode for the useState helperexport function useState(initVal) &#123;  if (firstRun) &#123;    state.push(initVal);    setters.push(createSetter(cursor));    firstRun &#x3D; false;  &#125;  const setter &#x3D; setters[cursor];  const value &#x3D; state[cursor];  cursor++;  return [value, setter];&#125;&#x2F;&#x2F; Our component code that uses hooksfunction RenderFunctionComponent() &#123;  const [firstName, setFirstName] &#x3D; useState(&quot;Rudi&quot;); &#x2F;&#x2F; cursor: 0  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;); &#x2F;&#x2F; cursor: 1  return (    &lt;div&gt;      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Richard&quot;)&#125;&gt;Richard&lt;&#x2F;Button&gt;      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;    &lt;&#x2F;div&gt;  );&#125;&#x2F;&#x2F; This is sort of simulating Reacts rendering cyclefunction MyComponent() &#123;  cursor &#x3D; 0; &#x2F;&#x2F; resetting the cursor  return &lt;RenderFunctionComponent &#x2F;&gt;; &#x2F;&#x2F; render&#125;console.log(state); &#x2F;&#x2F; Pre-render: []MyComponent();console.log(state); &#x2F;&#x2F; First-render: [&#39;Rudi&#39;, &#39;Yardley&#39;]MyComponent();console.log(state); &#x2F;&#x2F; Subsequent-render: [&#39;Rudi&#39;, &#39;Yardley&#39;]&#x2F;&#x2F; click the &#39;Fred&#39; buttonconsole.log(state); &#x2F;&#x2F; After-click: [&#39;Fred&#39;, &#39;Yardley&#39;]</code></pre><h4 id="为什么顺序很重要？"><a href="#为什么顺序很重要？" class="headerlink" title="为什么顺序很重要？"></a>为什么顺序很重要？</h4><p>现在如果在一个生命周期里，我们基于外部的因素或者组件状态改变了 hooks 的顺序，将会发生什么事情？</p><p>让我们试试看 react 不建议我们做的事情：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">let firstRender &#x3D; true;function RenderFunctionComponent() &#123;  let initName;  if(firstRender)&#123;    [initName] &#x3D; useState(&quot;Rudi&quot;);    firstRender &#x3D; false;  &#125;  const [firstName, setFirstName] &#x3D; useState(initName);  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;);  return (    &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;  );&#125;</code></pre><p>我们在一个条件语句中使用了 <code>useState</code>，让我们看看造成了什么样的破坏：</p><h4 id="坏组件的第一次渲染"><a href="#坏组件的第一次渲染" class="headerlink" title="坏组件的第一次渲染"></a>坏组件的第一次渲染</h4><p><img src="https://miro.medium.com/max/1270/1*C4IA_Y7v6eoptZTBspRszQ.png" alt="Image for post"></p><p>在这个时候，我们的实例变量 <code>firstName</code> 和 <code>lastName</code> 指向的正确的数据，但是我们看看第二次渲染发生了什么：</p><h4 id="坏组件的第二次渲染"><a href="#坏组件的第二次渲染" class="headerlink" title="坏组件的第二次渲染"></a>坏组件的第二次渲染</h4><p><img src="https://miro.medium.com/max/1274/1*aK7jIm6oOeHJqgWnNXt8Ig.png" alt="Image for post"></p><p>现在我们的 state 存储出现异常， <code>firstName</code> 和 <code>lastName</code> 都指向 “Rudi”。上述明显错误的操作给了我们一个思路：为什么 hooks 要如此规定。</p><blockquote><p>The React team are stipulating the usage rules because not following them will lead to inconsistent data</p></blockquote><h4 id="想想-hooks-操作一系列的数组，那么你就不会打破规则了（Think-about-hooks-manipulating-a-set-of-arrays-and-you-wont-break-the-rules）"><a href="#想想-hooks-操作一系列的数组，那么你就不会打破规则了（Think-about-hooks-manipulating-a-set-of-arrays-and-you-wont-break-the-rules）" class="headerlink" title="想想 hooks 操作一系列的数组，那么你就不会打破规则了（Think about hooks manipulating a set of arrays and you wont break the rules）"></a>想想 hooks 操作一系列的数组，那么你就不会打破规则了（Think about hooks manipulating a set of arrays and you wont break the rules）</h4><p>现在应该能很清晰理解为什么不能在条件或者循环语句中使用 <code>use</code> hook 了：因为我们使用了指针指向了数组，如果在 render 的时候改变了顺序，那么指针就不能对应正确的数据，所以调用 use 也不会指向正确的数据和 setter。</p><p>因此，诀窍就是将 hooks 想像成用恒定的指针来管理一系列数组。如果能做到这个，那么一切就能按预期进行。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>希望我已经就如何思考 hooks api 的工作原理指出了一个清晰的心智模型。（后面就偷个懒不翻译了，基本是上述观点的重复强调。）</p><p>Hopefully I have laid out a clearer mental model for how to think about what is going on under the hood with the new hooks API. Remember the true value here is being able to group concerns together so being careful about order and using the hooks API will have a high payoff.</p><p>Hooks is an effective plugin API for React Components. There is a reason why people are excited about this and if you think about this kind of model where state exists as a set of arrays then you should not find yourselves breaking the rules around their usage.</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见的安全问题汇总</title>
      <link href="/2020/07/23/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/23/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近安全部门的小伙伴提了一个前端安全的漏洞，想到前端开发过程中有时候往往追求开发效率，忽略掉一些安全问题，以下简单总结一些自己遇到过的以及一些常见的攻击手段，以自查自省。</p><a id="more"></a><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>回到安全部门提出的漏洞，场景还原如下：<br>这是一个老项目，展示文章用，页面路由为 <a href="http://xxx/article/:id?these-are-queries，node">http://xxx/article/:id?these-are-queries，node</a> 层收到这个 url 后，返回返回该文章 html，内容则包括了【推荐文章】， 而推荐文章的链接则是根据 url 的值来的，仅变化 id。此时如果在 url 上的 query 上构造一段恶意脚本，然后引导用户打开，那么用户打开页面后就会运行该恶意脚本。<br>上述正是一个典型的 XSS 攻击，定义如下：</p><blockquote><p>XSS是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p></blockquote><p>XSS 的本质是信任了某些不安全的输入，导致恶意代码混入正常代码，进而发生的攻击行为。常见的不安全输入有：</p><ol><li>上面提到的 url 参数，这种需要诱导用户取点击</li><li>用户输入的内容，比如用户发表评论</li><li>第三方的链接等</li></ol><p>防范的方法通常是：对用户输入内容和服务端返回内容进行过滤和转译。</p><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>CSRF 攻击常见的过程如下：</p><ol><li>用户登录你的网站，产生登录凭证，如 cookie</li><li>用户被<strong>诱导</strong>登录到恶意网站</li><li>恶意网站携带刚刚在浏览器产生的凭证向你的服务器发送一个恶意请求</li><li>你的服务器无法识别是否恶意请求，请求完成，用户受害。</li></ol><p>与上面提到的 XSS 攻击有个明显的区别在于：CSRF 攻击发生在恶意网站，而不是被攻击的网站。而这也使得攻击者并不能获取到受害者的登录凭证，仅仅只能使用。<br>防范的方法通常是：</p><ol><li>请求 url 添加 token 或者是在 http 请求头自定义属性进行验证</li><li>同源检测，通过解析 请求头中的 referer 判断请求来源</li><li>Samesite，Google 起草了一份草案来改进 HTTP 协议，为 Set-Cookie 响应头新增 Samesite 属性，用于标明 Cookie 是否能作用于其他网站，目前兼容性还不是很好。</li></ol><h4 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h4><p>当我们使用 iframe 加载第三方网站时，第三方网站可以对我们的网站执行恶意操作，如操作DOM，加载 js 等。<br>防范的方法是通过设置 sandbox 属性控制 iframe 的操作权限。</p><h4 id="opener"><a href="#opener" class="headerlink" title="opener"></a>opener</h4><p>我们在通常通过以下写法在 新 tab 下打开链接：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">1. &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;new-site.com&#39;&gt;2. window.open(&#39;new-site.com&#39;)</code></pre><p>上述两种写法的问题在于， <code>new-site.com</code> 是可以通过 <code>window.opener</code> 来拿到源页面的 <code>window</code> 对象，进而进行恶意操作。<br>防范的方法通常是：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">1. &lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;new-site.com&quot; rel&#x3D;&quot;noopener noreferrer nofollow&quot;&gt;a标签跳转url&lt;&#x2F;a&gt;2. function openurl(url) &#123;    var newTab &#x3D; window.open();    newTab.opener &#x3D; null;    newTab.location &#x3D; url;&#125;</code></pre><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul><li><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html">前端安全系列（一）：如何防止XSS攻击？</a></p></li><li><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">前端安全系列（二）：如何防止CSRF攻击？</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN 避坑指北</title>
      <link href="/2020/07/21/RN%20%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97/"/>
      <url>/2020/07/21/RN%20%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p>记录平时开发 rn 时遇到的问题，特指 0.59 版本，不同版本可能情况不同，仅供参考。</p><a id="more"></a><h5 id="一像素问题"><a href="#一像素问题" class="headerlink" title="一像素问题"></a>一像素问题</h5><p>rn 解决一像素很简单，只需要  <code>StyleSheet.hairlineWidth</code> 即可解决。</p><h5 id="TextInput-组件"><a href="#TextInput-组件" class="headerlink" title="TextInput  组件"></a>TextInput  组件</h5><p>自带内边距，多行文字时文字居中展示，想要消除需要设置样式如下：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;&#x2F; 文字向上对齐textAlignVertical: &#39;top&#39;&#x2F;&#x2F; 消除内边距padding: 0</code></pre><p>Placeholder 在 ios 和 android 下默认颜色表现不一致，可以通过 <code>placeholderTextColor</code>  属性进行设置：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">placeholderTextColor&#x3D;&quot;#CCCCCC&quot;</code></pre><h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><p>因为设计理念的问题，android 下几乎无法实现和 ios 一致的阴影效果。而 flutter 基于 skia 引擎渲染，应该会有比较好的表现？有空尝试下。 🤔</p><h5 id="border-虚线"><a href="#border-虚线" class="headerlink" title="border 虚线"></a>border 虚线</h5><p>border 虚线也是一个比较棘手的问题, android 上实测无效，详情看 <a href="https://github.com/facebook/react-native/issues/17251">issue</a>。解决方案是循环一个 pattern 然后 overhidden 掉，又多了一个让我想尝试 flutter 的理由 😂</p><h5 id="多行文字"><a href="#多行文字" class="headerlink" title="多行文字"></a>多行文字</h5><p>多行文字在 android 机型下有可能会出现高度不够导致文字被截掉的问题，解决方法：设置  <code>lineHeight</code></p><h5 id="实现不同字号的文字底部对齐"><a href="#实现不同字号的文字底部对齐" class="headerlink" title="实现不同字号的文字底部对齐"></a>实现不同字号的文字底部对齐</h5><p>例如 ¥500 想要 ¥ 字号小一点，而 500 字号大一点，但是需要底部对齐，则可以用 Text 包裹起来，如下：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;Text&gt;  &lt;Text style&#x3D;&#123;&#123; fontSize: 12 &#125;&#125;&gt;¥&lt;&#x2F;Text&gt;  &lt;Text style&#x3D;&#123;&#123; fontSize: 20 &#125;&#125;&gt;500&lt;&#x2F;Text&gt;&lt;&#x2F;Text&gt;</code></pre><h5 id="Text-组件样式继承"><a href="#Text-组件样式继承" class="headerlink" title="Text 组件样式继承"></a>Text 组件样式继承</h5><p>众所周知，css 如果想设置默认的全局样式相当简单，比如字体颜色默认为 ‘#323232’ , 只要在 body 上设置一下 <code>color: #323232</code> 即可 ，然而对于 RN 来说则有两种解决方案：</p><ol><li><p>将原生 Text 替换成自定义 Text 组件（官方推荐）</p><blockquote><p>The recommended way to use consistent fonts and sizes across your application is to create a component <code>MyAppText</code> that includes them and use this component across your app</p></blockquote><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React from &#39;react&#39;;import &#123; TextProps, StyleSheet, Text &#125; from &#39;react-native&#39;;const styles &#x3D; StyleSheet.create(&#123;  defaultStyle: &#123;    color: &#39;#323232&#39;,  &#125;,&#125;);export default function CustomText(props: TextProps &amp; &#123; children?: any &#125;) &#123;  const &#123; style, ...restProps &#125; &#x3D; props;  return (    &lt;Text style&#x3D;&#123;[styles.defaultStyle, style]&#125; &#123;...restProps&#125;&gt;      &#123;props.children&#125;    &lt;&#x2F;Text&gt;  );&#125;</code></pre></li><li><p>参考 <a href="https://github.com/Ajackster">Ajackster</a>/<strong><a href="https://github.com/Ajackster/react-native-global-props">react-native-global-props</a></strong> 的实现，在项目入口位置，修改组件的 render 方法。</p></li></ol><p>方案二虽然方便，但不是官方解法，万一有坑就 GG 了。而方案一如果是已有项目，则需要批量修改代码。<br>这里顺便提一下在 vscode 里批量替换的方法：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 将正则，大小写，全匹配 三个按钮点亮find: Text(,|\s)(.*react-native&#39;;)replace: $2\nimport Text from &#39;Your&#x2F;Text&#39;;</code></pre><p>一开始我是这么写的，只考虑到了单行，结果下面这种情况没有替换掉：</p><pre class="line-numbers language-none"><code class="language-none">import &#123;  StyleSheet,  ViewStyle,  View,  Text,  Image,  TouchableOpacity,&#125; from &#39;react-native&#39;;</code></pre><p>后面换成 <code>\sText[,|\s]\n?([\s\S]*&#39;react-native&#39;;)</code> 在浏览器里可以匹配上，但是 vscode 无法匹配 🤔。 最后简单写个脚本补全上面的漏网之鱼:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const fs &#x3D; require(&#39;fs&#39;);const util &#x3D; require(&#39;util&#39;);const path &#x3D; require(&#39;path&#39;);const glob &#x3D; require(&#39;glob&#39;);const replace &#x3D; async () &#x3D;&gt; &#123;  try &#123;    glob(&#39;src&#x2F;**&#x2F;*.tsx&#39;, &#123;&#125;, function (er, files) &#123;      const reg &#x3D; &#x2F;\sText[,|\s]\n?([\s\S]*&#39;react-native&#39;;)&#x2F;;      files.forEach(async (file) &#x3D;&gt; &#123;        const content &#x3D; await util.promisify(fs.readFile)(file, &#39;utf8&#39;);        const newContent &#x3D; content.replace(reg, (m, p1) &#x3D;&gt; &#123;          return &#96; $&#123;p1.trim()&#125;import Text from &#39;@&#x2F;components&#x2F;Text&#39;;&#96;;        &#125;);        await util.promisify(fs.writeFile)(file, newContent, &#39;utf8&#39;);      &#125;);    &#125;);  &#125; catch (error) &#123;    console.log(error);  &#125;&#125;;replace();</code></pre><p>🤔 上面 CustomText 的写法有一个问题，即嵌套 Text 的样式如果是自定义组件中默认的样式，将不会被继承:</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;Text style&#x3D;&#123;&#123; color: &#39;red&#39; &#125;&#125;&gt;  &lt;Text&gt;red&lt;&#x2F;Text&gt;  &lt;Text&gt;red&lt;&#x2F;Text&gt;&lt;&#x2F;Text&gt;&lt;CustomText style&#x3D;&#123;&#123; color: &#39;red&#39; &#125;&#125;&gt;  &lt;CustomText&gt;not red&lt;&#x2F;Text&gt;  &lt;CustomText&gt;not red&lt;&#x2F;Text&gt;&lt;&#x2F;CustomText&gt;</code></pre><p>改良版： </p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; Children, isValidElement, cloneElement &#125; from &#39;react&#39;;import &#123; TextProps, StyleSheet, Text &#125; from &#39;react-native&#39;;const styles &#x3D; StyleSheet.create(&#123;  defaultStyle: &#123;    color: &#39;#323232&#39;,  &#125;,&#125;);export default function CustomText(  props: TextProps &amp; &#123; children?: any; useDefaultStyle?: boolean &#125;,) &#123;  const &#123; style, useDefaultStyle &#x3D; true, ...restProps &#125; &#x3D; props;  const newStyle &#x3D; useDefaultStyle ? [styles.defaultStyle, style] : style;  const childrenWithProps &#x3D; Children.map(props.children, (child) &#x3D;&gt; &#123;    if (isValidElement(child)) &#123;     &#x2F;&#x2F; 如果子元素是个组件，则子组件不使用默认 style      return cloneElement(child as React.ReactElement&lt;any&gt;, &#123;        useDefaultStyle: false,      &#125;);    &#125;    return child;  &#125;);  return (    &lt;Text style&#x3D;&#123;newStyle&#125; &#123;...restProps&#125;&gt;      &#123;childrenWithProps&#125;    &lt;&#x2F;Text&gt;  );&#125;</code></pre><ul><li><p><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view">react-native-scrollable-tab-view</a></p><p><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view">react-native-scrollable-tab-view</a> 组件作为 ScrollView 的子组件时不可用，会出现 tab 选中不一致，tab content 无法撑开的现象，详情看：<a href="https://github.com/ptomasroos/react-native-scrollable-tab-view/issues/982">https://github.com/ptomasroos/react-native-scrollable-tab-view/issues/982</a></p></li><li><p>设置环境变量<br>通常我们的 web 项目可以在 npm script 里通过设置 NODE_ENV 来设置不同的环境变量。比如 <code>NODE_ENV=develope node index.js</code>, 之后可以在代码中通过 <code>process.env.NODE_ENV</code> 来判断具体是哪个环境。rn 项目要达到同样的目的，则需要额外安装 babel 插件 <a href="https://www.npmjs.com/package/babel-plugin-transform-inline-environment-variables">babel-plugin-transform-inline-environment-variables</a>（或者可以通过 <a href="https://github.com/luggit/react-native-config">react-native-config</a>，不过这个方法没有去验证，因为低于 6.x 版本的需要客户端 link）</p></li></ul><h5 id="ScrollView-与-Keyboard"><a href="#ScrollView-与-Keyboard" class="headerlink" title="ScrollView 与 Keyboard"></a>ScrollView 与 Keyboard</h5><p>场景： 当 ScrollView / FlatList / SectionList 中包含输入框时，点击输入框唤起键盘。如果此时输入框右侧有清除输入的按钮，点击时首先会将键盘收起，之后再次点击才会执行 onPress。</p><p>方案：将 <code>keyboardShouldPersistTaps</code> 属性设置为 <code>always</code>，点击清除输入的按钮，键盘不会自动收起。</p><h5 id="iOS-Text"><a href="#iOS-Text" class="headerlink" title="iOS Text"></a>iOS Text</h5><p>ios 的 Text 组件 <code>borderRadius</code> | <code>textAlignVertical</code> 属性无效，只能外层再包个 View</p><h5 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h5><p>RN 的盒模型是 border-box, 即 宽高包括了 padding 和 border。</p><p>在开发中发现如果容器具有 backgroundColor 与 borderRadius 后，设置一个不同颜色的 border, 该容器外围会有一层浅浅的 backgroundColor 描边（目前仅 ios 有这种情况）解决方案：在容器外层再包一个 View，设置 border 样式</p><h5 id="FlatList-的-onViewableItemsChanged"><a href="#FlatList-的-onViewableItemsChanged" class="headerlink" title="FlatList 的 onViewableItemsChanged"></a>FlatList 的 onViewableItemsChanged</h5><p>onViewableItemsChanged 的方法在 FlatList 的生命周期中不可以改变，否则报错：</p><pre class="line-numbers language-none"><code class="language-none">Invariant Violation: Changing onViewableItemsChanged on the fly is not supported</code></pre><p>如果是类组件，可以在 constructor 中定义该方法，如果是函数组件，可以通过 useRef 包裹该方法。</p><h5 id="等宽字体"><a href="#等宽字体" class="headerlink" title="等宽字体"></a>等宽字体</h5><p>如果字体不是等宽的话，倒计时组件会产生宽度抖动。ios 和 安卓平台的字体并不通用，参考 <a href="https://github.com/react-native-training/react-native-fonts。">https://github.com/react-native-training/react-native-fonts。</a> 想要设置等宽字体可以设置 Text 如下样式属性：</p><pre class="line-numbers language-none"><code class="language-none">fontVariant: [&#39;tabular-nums&#39;] &#x2F;&#x2F; 仅 IOSfontFamily: Platform.OS &#x3D;&#x3D;&#x3D; &#39;android&#39; ? &#39;monospace&#39; : undefined &#x2F;&#x2F; 如果是安卓则设置字体为 monospace</code></pre><p>注意如果 fontFamily 指定的字体不存在，则页面将报错</p><h5 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h5><p>轮播图一开始用的是社区里 star 数比较高的 <a href="https://github.com/leecade/react-native-swiper/issues/932">https://github.com/leecade/react-native-swiper/issues/932</a> ，</p><p>☠️ 但是这个组件存在一个坑：如果 loop 为 true，rerender 的时候，会先展示最后一项，再闪回到第一项。这个 bug 存在好几年了，提了很多 issue，都没有解决掉，例如 <a href="https://github.com/leecade/react-native-swiper/issues/932">https://github.com/leecade/react-native-swiper/issues/932</a> </p><p>由于项目比较紧张，又没有时间自己去实现一个，后面发现 <a href="https://github.com/f111fei/react-native-banner-carousel">https://github.com/f111fei/react-native-banner-carousel</a> 这个仓库不存在该问题。后续还是需要自己去研究一下 rn 的轮播图实现方案。</p><h5 id="stickyHeaderIndices"><a href="#stickyHeaderIndices" class="headerlink" title="stickyHeaderIndices"></a>stickyHeaderIndices</h5><p>ScrollView 提供 stickyHeaderIndices 可以指定滚动时吸顶的组件索引</p><p>☠️ 这个属性如果是动态的会导致 ScrollView 无法正常渲染，见 // <a href="https://github.com/facebook/react-native/issues/25157">https://github.com/facebook/react-native/issues/25157</a> ，解决的方法是将 removeClippedSubviews 设置成 false </p><h5 id="关闭弹窗与跳转新页面"><a href="#关闭弹窗与跳转新页面" class="headerlink" title="关闭弹窗与跳转新页面"></a>关闭弹窗与跳转新页面</h5><p>在我们的 ios 客户端发现一个问题：点击一个 Modal 中的内容后，关闭该 modal 并打开一个新的 webview，此时有很大概率无法打开新 webview。</p><p>猜测是由于关闭 modal 的动画影响到打开新 webview（不清楚是否 ios 原生就是如此）</p><p>解决方案就是延迟 300ms 后再打开新 webview</p><h4 id="SectionList-scrollToLocation"><a href="#SectionList-scrollToLocation" class="headerlink" title="SectionList scrollToLocation"></a>SectionList scrollToLocation</h4><p>在 stickySectionHeadersEnabled 为 true 的时候，以下代码的作用是滚动到第一个 section 的第一个元素。但是在 ios 和 android 平台表现不一致，ios 会认为 sticky 元素需要占位置，而安卓则不占位，导致安卓下列表会被遮挡。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sectionListRef.current.scrollToLocation(&#123;  sectionIndex: 0,  itemIndex: 0,&#125;);</code></pre><p>解决方案：根据平台添加 viewOffset 属性，设置滚动偏移量。</p><h4 id="FlatList-性能优化"><a href="#FlatList-性能优化" class="headerlink" title="FlatList 性能优化"></a>FlatList 性能优化</h4><p>RN 的长列表性能一向不太好，即使用了 FlatList 依然要注意性能优化。比如列表项中如果有图片，那么要注意压缩大小等。</p><p>未完待续～</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次搭建 react 项目遇到的坑</title>
      <link href="/2020/07/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%20react%20%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2020/07/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%20react%20%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>电商项目需要搭建一个 h5 项目。这里简单记录一下搭建过程遇到的坑，作为总结。</p><a id="more"></a><p>ui 框架：为了统一 ui 框架，因此选择使用 antd-mobile。<br>打包：parceljs 在此前的项目中已经使用过很多次了，打包速度较 cra 快，且配置简单，因此拟用 parcel。<br>ts：多人项目还是上 ts，没什么好说的。<br>很快就搭建好 demo，接着就开始遇到一些问题。</p><h5 id="antd-mobile-按需加载"><a href="#antd-mobile-按需加载" class="headerlink" title="antd-mobile 按需加载"></a>antd-mobile 按需加载</h5><p>antd-mobile 按需加载推荐使用 <a href="https://github.com/ant-design/babel-plugin-import">babel-plugin-import</a></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; .babelrc or babel-loader option&#123;  &quot;plugins&quot;: [    [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd-mobile&quot;, &quot;style&quot;: &quot;css&quot; &#125;] &#x2F;&#x2F; &#96;style: true&#96; 会加载 less 文件  ]&#125;</code></pre><p>此前 parcel 实际上内置支持了 ts，直接转成 es5 了，因此此前没有额外再配置 babel。<br>🤔 babel-plugin-import 只支持 es6 module 写法的代码，看来需要先把 ts 转成 es6 然后在通过 babel 转成 es5， 没问题，安排～ 于是：</p><ol><li><p>新增 .babelrc</p></li><li><p>修改 tsconfig 的 module 为 <code>es6</code></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;module&quot;: &quot;ES6&quot;  &#125;&#125;</code></pre><p>项目启动，没问题。但是 vscode 开始报错：</p></li></ol><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import React from &#39;react&#39;&#x2F;&#x2F; Module &#39;&quot;&#x2F;node_modules&#x2F;@types&#x2F;react&#x2F;index&quot;&#39; can only be default-imported using the &#39;allowSyntheticDefaultImports&#39; flag</code></pre><p>根本原因是由于 react 导出如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module.exports &#x3D; require(&#39;react.development.js&#39;)</code></pre><p>而非</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module.exports.default &#x3D; require(&#39;react.development.js&#39;)</code></pre><p>Babel 会在 commonjs 格式添加 default 导出，那我们要做的就是让 ts 不要提示这种类型的报错：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;allowSyntheticDefaultImports&quot;: true    &#x2F;&#x2F; ...  &#125;&#125;</code></pre><p>🤔 不过为什么一开始 parcel 不会报错呢？</p><p>接下来路由动态引入组件开始报错：</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import React, &#123; Suspense, lazy &#125; from &#39;react&#39;const List &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;modules&#x2F;List&#39;))&#x2F;&#x2F; Dynamic imports are only supported when the &#39;--module&#39; flag is set to &#39;es2020&#39;, &#39;esnext&#39;, &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, or &#39;umd&#39;.</code></pre><p>看来 <code>es6</code> 是不支持 import() 语法, 那好办，将 module 改成 <code>esnext</code>：</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;compilerOptions&quot;: &#123;    &quot;module&quot;: &quot;ESNext&quot;,  &#125;&#125;</code></pre><p>接下来引入 anti-mobile 组件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; List &#125; from &#39;antd-mobile&#39;&#x2F;&#x2F; Cannot find module &#39;antd-mobile&#39; or its corresponding type declarations.</code></pre><p>此时提示找不到对应的模块声明， 此时我的内心是崩溃的，看起来应该是模块解析路径不对，因此在 tsconfig 中显式配置 <code>moduleResolution</code>:</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;moduleResolution&quot;: &quot;Node&quot;    &#x2F;&#x2F; ...  &#125;&#125;</code></pre><p>不再报错了，看看 ts 文档的解释吧，ts 共有两种可用的模块解析策略：<a href="https://www.tslang.cn/docs/handbook/module-resolution.html#node">Node</a>和<a href="https://www.tslang.cn/docs/handbook/module-resolution.html#classic">Classic</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module &#x3D;&#x3D;&#x3D; &quot;AMD&quot; or &quot;System&quot; or &quot;ES6&quot; ? &quot;Classic&quot; : &quot;Node&quot;</code></pre><p>🤔 按理说 module 为 esnext 的话岂不是应该按 node 策略解析？但是目前看来似乎不是这样的？</p><h5 id="配置-antd-mobile-主题"><a href="#配置-antd-mobile-主题" class="headerlink" title="配置 antd-mobile 主题"></a>配置 antd-mobile 主题</h5><p>接下来需要配置主题，anti-mobile 推荐使用 <a href="http://lesscss.org/usage/#using-less-in-the-browser-modify-variables">modifyVars</a> 来配置主题。<br>将 .babelrc 改成做一下调整：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;    ...    &quot;plugins&quot;: [        [&quot;import&quot;, &#123;&quot;libraryName&quot;: &quot;antd-mobile&quot;, &quot;style&quot;: true&#125;],        ...    ]&#125;</code></pre><p>按照 webpack 的经验，此时需要开启 <code>javascriptEnabled: true</code>问题来了 parcel 内置支持 less ，那我们要在哪里去配置 less 呢？根据 <a href="https://github.com/parcel-bundler/parcel/issues/907">issue</a> 提到可以用 .lessrc 文件来配置，但是我经过尝试发现其实是无效的。。<br>至此基本放弃 parcel。parcel 在快速搭建实验性项目时确实有一定的优势，不过生态确实不如 webpack，由此转向使用 create-react-app</p><h5 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h5><p>使用 cra 很快也建好 demo，解决如何让 cra 创建的项目支持 less ，这个简单：<br>通过 <code>customize-cra</code> 提供的 <code>addLessLoader</code> 方法即可，同时也提供了 <code>fixBabelImports</code> 可以很方便的添加 babel-plugin-import 配置：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const &#123; override, fixBabelImports, addLessLoader &#125; &#x3D; require(&#39;customize-cra&#39;)module.exports &#x3D; override(  fixBabelImports(&#39;import&#39;, &#123;    libraryName: &#39;antd-mobile&#39;,    style: true,  &#125;),  addLessLoader(&#123;    lessOptions: &#123;      javascriptEnabled: true,      modifyVars: &#123;        &#39;@brand-primary&#39;: &#39;#ff74b9&#39;,        &#39;brand-primary-tap&#39;: &#39;#ff9cca&#39;,      &#125;,    &#125;,  &#125;))</code></pre><h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><p>接着是配置路径别名遇到的问题，通过 <code>customize-cra</code> 提供的 <code>addWebpackAlias</code> 可以配置别名，但是 typescript 一直无法解析对应别名，那么应该只需要配置好 ts 的 paths 就行了吧：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;baseUrl&quot;: &quot;.&quot;,    &quot;paths&quot;: &#123;      &quot;@&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;*&quot;]    &#125;    &#x2F;&#x2F; ...  &#125;&#125;</code></pre><p>vscode 不再报错了,接下来就是见证奇迹的时刻了<code>npm run start</code>：<br>控制台显示 <code>- compilerOptions.paths must not be set (aliased imports are not supported)</code> 并且 cra 会自动把 tscongfig 中的 paths 移除掉 😂<br>根据 <a href="https://github.com/timarney/react-app-rewired/issues/375">issue</a>，使用将 baseUrl 和 paths 的配置移动到单独的文件后，在 tsconfig 里通过 extends 的方式继承，虽然控制台依然提示错误，但是别名可以生效。</p><h5 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h5><p>在 build 时，mini-css-extract-plugin 提示 Conflicting order， 错误位置在 antd-mobile 的样式文件。根据 <a href="https://github.com/ant-design/ant-design/issues/14895">issue</a> 以及 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250"> issue </a>看来这个问题主要是由于懒加载加上 antd 组件导入顺序不一致导致的，目前看来无需解决。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
