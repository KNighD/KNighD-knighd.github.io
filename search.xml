<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello 2022</title>
      <link href="/2022/01/02/Hello-2022/"/>
      <url>/2022/01/02/Hello-2022/</url>
      
        <content type="html"><![CDATA[<p>2021 的经历的事情太多，留下的遗憾太多，是时候总结一下，再立一下 2022 Flag</p><a id="more"></a><h3 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h3><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4><p>上半年将 RN 项目迁移到小程序上，说起来算是我个人同时也是公司第一个比较大型的小程序了。在实现的过程中也是尝试了一些新技术，也踩了一些坑。</p><p>本来是打算有时间产出脚手架的，可惜最后因为不可抗力（项目转交给别的部门）而腰斩了。</p><h4 id="monorepo"><a href="#monorepo" class="headerlink" title="monorepo"></a>monorepo</h4><p>背景</p><p>电商在公司的不同 APP / 业务组内由于各自的业务存在一些逻辑 / 样式上的差异。</p><p>解决方案</p><ol><li>方案一：用策略模式，组件内根据不同环境，写各自的逻辑。这个方案的问题在于不同业务的同学可能会一起维护同一个项目，不仅仅是协作上会有问题，可能会经常有冲突，且维护不易</li><li>方案二：从原项目 fork 出来，各自维护代码仓库。这个方案的问题在于一旦有共同的修改点，需要各个业务组同学重复实现</li><li>方案三：我考虑使用 lerna 维护，所有的业务都在一个项目仓库中，并且将公共组件抽出来单独作一个组件库。由此可以解决上述两个方案的问题</li></ol><p>理想很美好，现实很残酷。在实现的过程中也遇到 rn 版本不一致导致无法启动 等等问题，但最终算是解决掉了。</p><p>可惜最后还是因为不可抗力（项目转交给别的部门）而腰斩了。</p><p>幸运的是，新项目组的 UI 框架是用 dumi 搭建的，也采用 lerna 来管理组件库，而同样使用了 dumi 的业务组件库还在起步中，刚好可以用这个机会来落地。</p><h4 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h4><p>想尝试微前端已经很久了，仅在一个新后台项目中加入过 qiankun ，本以为可以用的上，可惜后来发现没有适用的场景，就移除掉了，略微遗憾。</p><p>不过在现在项目组的项目中倒是有同学使用了这个技术，将来应该还是有机会去使用的。</p><h4 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h4><p>在一些项目中尝试去使用了下，bundless 的开发模式启动速度确实比 webpack 快了不少。不过有同学反馈在某些机型上会有打不开的情况，这个我自己倒是没有遇到过，将来前端构建方案到底会是怎么样一个趋势呢？</p><h4 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h4><p>前端一些工具链正在逐步用 rust 重写，这也引起了我的兴趣，打算了解下这门语言。</p><p>跟着 rust 文档学习的过程中，我发现 rust 吸取了很多语言的优点。比如相对于 js 而言，对异常的处理，不是使用 try catch 这样，而是 match ，这点（碍于眼界）我确实有被惊艳到。又比如自动生成文档这样的设计，我觉得对开发者而言体验也是非常好的。</p><p>不过上手上确实有难度，特别是所有权，我常常陷入是否需要加个 &amp; 的疑问中，知乎上称之为 <em>&amp; 配平</em> 我觉得颇为恰当。</p><h4 id="React-原理"><a href="#React-原理" class="headerlink" title="React 原理"></a>React 原理</h4><p>2021 还在啃 React 原理，并且还未啃完，每次重新啃都有新的感悟，有时候在写业务的时候会突然悟到，原来 react 这个地方是如此如此，这般这般～想来这是一个比较漫长的过程，欲速则不达。反正不影响平时的业务开发，反而能沉下心来仔细琢磨。</p><h4 id="技术分享"><a href="#技术分享" class="headerlink" title="技术分享"></a>技术分享</h4><p>今年在公司进行了两次分享，分别是 小程序的工程实践以及 React 即将取消的生命周期 这两个话题，总体上来说输出频率上是不太够的。</p><h3 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h3><p>今年经历了不少事情。先是疯狂扩张，面试了不少前端，发现很大比例的前端都使用的 vue，而 react 实际上是很少的。接着是带着新人做了电商小程序迁移。接着做了一年多的项目又移交到别的团队，再是组织架构调整，继而被分到了新的组。</p><p>在新的组里，承蒙 leader 关照，让我管理十几个人的前端团队，不胜惶恐。从零启动了一个医药相关的项目，期间管理的事项多且繁琐，不过于个人而言确实是一个不小的成长，可以站在更高的角度去看问题。</p><p>可惜好景不长，接着又是裁员风波，这么几周因为离职加微信的人比去年一整年都多。几家欢喜几家愁，而对于团队而言，不少新老同学受到波及，有朋友指出我在这件上事情的某些点上处理的过于理性而近乎不近人情，其实这也基于诸多无奈及我这些年的职场观作出的决定，我也反思是不是确实又些处理的不妥（做人比做技术难 _(:з」∠)_）希望能通过这件事有所成长吧。</p><p>近期两个老领导也离职了，略微伤感。而公司内部似乎因为这次裁员似乎也起了一些波澜，希望不破不立，2022 能是立的一年吧。</p><p>以上是工作上的，而生活上，即将迎接新生命，精力也被分散了些许，以至于有时候感觉对技术的敏感度有所下降，这个应该要注意。体重比去年保持的好一点，有所增涨，但是健身也因为种种原因中断掉。</p><p>路漫漫其修远兮，吾将上下而求索。再过几年即将而立，与刚毕业的时候相比，少了些恐慌，但着眼于更远的远方，迷茫却并未减少。而能做的无非就是走好脚下的道路，然后偶尔抬头，看看是否依然在追逐太阳的路上。</p><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><p>2022 年希望能</p><ul><li>学会 rust ，并写一些小项目练练手</li><li>保持博客更新的习惯</li><li>继续啃 React</li><li>找机会对开源做一点贡献</li><li>体重继续涨…</li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nextjs 初体验</title>
      <link href="/2021/08/20/nextjs-%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2021/08/20/nextjs-%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>最近有个项目转到我这里维护，项目基于 nextjs，刚好之前只有耳闻，未尝使用过，这里简单记录一下。</p><a id="more"></a><p> 接手过来的时候项目没有添加 eslint，查看文档后发现添加 eslint 比较简单</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">npm i eslint eslint-config-next -D&#x2F;&#x2F; .eslintrc.json&#123;  &quot;extends&quot;: &quot;next&quot;&#125;</code></pre><p>本次有个调整需要引入一个新的 npm，麻烦就来了。</p><p>首先是 next.js 默认不编译 node_modules，具体查看 <a href="https://github.com/vercel/next.js/issues/706。解决办法是添加">https://github.com/vercel/next.js/issues/706。解决办法是添加</a> <code>next-transpile-modules</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const withTM &#x3D; require(&#39;next-transpile-modules&#39;)([&#39;package-need-transpile&#39;]);module.exports &#x3D; withTM(&#123;  &#x2F;&#x2F; ...  webpack5: false,&#125;);</code></pre><p>项目不是 webpack5，因此置为 false</p><p>接着，nextjs 提示我第三方库引入了全局 css。具体查看 <a href="https://github.com/fullcalendar/fullcalendar/issues/5393。解决办法我这里就比较粗暴了，fork">https://github.com/fullcalendar/fullcalendar/issues/5393。解决办法我这里就比较粗暴了，fork</a> 出一份第三方库，将里面的全局样式注释掉。</p><p>接着，nextjs 提示入门必提示的 window is not defined，这是由于 node 环境还不存在 window。</p><p>这时候有几个解决方案:</p><ol><li>在 didMount / useEffect 中使用 window</li><li>如果是引入组件，那么通过 <code>next/dynamic</code> 引入, 且设置 ssr 为 false</li><li>判断 typeof window !== “undefined” 再使用 window</li></ol><p>按上述的方法解决完之后，代码运行，看似没啥问题了。打包，大功告成？等等，又出现了 window is not defined，打包失败。可是我在 dev 的时候确实是编译成功了且没有报错啊。查看提示发现原来是引入的包中使用到了 window</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const MyNoSsrCom &#x3D; dynamic(() &#x3D;&gt; import(&#39;.&#x2F;MyCom&#39;), &#123; ssr: false &#125;)&#x2F;&#x2F; MyCom.jsximport &#123; sometool &#125; from &#39;my-package&#39;&#x2F;&#x2F; ...&#x2F;&#x2F; my-package.js&#x2F;&#x2F; 使用到了 windowwindow.xxxx</code></pre><p>这种情况虽然在 dev 是可以的，然而 build 的时候却会报错，原因不详</p><p>无奈，只能做如下处理</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&#x2F;&#x2F; MyCom.jsxconst &#123;sometool &#125; &#x3D; typeof &#39;window&#39; &#x3D;&#x3D;&#x3D; undefined ? &#123;&#125; : require(&#39;my-package&#39;)&#x2F;&#x2F; ...</code></pre><p>看似没啥问题了，再次 build，依然还是失败了。这次提示 pages 下有文件没有默认导出 react 组件，仔细一看正是我 fork 出来的包文件。不知道为什么将这个文件判断成 react 组件，估计是因为其中存在 Class？只好添加一个默认导出</p><p>至此大功告成，但我却陷入怀疑，这个项目本身并没有太多 seo 的痕迹/需求，也只是一个页面，按道理没有首屏幕渲染之类的问题，为什么强行上了个 nextjs，代码中处处都要  <code>typeof &#39;window&#39; === undefined</code> 这真的好吗？</p><p>也许是还没有更深入去了解 nextjs，才会有上述见解。但起码对普通的项目于我而言大概率是不会再有 next 了吧。。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序踩坑小记（三）</title>
      <link href="/2021/08/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2021/08/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>上面一篇主要讲述了一些技术细节，这一篇主要来讲讲踩的坑以及单纯吐槽</p><a id="more"></a> <h4 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h4><ol><li><p>ScrollView 中的 fixed 样式无效 / 出错。这个问题是在使用官方的拓展组件 mp-sticky 时发现的。mp-sticky 的原理是包裹组件滚动出视口时，将样式变为 fixed 实现的，但如果在 ScrollView 中会失效 / 表现异常等，如 <a href="https://developers.weixin.qq.com/community/develop/doc/0004aeafeccb789ac219e474756000">https://developers.weixin.qq.com/community/develop/doc/0004aeafeccb789ac219e474756000</a> </p></li><li><p>fixed 可能会遇到层级错乱</p></li><li><p>wx.getMenuButtonBoundingClientRect() 偶现返回值为 0 的问题，一般是 ios 在重新进入小程序时会重现，见 <a href="https://developers.weixin.qq.com/community/develop/doc/0006a49ba7cf4090feea00db350000?_at=1627380707469">https://developers.weixin.qq.com/community/develop/doc/0006a49ba7cf4090feea00db350000?_at=1627380707469</a> ，目前的做法是在监听路由 appLaunch 的时候，如果获取到的值为 0 则重新获取</p></li><li><p>提示运行环境加载失败，这个问题可能是开了代理或者内存不足导致的</p></li><li><p>ScrollView 组件中要定位到某个元素是通过 scrollIntoView 这个属性来实现的，这里就有个问题，不清楚原生小程序是否存在，即定位过一次之后，如果还想定位到相同的元素，由于 scrollIntoView 属性没有变化，则不会产生滚动。。想吐槽一下为什么这个不设计成类似 pageScrollTo 这样的 api ，而是用属性形式</p></li><li><p>开发者工具与真机调试的请求超时/ 无网络时 的errMsg不一致</p></li><li><p>getNetworkType 获取到的网络状态可能会有延迟</p></li><li><p>tabbar borderStytle 在 ios 13 上格外粗，只能自己去实现一个 tabbar </p></li><li><p>Taro 的 PageMeta 无法使用 <a href="https://github.com/NervJS/taro/issues/6092">https://github.com/NervJS/taro/issues/6092</a></p></li><li><p>taro 中 dataset 的相关讨论 <a href="https://github.com/NervJS/taro/issues/7313">https://github.com/NervJS/taro/issues/7313</a></p></li><li><p>intersectionObserver 是一个用于监控元素与视口（或者指定元素）相交情况的一个 api，在 web 上是非常好用的，然而到了小程序有如下限制，导致我一度想放弃该 api</p><ol><li><p>createIntersectionObserver 创建出来的 observer 只能 observe 一次，即使 observer disconnect 之后也是如此</p></li><li><p>observe 不能监听新增的元素（未测试 web 上是否如此），比如无限加载的列表，新增加进来的元素是无法被监听的，除非再次 observe ，然而小程序不允许同一个 observer 重复 observe</p></li><li><p>observe 接收的参数是选择器，例如 ‘.classname’ 这样的，这个我觉得既然是小程序里为什么不支持 ref？</p></li><li><p>注意 observe  的时机，需要在组件挂载之后，那么这个时间在 Taro 对应的是 useEffect 中的 nextTick 里</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">useEffect(() &#x3D;&gt; &#123;  nextTick(() &#x3D;&gt; &#123;    observer.observe(&#39;.item&#39;, () &#x3D;&gt; &#123;      &#x2F;&#x2F; ...    &#125;)  &#125;)&#125;, []) </code></pre></li><li><p>通过 obsever 第二个参数是个回调，代表相交状态变化时要执行的回调，然而从这里获取到的信息比较少</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface ObserveCallbackResult &#123;  &#x2F;** 目标边界 *&#x2F;  boundingClientRect: BoundingClientRectResult  &#x2F;** 相交比例 *&#x2F;  intersectionRatio: number  &#x2F;** 相交区域的边界 *&#x2F;  intersectionRect: IntersectionRectResult  &#x2F;** 参照区域的边界 *&#x2F;  relativeRect: RelativeRectResult  &#x2F;** 相交检测时的时间戳 *&#x2F;  time: number&#125;</code></pre><p>额外信息只能带在 dataSet 中，如下</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; document &#125; from &#39;@tarojs&#x2F;runtime&#39;;observer.observe(&#39;.item&#39;,  (res: IntersectionObserver.ObserveCallbackResult &amp; &#123; id: string &#125;) &#x3D;&gt; &#123;      const el &#x3D; document.getElementById(res.id);  console.log(el.dataset)    &#125; &#125;);</code></pre></li></ol><p>总之这个 api 在小程序上我觉得没有很符合预期。。</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个项目历时一个多月，和小伙伴们将 rn 应用搬到小程序上，中间遇到种种问题。整体开发下来的体验就是小程序有一些比较方便的 api 同时也存在一些将原先 web 好用的地方魔改而产生的问题。</p><p>后续计划是将小程序中的公用组件抽出来到公共库中，同时提供小程序脚手架以便别的业务线使用。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序踩坑小记（二）</title>
      <link href="/2021/08/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/08/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>上一篇中主要讲的是工程架构方面的，这篇主要讲一些细节实现</p><a id="more"></a> <h4 id="使用原生能力"><a href="#使用原生能力" class="headerlink" title="使用原生能力"></a>使用原生能力</h4><p>使用原生 api，如 wx.xxx，taro 将 wx 暴露的 api 集成到 @tarojs/taro 中了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import Taro from &#39;@tarojs&#x2F;taro&#39;Taro.xxx</code></pre><p>使用原生组件 taro 的文档讲的就相当模糊。这里我结合自己的场景，一个是用到直播插件, app 配置</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; src&#x2F;app.config.ts&#123;&#x2F;&#x2F; ...plugins: &#123;    &#39;live-player-plugin&#39;: &#123;      version: &#39;1.3.0&#39;,      provider: &#39;wx2b03c6e691cd7370&#39;,    &#125;,  &#125;,&#125;</code></pre><p>其中 wx2b03c6e691cd7370 是微信规定的直播插件，需要写死的</p><p>使用时：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;Navigator url&#x3D;&#123;&#96;plugin-private:&#x2F;&#x2F;wx2b03c6e691cd7370&#x2F;pages&#x2F;live-player-plugin&#96;&#125;&gt;  进入直播&lt;&#x2F;Navigator&gt;</code></pre><p>使用原生组件需要在页面的配置文件中添加 usingComponents</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;&#x2F;&#x2F; ...usingComponents: &#123;    &#39;mp-tabs&#39;:      &#39;..&#x2F;..&#x2F;components&#x2F;@miniprogram-component-plus&#x2F;tabs&#x2F;miniprogram_dist&#39;,    &#39;mp-sticky&#39;:      &#39;..&#x2F;..&#x2F;components&#x2F;@miniprogram-component-plus&#x2F;sticky&#x2F;miniprogram_dist&#39;,  &#125;,&#125;</code></pre><p>看到这里引用路径是 <code>../../components/xxx</code>这个路径是怎么来的呢？</p><p>原来 taro 不会将没有使用到的 node_module 下的文件拷贝到 dist，那么我们需要就自己去配置拷贝项</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; config&#x2F;index.js&#123;&#x2F;&#x2F; ...copy: &#123;    patterns: [      &#123;        from: &#39;node_modules&#x2F;@miniprogram-component-plus&#39;,        to: &#39;dist&#x2F;components&#x2F;@miniprogram-component-plus&#39;,      &#125;,    ],  &#125;,&#125;</code></pre><p>这里我们约定 dist/components 为原生组件放置的目录，<code>../../components/xxx</code> 即相对这个目录来的。</p><p>使用时</p> <pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&#x2F;&#x2F; index.tsx&#x2F;&#x2F; ...&lt;mp-sticky&gt;&lt;&#x2F;mp-sticky&gt;&#x2F;&#x2F; global.d.ts&#x2F;&#x2F; 定义一下 type，如果有用 typescript 的话declare namespace JSX &#123;  interface IntrinsicElements &#123;    &#39;mp-sticky&#39;: any;  &#125;&#125;</code></pre><h4 id="mini-css-extract-plugin-编译警告"><a href="#mini-css-extract-plugin-编译警告" class="headerlink" title="mini-css-extract-plugin 编译警告"></a>mini-css-extract-plugin 编译警告</h4><p> mini-css-extract-plugin 需要按引用顺序去生成 css 文件，如果多个文件引入顺序不一致就会警告</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">chunk common [mini-css-extract-plugin]Conflicting order between:...</code></pre><p>详见 <a href="https://github.com/NervJS/taro/issues/7160">https://github.com/NervJS/taro/issues/7160</a></p><p>解决方案：我这里引入顺序没有太大的影响，因此选择忽略顺序</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; config&#x2F;index.js&#123;&#x2F;&#x2F; ...  mini: &#123;    miniCssExtractPluginOption: &#123;      ignoreOrder: true,    &#125;,  &#125;,&#125;</code></pre><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>前端生成随机 id，通常是通过 Math.random 实现的，例如组内一个小伙伴的实现：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function uuid(len &#x3D; 8) &#123;let str &#x3D; &#39;&#39;  for(; str.length &lt; len; str +&#x3D; Math.random().toString(36).substr(2)) &#123;&#125;  return str.substr(0, len)&#125;</code></pre><p>然而上面实际是伪随机，web 端可以利用 crypto 实现，组内另一个小伙伴的实现</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * 用来随机生成文件名的字符串集合，需要达到256位，但超过256位之后会抛弃 *&#x2F;const randomSeed &#x3D; &#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;.repeat(5);&#x2F;** * 使用浏览器的crypto模块，简单地生成随机字符串 *&#x2F;export const createRandomString &#x3D; (len &#x3D; 16) &#x3D;&gt; &#123;  return Array.from(crypto.getRandomValues(new Uint8Array(len)))    .map((v) &#x3D;&gt; randomSeed[v])    .join(&#39;&#39;);&#125;;</code></pre><p>然而小程序自己提供的 getRandomValues 对微信基础库版本要求较高</p> <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const createRandomString &#x3D; async (length &#x3D; 16) &#x3D;&gt; &#123;  const res &#x3D; await wx.getRandomValues(&#123; length &#125;);  return Taro.arrayBufferToBase64(res.randomValues);&#125;;</code></pre><p>偶然看到 taro-ui 的实现，记录下来：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function uuid(len &#x3D; 8, radix &#x3D; 16): string &#123;  const chars &#x3D; &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#39;.split(&#39;&#39;)  const value: string[] &#x3D; []  let i &#x3D; 0  radix &#x3D; radix || chars.length  if (len) &#123;    &#x2F;&#x2F; Compact form    for (i &#x3D; 0; i &lt; len; i++) value[i] &#x3D; chars[0 | (Math.random() * radix)]  &#125; else &#123;    &#x2F;&#x2F; rfc4122, version 4 form    let r    &#x2F;&#x2F; rfc4122 requires these characters    &#x2F;* eslint-disable-next-line *&#x2F;    value[8] &#x3D; value[13] &#x3D; value[18] &#x3D; value[23] &#x3D; &#39;-&#39;    value[14] &#x3D; &#39;4&#39;    &#x2F;&#x2F; Fill in random data.  At i&#x3D;&#x3D;19 set the high bits of clock sequence as    &#x2F;&#x2F; per rfc4122, sec. 4.1.5    for (i &#x3D; 0; i &lt; 36; i++) &#123;      if (!value[i]) &#123;        r &#x3D; 0 | (Math.random() * 16)        value[i] &#x3D; chars[i &#x3D;&#x3D;&#x3D; 19 ? (r &amp; 0x3) | 0x8 : r]      &#125;    &#125;  &#125;  return value.join(&#39;&#39;)&#125;</code></pre><h4 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h4><p>在加入七鱼插件后，尝试上传代码时，小程序提示主包体积过大。分析发现，小程序对于官方提供的插件或者拓展组件，如 直播 / sticky 等组件是不计入体积的，而对于第三方的插件是需要计入体积的。那么怎么解决呢？</p><p>已知七鱼插件约1.3 m, 而微信允许一个包最多 2m，显然七鱼的代码不能和业务代码放在同一个包里。而微信也提供了分包的办法。配置起来倒是简单。在 app.config.json 中可以添加 subpackages 字段，将需要分包出去的页面按 root 分别打包。</p><p>第二个问题是，七鱼只是提供了跳转插件页的 url <code>plugin://qiyukefu/chat</code>, 可是这个 url 确不能作为分包的 page。因此我单独加了一个页面作为中转到七鱼的入口，即进入这个中转页面后就会执行</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">redirectTo(&#123;  url: &#39;plugin:&#x2F;&#x2F;qiyukefu&#x2F;chat&#39;,&#125;);</code></pre><p>然而，小程序这里还有个坑，如果当前这个插件加载速度比较慢的话，就会导致中转页面先关掉，然后再跳转到七鱼，表现成闪烁一下。这里没什么好的办法，在当前页面延时 1s 后跳转。</p><p>同时对这个中转页所在包通过配置 <code>preloadRule</code> 做了一个预加载，优化体验。</p><h4 id="路由设计"><a href="#路由设计" class="headerlink" title="路由设计"></a>路由设计</h4><p>微信提供了路由跳转的 api，一开始是直接使用的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Taro.navigateTo(&#123;url: &#39;xxxx&#39;&#125;)</code></pre><p> 但是直接使用这个 api 很快就暴露了一些问题</p><ol><li>参数需要自行拼接，即需要拼接成 <code>xxx?x=x</code>  的形式，写起来不太友好</li><li>分包的时候由于文件路径变更，所有涉及到的路由都要手动改，这里很容易漏掉或者写错</li><li>不够直观，且无法复用</li></ol><p>基于这些问题，我对路由进行了简单的封装</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 给各个页面提供别名export enum RoutesMap &#123;  首页 &#x3D; &#39;&#x2F;pages&#x2F;home&#x2F;index&#39;,  &#x2F;&#x2F; ...&#125;export class Router &#123;  &#x2F;&#x2F; 记录当前 url  currentUrl;  constructor() &#123;    wx.onAppRoute((res: AppRouteRes) &#x3D;&gt; &#123;      &#x2F;&#x2F; 当路由变化时，发布一个 ON_ROUTE_CHANGE 的事件      eventCenter.trigger(ON_ROUTE_CHANGE, &#123;        from: this.currentUrl,        to: this.getUrlFromRouteRes(res),        openType: res.openType,      &#125;);      this.currentUrl &#x3D; this.getUrlFromRouteRes(res);    &#125;);  &#125;  &#x2F;&#x2F; 根据 wx.onAppRoute 的返回值拼成完整 url  getUrlFromRouteRes(res: AppRouteRes) &#123;    return &#39;&#x2F;&#39; + res.path + qs.stringify(res.query || &#123;&#125;);  &#125;  &#x2F;** 获取当前所在页面 *&#x2F;  getCurrentPage() &#123;    const pages &#x3D; Taro.getCurrentPages();    const currentPage &#x3D; pages[pages.length - 1];    return currentPage;  &#125;  &#x2F;**   * 封装跳转，支持 NAVIGATE | REDIRECT | SWITCH_TAB   * @example   * &#96;&#96;&#96;tsx   *  router.go(&#123; path: RoutesMap.商品详情, data: &#123; id: 1 &#125; &#125;)   * &#96;&#96;&#96;   *&#x2F;  go(&#123; path, openType &#x3D; OpenType.NAVIGATE, data &#x3D; &#123;&#125; &#125;: GoOption) &#123;    const querystring &#x3D; stringify(data);    const url &#x3D; &#96;$&#123;path&#125;$&#123;querystring&#125;&#96;;    switch (openType) &#123;      case OpenType.NAVIGATE:        return navigateTo(&#123;          url,        &#125;);      case OpenType.REDIRECT:        return redirectTo(&#123;          url,        &#125;);      case OpenType.SWITCH_TAB:        return switchTab(&#123;          url,        &#125;);      default:        break;    &#125;  &#125;  &#x2F;**   * 监听路由变化   *&#x2F;  onRouteChange(listener: RouteEventListener) &#123;    eventCenter.on(&#39;ON_ROUTE_CHANGE&#39;, listener);    return this;  &#125;  &#x2F;**   * 解绑路由监听   *&#x2F;  offRouteChange(listener: RouteEventListener) &#123;    eventCenter.off(&#39;ON_ROUTE_CHANGE&#39;, listener);    return this;  &#125;&#125;</code></pre><p>这里的 wx.onAppRoute 是微信内部使用的 api，没有文档，不过确实可以使用。一开始我是想通过所有跳转的地方都使用自己封装的 Router 来跳转实现记录路由，但是这样其实有一个最主要的问题：无法监听（物理）返回。因此不得已使用这个 wx.onAppRoute。</p><p>通过上述简单封装，就实现了路由监听，通过别名跳转等，使用方法如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const router &#x3D; new Router()router.go(&#123; path: RoutesMap.商品详情, data: &#123; id: 1 &#125; &#125;)router.onRouteChange(() &#x3D;&gt; &#123;   &#x2F;&#x2F;... &#125;)</code></pre><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>微信小程序 sdk 最新有个更新是提供了一个新的api  <code>wx.getUserProfile</code> 用于替换 <code>wx.getUserInfo</code>，开发者每次通过该接口获取用户个人信息均需用户确认，见 <a href="https://developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801?highLine=login">https://developers.weixin.qq.com/community/develop/doc/000cacfa20ce88df04cb468bc52801?highLine=login</a></p><p>本项目中暂时只需要获取到用户的唯一标识，因此需要用到的 api 是 <code>wx.login</code>。</p><p>当我们进入到小程序页面的时候，分两种情况，一种是当前页面需要登录态，一种是无需登录态。进入到需要登录态的页面，如果当前 storage 中没有用户信息，那么可以判断为没有登录态，此时展示 loading 同时调用 wx.login 后，将会得到用户的 union_id，使用这个 union_id 去跟服务端兑换用户信息即可。</p><p>那么这里的逻辑是如何封装的呢，代码如下</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&#x2F;** * 登录 hoc，包裹的页面未登录时会自行进行登录 *&#x2F;export default function NeedLogin(&#123; children &#125;: IProps) &#123;  const [userInfo] &#x3D; useAtom(userInfoAtom);  const childrenVisible &#x3D; !userInfo;  if (childrenVisible) &#123;    &#x2F;&#x2F; 如果不是 mock 且无用户信息时，展示 loading 并开始登录流程    return &lt;LoginView &#x2F;&gt;;  &#125;  return children;&#125;&#x2F;** 提供 hoc * @example * &#96;&#96;&#96;tsx * export default withLogin(Home) * &#96;&#96;&#96;&#96; *&#x2F;export const withLogin &#x3D; (WrappedPage: ComponentType&lt;any&gt;) &#x3D;&gt; () &#x3D;&gt;  (    &lt;NeedLogin&gt;      &lt;WrappedPage &#x2F;&gt;    &lt;&#x2F;NeedLogin&gt;  );</code></pre><p>为了不影响到原先页面的布局结构，这里提供了一个 <code>withLogin</code> 高阶组件，使用时 <code>withLogin(Home)</code> 即可</p><p>可以看到上述代码中，如通过 userInfoAtom 来获取用户信息，实际上这个 userInfo 就是一个持久化到 storage 的状态。如果没有获取到用户信息，将会展示 <code>LoginView</code> 这个组件，那么这个组件做了什么呢？</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const LoginView &#x3D; () &#x3D;&gt; &#123;  useEffect(() &#x3D;&gt; &#123;    const init &#x3D; async () &#x3D;&gt; &#123;      try &#123;        const currentPage &#x3D; Taro.getCurrentInstance().page;        await login();        Taro.nextTick(() &#x3D;&gt; &#123;          if (currentPage &amp;&amp; currentPage.onShow) &#123;            currentPage.onShow();          &#125;        &#125;);      &#125; catch (error) &#123;        Taro.showToast(&#123;          icon: &#39;none&#39;,          title: error.message || &#39;登录失败&#39;,        &#125;);      &#125;    &#125;;    init();  &#125;, []);  return (    &lt;View&gt;      加载中...    &lt;&#x2F;View&gt;  );&#125;;</code></pre><p>可以看到其实很简单，就是加载的时候执行 login。</p><p>这里有个注意点，我们监听被包裹的页面的 onShow 事件，但是 onShow 实际上是页面的生命周期，即未登录时，被包裹页面的组件的 onShow 不会在登录完成后执行。因此做了一个 hack，即登录完成后调用当前页面的 onShow。</p><p>回到 login 又做了什么呢？这里先按下不表，我们需要考虑几个问题</p><ol><li>用户登录态失效了该怎么办，上述代码并没有检测登录态是否失效的逻辑</li><li>进入页面时登录态有效，然而请求接口时用户登录态失效了怎么处理</li></ol><p>对的，解决上述两个问题的方法，请求的时候如果服务端返回 401 ，那么我们有两种选择：</p><ol><li>在页面上盖一层提示异常的页面，让用户点击重新登录</li><li>静默执行 login，重新获取用户信息即可</li></ol><p>第一种方案看似挺好的，实际上实现起来并不简单，将会涉及到页面布局，数据通信等等。那么如果采用第二种方案要在接口登录态失效的时候 login，需要考虑哪些问题？</p><ol><li>并发： 如果同时有两个接口调用 login，那会不会同时存在两个请求登录的接口，有没有办法优化？</li><li>重试：登录成功之后，之前的失效的请求是否还需要重新发一次呢？</li><li>重试次数：如果登录接口异常，返回的用户信息就是不正确的，那么很可能导致一直重试死循环，那么我们需要限制最多尝试登录的次数。</li></ol><p>并发就涉及到 login 的实现了，这里很容易想到就是单例模式，实际上在前端借助 esm 是很容易实现一个单例的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import Taro from &#39;@tarojs&#x2F;taro&#39;;&#x2F;** 保持一个 promise 防止并行 *&#x2F;let loginPromise;&#x2F;** 登录 *&#x2F;export const login &#x3D; () &#x3D;&gt; &#123;  if (!loginPromise) &#123;    loginPromise &#x3D; new Promise&lt;UserInfo&gt;((resolve, reject) &#x3D;&gt; &#123;      Taro.login(&#123;        async success(res) &#123;          if (res.code) &#123;            try &#123;              &#x2F;&#x2F; 请求服务端用户信息              let userRes &#x3D; await getUserLogin(&#123;                code: res.code,              &#125;);              userStore.setState(&#123; userInfo: userRes &#125;);              resolve(userRes);            &#125; catch (error) &#123;              &#x2F;&#x2F; 清除掉 storage 中的 user 信息              userStore.setState(&#123; userInfo: undefined &#125;);              reject(error);            &#125;          &#125; else &#123;            reject(&#123; code: -1, message: &#39;登录失败&#39; &#125;);          &#125;          loginPromise &#x3D; null;        &#125;,        fail: (res) &#x3D;&gt; &#123;          reject(&#123; code: -1, message: &#39;登录失败&#39; &#125;);          loginPromise &#x3D; null;        &#125;,      &#125;);    &#125;);  &#125;  return loginPromise;&#125;;</code></pre><p>在上述代码中，如果已经存在了 loginPromise，就不再创建新的 promise</p><p>第二三点则是需要封装在 request 里，这里就需要对 request 进行一个小改造了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let retryTimes &#x3D; 0;async function myRequest(config) &#123;  &#x2F;&#x2F; 登录失效一共可重试 3 次  let MAX_RETRY_TIMES &#x3D; 3;  try &#123;    const res &#x3D; await request(config);    const &#123; code, data &#125; &#x3D; res.data;    if (res.statusCode &#x3D;&#x3D;&#x3D; 401 &amp;&amp; retryTimes &lt; MAX_RETRY_TIMES) &#123;      &#x2F;&#x2F; 重试计数器加 1      retryTimes &#x3D; retryTimes + 1;      &#x2F;&#x2F; 清空登录      userStore.setState(&#123; userInfo: undefined &#125;);      &#x2F;&#x2F; 过期或者登录态失效      await login();      &#x2F;&#x2F; 重新请求一次      const res2 &#x3D; await youpinRequest&lt;T&gt;(config);      return res2;    &#125;    return data;  &#125; catch (error) &#123;    throw error;  &#125;&#125;</code></pre><p>这里整个应用存在的周期允许用户重试 MAX_RETRY_TIMES 次数</p><h4 id="一像素边框"><a href="#一像素边框" class="headerlink" title="一像素边框"></a>一像素边框</h4><p>写过 h5 的同学可能经常遇到一像素问题，即1px 在移动端实际上对应的是 1 * pixelRatio 的物理像素，导致整个边框显得格外粗，UI 同学就会过来找你麻烦。解决方案也是五花八门，比较通用的方案是通过缩放带边框的伪元素来解决。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">.hairline-border &#123;  position: relative;  border: none;  &amp;::after &#123;    content: &#39;&#39;;    position: absolute;    left: 0;    top: 0;    transform-origin: top left;    box-sizing: border-box;    pointer-events: none;    width: 200%;    height: 200%;    transform: scale(0.5);    &#x2F;&#x2F; prettier-ignore    border-width: 1PX;    border-style: solid;    border-color: black;  &#125;&#125;</code></pre><p>之后在需要的组件上添加这个 hairline-border 样式就可以了。然而在每个组件上添加样式名实属有些麻烦，特别是与 css module 在一起使用时</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;View className&#x3D;&#123;classnames([styles.myStyles, &quot;hairline-border&quot;])&#125; &#x2F;&gt;</code></pre><p>差不多是上述代码这样的，如果组件有圆角则更为麻烦，需要在 myStyles 里写</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">.myStyles &#123;  &amp;::after &#123;    &#x2F;&#x2F; 如果需要的圆角为 4，则要写成 4 * 2 &#x3D; 8border-radius: 8px;&#125;&#125;</code></pre><p>还比如我希望仅底部有 border，要怎么处理呢？</p><p>这里可以借助 less 提供的函数能力进行一个简单的封装</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;** * 1 像素边框 * @example * &#96;&#96;&#96; * @import &#39;@&#x2F;hairline-border.less&#39;; * &#x2F;&#x2F; 红色的一像素边框 * .hairline-border(red) * &#x2F;&#x2F; 圆角为 4px 的一像素红色边框 * .hairline-border(red, 4px) * &#x2F;&#x2F; 圆角为 4px 的一像素红色顶部边框 * .hairline-border(red, 4px, top) * &#x2F;&#x2F; 不带圆角的一像素红色顶部边框 * .hairline-border(red, 0, top) * &#96;&#96;&#96; *&#x2F;.hairline-border(@color) &#123;  position: relative;  border: none;  &amp;::after &#123;    content: &#39;&#39;;    position: absolute;    left: 0;    top: 0;    transform-origin: top left;    box-sizing: border-box;    pointer-events: none;    width: 200%;    height: 200%;    transform: scale(0.5);    &#x2F;&#x2F; prettier-ignore    border-width: 1PX;    border-style: solid;    border-color: @color;  &#125;&#125;.hairline-border(@color, @radius) &#123;  .hairline-border(@color);  &amp;::after &#123;    border-radius: @radius * 2;  &#125;&#125;.hairline-border(@color, @radius, @position) &#123;  .hairline-border(@color, @radius);  &amp;::after &#123;    border-width: 0px;    each(@position, &#123;      &#x2F;&#x2F; prettier-ignore      border-@&#123;value&#125;-width: 1PX;    &#125;);  &#125;&#125;@media only screen and (-webkit-min-device-pixel-ratio: 3) &#123;  .hairline-border(@color) &#123;    position: relative;    border: none;    &amp;::after &#123;      content: &#39;&#39;;      position: absolute;      left: 0;      top: 0;      transform-origin: top left;      box-sizing: border-box;      pointer-events: none;      width: 300%;      height: 300%;      transform: scale(0.33);      &#x2F;&#x2F; prettier-ignore      border-width: 1PX;      border-style: solid;      border-color: @color;    &#125;  &#125;  .hairline-border(@color, @radius) &#123;    .hairline-border(@color);    &amp;::after &#123;      border-radius: @radius * 3;    &#125;  &#125;  .hairline-border(@color, @radius, @position) &#123;    .hairline-border(@color, @radius);    &amp;::after &#123;      border-width: 0px;      each(@position, &#123;      &#x2F;&#x2F; prettier-ignore      border-@&#123;value&#125;-width: 1PX;    &#125;);    &#125;  &#125;&#125;</code></pre><p>那么使用的时候</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">.myStyle &#123;.hairline-border(red, 0, top)&#125;</code></pre><p>是不是就很方便了</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;View className&#x3D;&#123;styles.myStyles&#125; &#x2F;&gt;</code></pre><p>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序踩坑小记（一）</title>
      <link href="/2021/06/15/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0/"/>
      <url>/2021/06/15/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>最近公司将搁置了一年的将 RN 应用搬到小程序的计划提上议程，由此开始了这段时间的踩坑之旅。考虑到技术栈为 react，因此使用 tarojs 作为基础框架。</p><a id="more"></a><h4 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h4><p>在 rn 项目中，我们使用 axios 并搭配 axios-mock-adapter 作为 mock，而 tarojs 提供了 mock 插件，由于仅在 dev 场景下才会使用到 mock，配置如下:</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; package.json&quot;scripts&quot;: &#123;    &quot;dev:weapp:mock&quot;: &quot;MOCK&#x3D;1 npm run dev:weapp&quot;,  &#125;,</code></pre><p>新增一个 <code>script</code>, 并且添加环境变量 <code>MOCK=1</code>。然而仅仅是这样的话，如果我们在业务代码中去取 <code>process.env.MOCK</code>，取的值是 <code>undefined</code>。</p><p>解决的方法是在 config/dev.js 下注入，配置如下:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;  env: &#123;      NODE_ENV: &#39;&quot;development&quot;&#39;,      MOCK: process.env.MOCK,    &#125;,&#125;</code></pre><p>此时在业务代码中去取 <code>process.env.MOCK</code> 可以得到 <code>1</code>。这里值得注意，按道理说应该获取到字符”1”，然而实际上却是 number 类型的 1。</p><p>在 config/dev.js 下还需添加一个mock 插件的配置</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;  plugins:      process.env.MOCK &#x3D;&#x3D;&#x3D; &#39;1&#39;        ? [            [              &#39;@tarojs&#x2F;plugin-mock&#39;,              &#123;&#125;            ],          ]        : [],&#125;</code></pre><p>至此，当我们运行 <code>npm run dev:weapp:mock</code>时，将会启动一个 mock 服务器。</p><p>那么接下来就需要定制一下我们的请求</p><h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><p>tarojs 提供了 request 来发送请求，但仅仅这还不够用，比如，我们希望本地开发的时候，mock 时使用的是 mock 服务器的接口，非mock 时使用测试服务器的接口，上线的时候使用的是线上的接口，即一个根据不同环境 baseUrl 的功能。</p><p>判断 开发/线上环境可以通过 getAccountInfoSync 来获取，判断是否 mock 可以通过 process.env.MOCK 来获取。</p><p>然而 request 并不像 axios 那样可以根据配置创建一个 instance 实例，并且提供 baseUrl 这样的配置，所幸 request 可以自定义拦截器 interceptor。</p><p>利用这点实现上述需求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; request, addInterceptor, getAccountInfoSync &#125; from &#39;@tarojs&#x2F;taro&#39;;const accountInfo &#x3D; getAccountInfoSync();const interceptor &#x3D; function (chain) &#123;  const requestParams &#x3D; chain.requestParams;  const &#123; url &#125; &#x3D; requestParams;  const host &#x3D;    accountInfo.miniProgram.envVersion &#x3D;&#x3D;&#x3D; &#39;develop&#39;      ? &#x2F;&#x2F; 这里的 process.env.MOCK 按道理应该是 string，然而实际上 taro 给注入的是 number，因此使用 any 暂时跳过        (process.env.MOCK as any) &#x3D;&#x3D;&#x3D; 1        ? MockServer        : TestServer      : ProServer;  return chain.proceed(&#123; ...requestParams, url: &#96;$&#123;host&#125;$&#123;url&#125;&#96; &#125;);&#125;;addInterceptor(interceptor);</code></pre><p>request 返回的结果 res 中的 data 字段是接口返回给我们的内容，那么我们还希望能直接获取到 res.data。通常这里还是会用 interceptor 来做一层拦截，返回 res.data , 但是这样的话，在 Typescript 中你会发现返回的类型与 request 的返回类型是不一致的。因此为了不影响输出的类型，我们可以对 request 做一层封装</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const myRequest &#x3D; &lt;T &#x3D; any&gt;(config: request.Option) &#x3D;&gt;  request&lt;&#123; code: number; data: T &#125;&gt;(config).then((res) &#x3D;&gt; &#123;    const &#123; code, data &#125; &#x3D; res.data;    return data;  &#125;);export default myRequest;</code></pre><p>到这一步我们的请求就封装好了。</p><h4 id="页面背景色"><a href="#页面背景色" class="headerlink" title="页面背景色"></a>页面背景色</h4><p>关于页面背景色，小程序有个 app.json 配置项 <code>backgroundColor</code>，如果我们在这里设置的话你会发现基本没用，那是因为这个配置项实际上指的是窗体的背景色，而非 <code>page</code> 的背景色，因此解决方案就是直接在全局样式里给 page 添加样式。</p><p>说到这个 <code>backgroundColor</code>，如果我们配置页面的 <code>enablePullDownRefresh</code> 下拉刷新，你会发现下拉刷新似乎没有动画，这是因为<code>backgroundColor</code> 默认色值是白色，而这个和动画的颜色是一样的。</p><h4 id="图片静态资源"><a href="#图片静态资源" class="headerlink" title="图片静态资源"></a>图片静态资源</h4><p>小程序要求打包后体积不超过 2m，因此图片等静态资源需要上传到 cdn （上传方法不赘述，根据自己的 cdn 工具编写脚本代码即可）。webpack 的 output 提供了 publicPath 属性来配置。</p><p>因此，在生产环境配置如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; config&#x2F;prod.jsmodule.exports &#x3D; &#123;  env: &#123;    NODE_ENV: &#39;&quot;production&quot;&#39;,  &#125;,  defineConstants: &#123;&#125;,  mini: &#123;    output: &#123;      publicPath: &#39;https:&#x2F;&#x2F;your.cdn.com&#x2F;&#39;,    &#125;,  &#125;&#125;;</code></pre><p>那么生产环境打包就会将静态资源引用地址变成诸如 “<a href="https://your.cdn.com/your.png&quot;">https://your.cdn.com/your.png&quot;</a> 的形式。</p><p>这是在 js 代码中直接引用图片的处理，还有一个容易忽略掉的地方是 css 文件中也会用到 background-image，这时候需要配置 imageUrlLoaderOption 属性</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; config&#x2F;prod.jsmodule.exports &#x3D; &#123;  env: &#123;    NODE_ENV: &#39;&quot;production&quot;&#39;,  &#125;,  defineConstants: &#123;&#125;,  mini: &#123;    &#x2F;&#x2F; ...    imageUrlLoaderOption: &#123;      limit: 0, &#x2F;&#x2F; 单位为 byte 字节      fallback: &#123;        loader: &#39;file-loader&#39;,        options: &#123;          outputPath: &#39;assets&#x2F;images&#39;,          name: &#39;[name].[ext]&#39;,          publicPath: &#39;https:&#x2F;&#x2F;your-cdn&#x2F;assets&#x2F;images&#x2F;&#39;,        &#125;,      &#125;,    &#125;,  &#125;&#125;;</code></pre><p>如此这些 css 中的图片也会转成 cdn 地址。</p><p>假设我们的静态资源全部都位于 src/assets 里，通过上述配置我们的静态资源还是会被构建到 dist/assets 目录下。此时有几个方案：</p><ol><li><p>在打包脚本里直接删除 <code>rm -rf src/assets</code></p></li><li><p>在 <code>project.config.json</code> 中配置 <code>packOptions</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;&#x2F;&#x2F;...&quot;packOptions&quot;: &#123;    &quot;ignore&quot;: [&#123;      &quot;type&quot;: &quot;folder&quot;,      &quot;value&quot;: &quot;assets&quot;    &#125;]  &#125;&#125;</code></pre><p>根据小程序的文档，这么配置将会在 <strong>打包和预览时</strong>根据规则忽略上传的文件。然而根据实测，在微信开发者工具编译时也会导致读取不到文件，这里是官方社区的回答 <a href="https://developers.weixin.qq.com/community/develop/doc/0002a2a6fe4e38a8c668c95d25b400?highLine=packOptions">https://developers.weixin.qq.com/community/develop/doc/0002a2a6fe4e38a8c668c95d25b400?highLine=packOptions</a></p><blockquote><p>目前还不支持这种需求，可以考虑在上传/预览时，才启用 packOptions 字段（例如debug时把这个字段改成 packOptions2，上传时改成 packOptions）</p></blockquote><p>怎么说呢，就挺无语的。。因此该方案不可取</p></li><li><p>通常我们不会人工打包，小程序页提供了 CI 接口来实现 CI / CD，而 CI 里提供了配置来忽略文件。下面我会在 CI 发布中详细解释。</p></li></ol><h4 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h4><p>说 CI 之前，得先设计好 git flow。小程序与 web 不同之处在于只能有一个体验版及一个线上版，而 web 我们通常是可以有测试，预发，正式等环境。而当前项目实际上有涉及直播功能，其中后台创建直播间时，服务端却无法区分环境，为此额外申请了一个小程序作为测试环境。为了方便描述，将原小程序称为 A，测试小程序称为 B。</p><p>目前设计的 git flow 如下：</p><ol><li>Release 分支对应测试环境，代码将会发布到 B，simulation 分支对应预发，代码发布到 A，master 分支仍然为线上稳定版本。</li><li>上线时将 simulation 提升版本号后合并回 master 分支，此时触发 CI 发布到 A 上。</li><li>经测试，同样开发者上传到小程序上，是会直接覆盖更新的，就是说如果 B 上面已经有了一个我已经上传了一个体验版，那么如果再次上传更新的代码，就会将之前的体验版直接覆盖掉。利用这一点，代码上到 release 时时可以不修改版本号的。如此测试同学就无需每次扫码更新测试环境的版本。那么从发布代码脚本层面上来说就是 release / simulation 分支上的代码构建时完全可以将版本号定死，而不用从 package.json 中去获取，那么需要维护版本号的地方只有 master 分支。</li><li>master 版本号主要是为了方便回滚, 这里需要写好 ChangeLog， 打 tag。</li><li>master 分支还需要注意的一点是 envVersion 此前我们根据这个值来判断环境，然而小程序在审核时这个值是不规律的，因此在master 分支打包时需要注意请求的 host 不能请求到测试环境。</li><li>版本号管理：x.y.z , 热修复则提升 z，需求提升 y，breaking change 提升 x</li></ol><h4 id="CI-发布"><a href="#CI-发布" class="headerlink" title="CI 发布"></a>CI 发布</h4><p>这里讲一下 ci 发布的部分</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const ci &#x3D; require(&#39;miniprogram-ci&#39;);&#x2F;&#x2F; ...const project &#x3D; new ci.Project(&#123;  appid: &#39;your_app_id&#39;,  type: &#39;miniProgram&#39;,  projectPath: DIST,  privateKeyPath,  ignores: [&#39;node_modules&#x2F;**&#x2F;*&#39;, &#39;assets&#x2F;**&#x2F;*&#39;],&#125;);await ci.upload(&#123;  project,  version,  desc: &#96;上传 $&#123;version&#125;&#96;,  setting: &#123;    es6: false,  &#125;,&#125;);</code></pre><p>主要还是利用微信提供的 ci ，上面的 ignore 就是我们忽略静态文件上传的配置</p><h4 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h4><p>小程序的真机预览会将代码打包后传输，同样这里预览也是要求体积不超过 2m。</p><p>可以看出小程序的预览本意是尽量模拟打包后的环境，那我们尽量不要在 dev 模式下预览，因为 dev 模式下还会打出 source map，也没有做压缩，很有可能导致代码包超过 2m 或者预览结果和最终打包结果不一致，因此我们用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">taro build --type weapp --watch</code></pre><p>这个模式进行预览，那么静态资源呢？静态资源此时还没有上传到 cdn，因此我的思路是额外注入 <code>PREVIEW=1</code>，即表示当前是预览模式</p><p>同时启动一个本地服务，我这里简单使用 koa 来搭建这个服务用于提供静态资源</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; server.jsconst Koa &#x3D; require(&#39;koa&#39;);const serve &#x3D; require(&#39;koa-static&#39;);const path &#x3D; require(&#39;path&#39;);const chalk &#x3D; require(&#39;chalk&#39;);const DIST &#x3D; path.resolve(__dirname, &#39;..&#x2F;src&#39;);const server &#x3D; async () &#x3D;&gt; &#123;  const app &#x3D; new Koa();  app.use(serve(DIST));  app.listen(3000);  console.log(chalk.green(&#39;本地静态资源服务启动，端口号：3000&#39;));&#125;;try &#123;  server();&#125; catch (error) &#123;  console.log(chalk.red(error));&#125;</code></pre><p> 在这个模式下 publicPath 为改为本地服务的 ip及端口即可，详细配置上面已经讲过类似的，这里就不展开说了。</p><p>可以看到服务器的静态资源目录是 src，为啥不是 dist 呢？其实 dist 也可以，本地预览时，静态资源还是会被构建进 dist 的。但这样小程序体积就容易超过 2m，就又回到了上面的提到过的问题。此时已经没了 ci 的帮助，因而我这里的只能去删除 dist/assets ，那么就只能从 src 去提供了。小程序实际上提供了几个 hook，分别是编译前，预览前，上传前</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; project.config.json&#123;&#x2F;&#x2F; ...&quot;scripts&quot;: &#123;    &quot;beforeCompile&quot;: &quot;&quot;,    &quot;beforePreview&quot;: &quot;rm -rf dist&#x2F;assets&quot;,    &quot;beforeUpload&quot;: &quot;&quot;  &#125;,&#125;</code></pre><p>一开始，我是在预览前将 dist/assets 删掉，后来发现这么做有几个问题：</p><ol><li>需要开启微信开发者工具的自定义处理命令</li><li>用 windows 的同学不支持 rm</li></ol><p>后面发现 Taro 提供了 plugin，暴露了构建时的一些钩子，如 <code>onBuildFinish</code>，通过自定义插件，在构建结束后删除 assets 即可，这里用了 <code>fs-extra</code> 提供的 <code>removeSync</code> 来删除，具体实现挺简单的，这里不赘述。</p><h4 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h4><p>给后面内容做铺垫，这里提前讲一下当前项目的状态管理以及选型的理由，以供参考。</p><p>目前 react 比较主流的一些状态管理有：纯 Redux，基于 Redux 的诸如 saga / dva，或者是基于观察者的 mobx， 有基于 hooks 简单封装的 unstate，同时官方也在做一个 recoil，也有一些偏门方案如 rxjs 可以说是五花八门了。这个我倒是比较欣赏 vue 的简单粗暴（别整这些幺蛾子，就用 vuex）</p><h5 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h5><p>redux 之流的模板虽然是为了更好约束开发者，但是写起来实属繁琐，因此暂不考虑。</p><h5 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h5><p>mobx 之前有做过一些尝试，mobx 给我的感觉就很像 vuex。 react 在推 fp，而 mobx 更接近 oop。</p><p>主要的问题在于和 react 一直推崇的 immutable 思路是完全不同的，mobx 更推荐的是 mutable，在一些时候 immutable 的写法反而会使数据失去响应性。</p><p>mobx 使用 Class 定义 store，那么就需要注意 this 指向等问题（例如 action 中的 this 指向，需要用 action.bound 等 api 来 hack）</p><p>更不用说还有一些常见陷阱，如 <a href="https://cn.mobx.js.org/best/react.html#%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1-consolelog">https://cn.mobx.js.org/best/react.html#%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1-consolelog</a> </p><p>当然我并不是说 oop 不如 fp，只是种种特性让我在 react 中使用 mobx 的时候感觉自己相当精分，以至于不能确定运行的结果是不是真的会如自己预期。</p><h5 id="hooks-类型的状态管理"><a href="#hooks-类型的状态管理" class="headerlink" title="hooks 类型的状态管理"></a>hooks 类型的状态管理</h5><p>这种方案一般是借助 useContext 来实现的，这种方案我并没有使用过，不过很容易想到的就是性能问题，关于性能问题可以参考 <a href="https://github.com/ascoders/weekly/blob/v2/146.%E7%B2%BE%E8%AF%BB%E3%80%8AReact%20Hooks%20%E6%95%B0%E6%8D%AE%E6%B5%81%E3%80%8B.md">https://github.com/ascoders/weekly/blob/v2/146.%E7%B2%BE%E8%AF%BB%E3%80%8AReact%20Hooks%20%E6%95%B0%E6%8D%AE%E6%B5%81%E3%80%8B.md</a> </p><p>如果只是做简单的状态管理应该是个轻量的方案，但是目前的项目而言是不太合适的。</p><h5 id="recoil"><a href="#recoil" class="headerlink" title="recoil"></a>recoil</h5><p>这个是官方在做的一个状态管理，体验的过程是，使用起来相当方便，每个状态相当于一个原子，在需要使用的时候就</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const textState &#x3D; atom(&#123;  key: &#39;textState&#39;, &#x2F;&#x2F; unique ID (with respect to other atoms&#x2F;selectors)  default: &#39;&#39;, &#x2F;&#x2F; default value (aka initial value)&#125;);function TextInput() &#123;  const [text, setText] &#x3D; useRecoilState(textState);  const onChange &#x3D; (event) &#x3D;&gt; &#123;    setText(event.target.value);  &#125;;  return (    &lt;div&gt;      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;text&#125; onChange&#x3D;&#123;onChange&#125; &#x2F;&gt;      &lt;br &#x2F;&gt;      Echo: &#123;text&#125;    &lt;&#x2F;div&gt;  );&#125;</code></pre><p>和 useState 几乎一样，同时还提供了<code>selector</code> 用于缓存提高性能，于此同时还支持 <code>React.Suspense</code> 等</p><p>实际上我挺倾向与这个方案的，但是这个库还处于实验阶段，并不推荐在生产环境中使用。</p><p>当然上述种种仅仅是我个人的一个简单实用体验，每个人习惯的编程思路不太一样，仅供参考。</p><p>那么我们最终使用的状态管理方案是 jotai + zustand。这两个可能对大家比较陌生。jotai 的 api 与 recoil 极其相似，每个状态都是一个 atom</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import &#123; atom &#125; from &#39;jotai&#39;const countAtom &#x3D; atom(0)import &#123; useAtom &#125; from &#39;jotai&#39;function Counter() &#123;  const [count, setCount] &#x3D; useAtom(countAtom)  return (    &lt;h1&gt;      &#123;count&#125;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(c &#x3D;&gt; c + 1)&#125;&gt;one up&lt;&#x2F;button&gt;)&#125;</code></pre><p>相比于 recoil，官方提出这么些优点：</p><ol><li>核心 api 更少</li><li>模版代码更少（不需要提供 key）</li><li>代码体积更小</li><li>可以很方便接入其他第三方库拓展能力，如 zustand 等</li><li>内置持久化方案</li><li>文档更友好</li></ol><p>见 <a href="https://github.com/pmndrs/jotai/issues/420">https://github.com/pmndrs/jotai/issues/420</a></p><p>关于第 4 点，小程序中加入了 zustand 这个库，主要是因为 jotai 获取或者修改 atom 是通过 hooks，那么如果我们需要在非组件的代码里取值/修改值就需要借助 zustand。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; useAtom &#125; from &#39;jotai&#39;import &#123; atomWithStore &#125; from &#39;jotai&#x2F;zustand&#39;import create from &#39;zustand&#x2F;vanilla&#39;const store &#x3D; create(() &#x3D;&gt; (&#123; count: 0 &#125;))const stateAtom &#x3D; atomWithStore(store)store.getState() &#x2F;&#x2F; &#123; count: 0 &#125;</code></pre><p>Zustand 还提供了 subscribe 等非常实用的 api。</p><p>关于第 6 点，在小程序中，如果想把状态同步到 storage，我是借助了 zustand</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; persist, StateStorage &#125; from &#39;zustand&#x2F;middleware&#39;;const storage: StateStorage &#x3D; &#123;  getItem: (name: string) &#x3D;&gt; Taro.getStorageSync(name),  setItem: (name: string, value: string) &#x3D;&gt; Taro.setStorageSync(name, value),&#125;;export const myStore &#x3D; create&lt;MyStore&gt;(  persist(    (set, get) &#x3D;&gt; (&#123;      data: [],    &#125;),    &#123;      name: &#39;myStore&#39;,      getStorage: () &#x3D;&gt; storage,    &#125;,  ),);  export const myStoreAtom &#x3D; atomWithStore&lt;MyStore&gt;(myStore);</code></pre><p>而实际上 atom 本身也是支持持久化的 <a href="https://docs.pmnd.rs/jotai/guides/persistence">https://docs.pmnd.rs/jotai/guides/persistence</a> 这里就不展开了</p><p>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 webpack 的 tree shaking</title>
      <link href="/2021/05/27/%E5%85%B3%E4%BA%8E-webpack-%E7%9A%84-tree-shaking/"/>
      <url>/2021/05/27/%E5%85%B3%E4%BA%8E-webpack-%E7%9A%84-tree-shaking/</url>
      
        <content type="html"><![CDATA[<p>最近重新翻看了下 ant design 的文档，发现这样一段话</p><blockquote><p><code>antd</code> 默认支持基于 ES modules 的 tree shaking，对于 js 部分，直接引入 <code>import &#123; Button &#125; from &#39;antd&#39;</code> 就会有按需加载的效果。</p></blockquote><p>而之前的版本要做到按需加载是通过 <a href="https://github.com/ant-design/babel-plugin-import">babel-plugin-import</a> ，通过修改引用路径来实现的。</p><p>虽然也知道 tree shaking，但没有深入去了解具体的配置。以下简单记录一下探索的过程，webpack 版本为 5.37.1。</p><a id="more"></a><p>tree shaking 简单来说就是可以将代码中没有使用到的代码移除，以减少包的体积。</p><p>根据 <a href="https://webpack.js.org/guides/tree-shaking/#conclusion">webpack 文档</a>可知，影响 webpack tree shaking 有以下几点：</p><ol><li>使用 esm 语法（import，export）</li><li>未将代码编译成 CommonJS，常见的如 @babel/preset-env 这个预设就会将代码编译成 CommonJS</li><li>package.json 添加 sideEffects 字段</li><li>mode 必须是 production</li></ol><p>文档里的说明有点绕，因此我简单写了几个 case 测试实际效果如何</p><h4 id="1-符合所有条件的情况"><a href="#1-符合所有条件的情况" class="headerlink" title="1. 符合所有条件的情况"></a>1. 符合所有条件的情况</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; a.jsexport const a1 &#x3D; &#39;a1&#39;export const a2 &#x3D; &#39;a2&#39;&#x2F;&#x2F; index.jsimport &#123; a1, a2 &#125; from &#39;.&#x2F;a&#39;console.log(a1)&#x2F;&#x2F; webpack.config.jsmode: &#39;production&#39;&#x2F;&#x2F; package.json&quot;sideEffects&quot;: false&#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;console.log(&quot;a1&quot;)&#125;)();</code></pre><p>可以看到虽然 a.js 文件中包含了 a2，但是实际打包却并未将其打包进去</p><h4 id="2-非-production-模式"><a href="#2-非-production-模式" class="headerlink" title="2. 非 production 模式"></a>2. 非 production 模式</h4><p>将上述 mode 改成 development</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 输出...&#x2F;***&#x2F; &quot;.&#x2F;src&#x2F;a.js&quot;:&#x2F;*!******************!*\  !*** .&#x2F;src&#x2F;a.js ***!  \******************&#x2F;&#x2F;***&#x2F; ((__unused_webpack_module, __webpack_exports__, __webpack_require__) &#x3D;&gt; &#123;eval(&quot;__webpack_require__.r(__webpack_exports__);\n&#x2F;* harmony export *&#x2F; __webpack_require__.d(__webpack_exports__, &#123;\n&#x2F;* harmony export *&#x2F;   \&quot;a1\&quot;: () &#x3D;&gt; (&#x2F;* binding *&#x2F; a1),\n&#x2F;* harmony export *&#x2F;   \&quot;a2\&quot;: () &#x3D;&gt; (&#x2F;* binding *&#x2F; a2)\n&#x2F;* harmony export *&#x2F; &#125;);\nconst a1 &#x3D; &#39;a1&#39;\nconst a2 &#x3D; &#39;a2&#39;\n\n&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;test-webpack&#x2F;.&#x2F;src&#x2F;a.js?&quot;);&#x2F;***&#x2F; &#125;),...</code></pre><p>可以看到这次将 a2 打包进来了，即 development 模式下是不会进行 tree shaking 的</p><p>而如果，我们开启了<code>optimization.usedExports</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; webpack.config.jsoptimization: &#123;  usedExports: true,&#125;,</code></pre><p>可以看到</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;***&#x2F; &#39;.&#x2F;src&#x2F;a.js&#39;:      &#x2F;*!******************!*\  !*** .&#x2F;src&#x2F;a.js ***!  \******************&#x2F;      &#x2F;***&#x2F; (        __unused_webpack_module,        __webpack_exports__,        __webpack_require__      ) &#x3D;&gt; &#123;        eval(          &#39;&#x2F;* harmony export *&#x2F; __webpack_require__.d(__webpack_exports__, &#123;\n&#x2F;* harmony export *&#x2F;   &quot;a1&quot;: () &#x3D;&gt; (&#x2F;* binding *&#x2F; a1)\n&#x2F;* harmony export *&#x2F; &#125;);\n&#x2F;* unused harmony export a2 *&#x2F;\nconst a1 &#x3D; &quot;a1&quot;\n\nconst a2 &#x3D; \&#39;a2\&#39;\n\n\n\n&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;test-webpack&#x2F;.&#x2F;src&#x2F;a.js?&#39;        )        &#x2F;***&#x2F;      &#125;,</code></pre><p>这里看到 <code>unused harmony export a2</code> 即 webpack 标识 a2 没有被实际使用到。</p><p>这里 optimization.usedExports 在 webpack 文档里提到，可以用于别的压缩工具压缩时移除掉。</p><p>根据文档说明，配置了<code>concatenateModules</code> 与 <code>TerserPlugin</code> ，但是没能将 a2 tree shaking 掉</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; webpack.config.js&#123;  ...  mode: &#39;development&#39;,  optimization: &#123;    usedExports: true,    minimize: true,    minimizer: [new TerserPlugin(&#123;&#125;)],    concatenateModules: true,  &#125;&#125;&#x2F;&#x2F;输出;(() &#x3D;&gt; &#123;  &#39;use strict&#39;  var __webpack_modules__ &#x3D; &#123;      &#39;.&#x2F;src&#x2F;index.js&#39;: () &#x3D;&gt; &#123;        eval(          &#39;\n;&#x2F;&#x2F; CONCATENATED MODULE: .&#x2F;src&#x2F;a.js\nconst a1 &#x3D; &quot;a1&quot;\n\nconst a2 &#x3D; \&#39;a2\&#39;\n\n\n;&#x2F;&#x2F; CONCATENATED MODULE: .&#x2F;src&#x2F;index.js\n\n\nconsole.log(a1)\n\n\n&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;test-webpack&#x2F;.&#x2F;src&#x2F;index.js_+_1_modules?&#39;        )      &#125;,    &#125;,    __webpack_exports__ &#x3D; &#123;&#125;  __webpack_modules__[&#39;.&#x2F;src&#x2F;index.js&#39;]()&#125;)()</code></pre><p>注意到上述代码是 eval 包裹的，应该由于 development 模式下 source map 默认为 eval 导致的，那么我这里将 source map 关掉</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; webpack.config.js&#123;&#x2F;&#x2F; ...mode: &#39;development&#39;,  devtool: false,  optimization: &#123;    usedExports: true,    minimize: true,    minimizer: [new TerserPlugin(&#123;&#125;)],    concatenateModules: true,  &#125;,&#125;&#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;console.log(&quot;a1&quot;)&#125;)();</code></pre><p>同样，将 mode 改成 ‘none’ 之后也是能正确 tree shaking 的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; webpack.config.js&#123;  ...  mode: &#39;none&#39;,  optimization: &#123;    usedExports: true,    minimize: true,    minimizer: [new TerserPlugin(&#123;&#125;)],    concatenateModules: true,    providedExports: true,  &#125;,&#125;&#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;console.log(&quot;a1&quot;)&#125;)();</code></pre><p>如果将相关配置移除掉，那即使是在 none 模式下也是不能正常 tree shaking 的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; webpack.config.js&#123;...mode: &#39;none&#39;,  optimization: &#123;    usedExports: true,    &#x2F;&#x2F; minimize: true,    &#x2F;&#x2F; minimizer: [new TerserPlugin(&#123;&#125;)],    &#x2F;&#x2F; concatenateModules: true,    &#x2F;&#x2F; providedExports: true,  &#125;,&#125;  &#x2F;&#x2F; 输出&#x2F;***&#x2F; ((__unused_webpack_module, __webpack_exports__, __webpack_require__) &#x3D;&gt; &#123;&#x2F;* harmony export *&#x2F; __webpack_require__.d(__webpack_exports__, &#123;&#x2F;* harmony export *&#x2F;   &quot;a1&quot;: () &#x3D;&gt; (&#x2F;* binding *&#x2F; a1)&#x2F;* harmony export *&#x2F; &#125;);&#x2F;* unused harmony export a2 *&#x2F;const a1 &#x3D; &quot;a1&quot;const a2 &#x3D; &#39;a2&#39;&#x2F;***&#x2F; &#125;)</code></pre><p>可见配置好了 usedExports 与 TerserPlugin 以及 concatenateModules 等相关配置，即使在别的 mode 下也是能将无用的代码 tree shaking 掉的，而这也是为什么文档里提到需要在 production 模式下才能 tree shaking 的原因了</p><h4 id="3-改成-commonjs"><a href="#3-改成-commonjs" class="headerlink" title="3. 改成 commonjs"></a>3. 改成 commonjs</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; index.jsconst &#123; a1 &#125; &#x3D; require(&#39;.&#x2F;a&#39;)console.log(a1)&#x2F;&#x2F; 输出（格式化后）...var e &#x3D; &#123;      85: (e, o, r) &#x3D;&gt; &#123;        &#39;use strict&#39;        r.r(o), r.d(o, &#123; a1: () &#x3D;&gt; t, a2: () &#x3D;&gt; n &#125;)        const t &#x3D; &#39;a1&#39;,          n &#x3D; &#39;a2&#39;      &#125;,    &#125;...</code></pre><p>可以看到 a2  还是被打包进来了，因此 commonjs 是不支持 tree shaking 的。奇怪的是在 <a href="https://webpack.docschina.org/blog/2020-10-10-webpack-5-release/#commonjs-tree-shaking">https://webpack.docschina.org/blog/2020-10-10-webpack-5-release/#commonjs-tree-shaking</a> 里提到 webpack5 是支持对部分 commonjs 导出做 tree shaking 的，但是我实验的结果却是没有效果，不知道是否哪里有出入</p><h4 id="4-sideEffects"><a href="#4-sideEffects" class="headerlink" title="4. sideEffects"></a>4. sideEffects</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; package.json 移除掉 sideEffects&#x2F;&#x2F; &quot;sideEffects&quot;: false&#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;console.log(&quot;a1&quot;)&#125;)();</code></pre><p>看起来即使未配置 sideEffects 能 tree shaking</p><p>对此我产生了一个疑惑，那么 sideEffects 的作用是什么？为什么文档里又说 sideEffects 是必须要配置的？比如 ant design 为什么要这么配置 <a href="https://github.com/ant-design/ant-design/blob/master/package.json#L38">sideEffects</a> 呢？</p><p>因此我又做了以下几个实验</p><ol><li><p>IIFE</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; a.jsexport const a1 &#x3D; &#39;a1&#39;export const a2 &#x3D; &#39;a2&#39;export const a3 &#x3D; (function () &#123;  console.log(&#39;a3&#39;)  return &#39;a3&#39;&#125;)()&#x2F;&#x2F; index.jsimport &#123; a1, a2 &#125; from &#39;.&#x2F;a&#39;console.log(a1)&#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;console.log(&quot;a3&quot;),console.log(&quot;a1&quot;)&#125;)();</code></pre><p>无论 package.json 中 sideEffects 是否配置，即使我们没有使用到 a3， IIFE 中的代码会被打包进去执行,但是 a3 是不会被打包进去的。</p></li><li><p>样式文件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; webpack.config.jsmodule: &#123;  rules: [    &#123;      test: &#x2F;\.css$&#x2F;i,      use: [&#39;style-loader&#39;, &#39;css-loader&#39;],    &#125;,  ],&#125;,  &#x2F;&#x2F; style.cssbody &#123;  background-color: red;&#125;  &#x2F;&#x2F; index.jsimport &#39;.&#x2F;style.css&#39;</code></pre><p>这里就有差别了，如果我们此时配置 <code>sideEffects: false</code> 那么输出将会是空白内容，如果将 <code>sideEffects: false</code> 删掉，则输出</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">...o.push([e.id, &#39;body &#123;\n  background-color: red;\n&#125;\n&#39;, &#39;&#39;])...</code></pre><p>也就是说引入样式文件会被认为一种副作用，如果 sideEffects：false，则认为我们的代码中没有包含副作用的模块，可以放心将样式文件移除。如果我们配置 <code>sideEffects：[&quot;src/style.css&quot;]</code>,即配置 style.css 为有副作用的模块，那么此时也是会将 style.css 打包进去的</p></li><li><p>polyfill</p><p>如果在代码中修改了全局变量，或原型会发生什么</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; b.jswindow.b1 &#x3D; &#39;b1&#39;Array.prototype.test &#x3D; function () &#123;  console.log(&#39;test&#39;)&#125;&#x2F;&#x2F; index.jsimport &#39;.&#x2F;b&#39;&#x2F;&#x2F; package.json&#x2F;&#x2F; sideEffects: false&#x2F;&#x2F; 输出...;(window.b1 &#x3D; &#39;b1&#39;),  (Array.prototype.test &#x3D; function () &#123;  console.log(&#39;test&#39;)&#125;)...</code></pre><p>与样式的结果是一样的，即如果配置了 sideEffect: false，则认为所有文件模块都是没有副作用的，就不会将 b.js 中的内容打包</p></li><li><p>作为 npm 包</p><p>上面的实验都是引用本地文件，那 webpack 是如何对依赖进行 tree shaking 的呢？这里我新开一个项目 test-npm，并且将当前项目 link 过去</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; npm-test src&#x2F;index.jsexport &#123; a3 &#125; from &#39;.&#x2F;a&#39;export const a1 &#x3D; &#39;a1&#39;export const a2 &#x3D; &#39;a2&#39;&#x2F;&#x2F; npm-test src&#x2F;index.jsexport const a3 &#x3D; &quot;a3&quot;window.a4 &#x3D; &quot;a4&quot;&#x2F;&#x2F; npm-test package.json&quot;module&quot;: &quot;src&#x2F;index.js&quot;,</code></pre><p>在 test-npm 中，指定 esm 入口文件为 src/index.js，在这里重新的导出 a.js 中的 a3，然而 a.js 中存在一个副作用 <code>window.a4 = &quot;a4&quot;</code>。</p><p>题外话：这里通过 module 字段制定 esm 入口，实际上 module 并不是 package.json 的标准字段，而是打包工具约定的字段，package.json 中标准的入口实际上是 main。如果我们的库需要同时支持 esm 与 commonjs，可以参考 antd，构建出 lib/ 和 es/ 两个文件夹，并配置<code>package.json</code>的<code>main</code>、<code>module</code>字段。</p><p>当我们在项目中使用时，无论是否用到 a3，都会将 a4 这个副作用引进来</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">   &#x2F;&#x2F; index.js   import &#123; a1 &#125; from &#39;test-npm&#39;   console.log(a1)      &#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;window.a4&#x3D;&quot;a4&quot;,console.log(&quot;a1&quot;)&#125;)();</code></pre><p>而当在 test-npm 中我们配置了 <code>sideEffects: false</code> 之后，只有使用到 a3 才会将 a4 这个副作用引进来。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">   &#x2F;&#x2F; index.js   import &#123; a1 &#125; from &#39;test-npm&#39;   console.log(a1)      &#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;console.log(&quot;a1&quot;)&#125;)();</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">   &#x2F;&#x2F; index.js   import &#123; a1, a3 &#125; from &#39;test-npm&#39;   console.log(a1, a3)      &#x2F;&#x2F; 输出(()&#x3D;&gt;&#123;&quot;use strict&quot;;window.a4&#x3D;&quot;a4&quot;,console.log(&quot;a1&quot;,&quot;a3&quot;)&#125;)();</code></pre><p>实际上我们还可以通过 <code>/*#__PURE__*/</code> 这个注释来表示语句是无副作用的。如果你有去注意到 babel 如何编译 jsx，你就会对这个注释比较熟悉</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; react let div &#x3D; &lt;div className&#x3D;&quot;header&quot;&gt;hello&lt;&#x2F;div&gt;;&#x2F;&#x2F; babel 编译后let div &#x3D; &#x2F;*#__PURE__*&#x2F;React.createElement(&quot;div&quot;, &#123;  className: &quot;header&quot;&#125;, &quot;hello&quot;);</code></pre><p>这里就不展开探讨</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上面的用例并没有做到完全的控制变量，仅供参考。然后这里我结合自己的理解来试图说明 webpack 中 tree shaking ：</p><p>webpack 有两个方式做 tree shaking，一方面是通过 optimization.usedExports 标记未使用的导出，然后通过压缩工具来移除。但是这种方式做不到移除包含副作用的代码，如果我们需要移除可能包含副作用的代码，就需要用到第二个方式：配置 sideEffects 告知 webpack 当前项目中哪些文件可能包含副作用或者当前项目完全没有副作用。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录保存网页的脚本优化过程</title>
      <link href="/2021/05/21/%E8%AE%B0%E5%BD%95%E4%BF%9D%E5%AD%98%E7%BD%91%E9%A1%B5%E7%9A%84%E8%84%9A%E6%9C%AC%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/05/21/%E8%AE%B0%E5%BD%95%E4%BF%9D%E5%AD%98%E7%BD%91%E9%A1%B5%E7%9A%84%E8%84%9A%E6%9C%AC%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>近期为了看文章开了网站会员，想把内容保存到本地，以便后续回顾，为此写了个脚本，记录一下思考的过程</p><a id="more"></a><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>长截图，然而一方面，长截图效果不太好，保存下来是图片，文字也不能选中，而且操作也麻烦。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>chrome dev tool 提供了 capture snapshot 的功能，可以全屏长截图，或者是对节点进行截图。功能虽好，但依然存在手动的麻烦，并且存下来还是图片</p><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>使用 html2pdf，将网页存成 pdf。<a href="https://github.com/eKoopmans/html2pdf.js">html2pdf</a> 实际上依赖了 <a href="https://github.com/niklasvh/html2canvas">html2canvas</a> 与 <a href="https://github.com/MrRio/jsPDF">jsPDF</a></p><p>存在几个问题：</p><ol><li>原网页做了特殊处理，导致绘制 canvas 时不能正确还原展示样式</li><li>保存成 pdf 时 page-breaks 配置无效，导致文本从中间被断开</li><li>pdf 实际上也是插入 cavans，所以实际体验和图片差不多</li><li>文章中的图片绘制到 canvas 时，会跨域导致无法绘制，需要将 img 标签里的 src 转成 object url 或者 base64</li></ol><p>代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var imgs &#x3D; document.querySelectorAll(&#39;img&#39;)for (let i &#x3D; 0; i &lt; imgs.length; i++) &#123;  var img &#x3D; imgs[i]  await fetch(new Request(img.src))    .then((response) &#x3D;&gt; response.blob())    .then(function (myBlob) &#123;      var objectURL &#x3D; URL.createObjectURL(myBlob)      &#x2F;&#x2F; 将 img 转为 objectURL, 防止跨域      img.src &#x3D; objectURL    &#125;)&#125;function addScript(url) &#123;  var script &#x3D; document.createElement(&#39;script&#39;)  script.type &#x3D; &#39;application&#x2F;javascript&#39;  script.src &#x3D; url  document.head.appendChild(script)&#125;addScript(  &#39;https:&#x2F;&#x2F;raw.githack.com&#x2F;eKoopmans&#x2F;html2pdf&#x2F;master&#x2F;dist&#x2F;html2pdf.bundle.js&#39;)var pdfTitle &#x3D; document.querySelector(&#39;.title&#39;).innerTexthtml2pdf()  .set(&#123;    filename: &#96;$&#123;pdfTitle&#125;.pdf&#96;,  &#125;)  .from(document.body)  .save()</code></pre><h3 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h3><p>利用无头浏览器例如 <a href="https://pptr.dev/">puppeteer</a> （以下简称 pptr）来生成 pdf。这个方案可以完美避开方案三的问题，生成的 pdf 质量也是最好的。但是需要解决一个问题：登录问题。理想的方案是使用 pptr ，启动时即可实现登录，跳转到对应的文章，保存成 pdf。鉴于实现脚本登录的成本较大，将需求拆分，即登录是在 chrome 里手动完成的，之后将整个 html 保存为本地 html，pptr 读取本地 html 并转成 pdf 即可。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>思路</p><ol><li>网站有比较多影响阅读的元素，如目录，用户信息等，需要将这些元素移除，仅保留内容和样式。</li><li>后台起一个 nodejs 搭建的本地服务，当处理完网页后，将整个 html 内容传输给服务器，服务器写入一个本地目录（这里我用 dist）保存起来</li><li>将所有需要保存的文章都存到本地后，运行生成 pdf 脚本，这个脚本读取 dist 目录所有文件，启动 pptr，依次将内容作为网页打开，保存成 pdf</li></ol><p>上述就是第一个版本的做法</p><p>本地服务 server 代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const Koa &#x3D; require(&#39;koa&#39;)const cors &#x3D; require(&#39;@koa&#x2F;cors&#39;)const bodyParser &#x3D; require(&#39;koa-bodyparser&#39;)const fs &#x3D; require(&#39;fs-extra&#39;)const path &#x3D; require(&#39;path&#39;)const app &#x3D; new Koa()&#x2F;&#x2F; 允许跨域app.use(  cors(&#123;    allowHeaders: &#39;*&#39;,  &#125;))app.use(bodyParser())app.use(async (ctx) &#x3D;&gt; &#123;  &#x2F;&#x2F; 接收 &#123; html, title &#125; 参数  const &#123; title, html &#125; &#x3D; ctx.request.body  const dir &#x3D; path.join(__dirname, &#39;..&#x2F;dist&#x2F;&#39;)  try &#123;    await fs.ensureDir(dir)    &#x2F;&#x2F; 注意 title 如果带有 &#x2F; 会导致创建文件失败，将 &#x2F; 替换成 |    &#x2F;&#x2F; 将 title 作为文件名    await fs.writeFile(path.join(dir, &#96;$&#123;title.replace(&#39;&#x2F;&#39;, &#39;｜&#39;)&#125;.html&#96;), html)    ctx.body &#x3D; &#123; code: 200 &#125;  &#125; catch (error) &#123;    console.log(error)  &#125;&#125;)&#x2F;&#x2F; 服务端口 3000app.listen(3000)</code></pre><p>网页登录后，在浏览器控制台输入如下 web,js 代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 主要内容部分var mainEle &#x3D; document.querySelector(&#39;.main&#39;)&#x2F;&#x2F; 文章标题var title &#x3D; document.querySelector(&#39;.title&#39;).innerTextdocument  .querySelectorAll(&#39;script&#39;)  .forEach((s) &#x3D;&gt; s.remove())var body &#x3D; document.querySelector(&#39;body&#39;)&#x2F;&#x2F; 移除其他内容，仅保留主要内容body.innerHTML &#x3D; &#39;&#39;body.appendChild(mainEle)&#x2F;&#x2F; 通过 fetch 将 html 及 title 传给服务端await fetch(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;&#39;, &#123;  method: &#39;POST&#39;,  headers: &#123;    &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,  &#125;,  body: JSON.stringify(&#123;    title,    html: document.documentElement.outerHTML,  &#125;),&#125;)</code></pre><p>pptr 脚本代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const puppeteer &#x3D; require(&#39;puppeteer&#39;)const path &#x3D; require(&#39;path&#39;)const fs &#x3D; require(&#39;fs-extra&#39;);(async () &#x3D;&gt; &#123;  const dist &#x3D; path.resolve(__dirname, &#39;..&#x2F;dist&#39;)  const htmls &#x3D; await fs.readdir(dist)  &#x2F;&#x2F; 启动无头浏览器  const browser &#x3D; await puppeteer.launch()  &#x2F;&#x2F; 打开新页面  const page &#x3D; await browser.newPage()  for (let i &#x3D; 0; i &lt; htmls.length; i++) &#123;    &#x2F;&#x2F; 依次读取 html 文件    const html &#x3D; htmls[i]    var contentHtml &#x3D; await fs.readFile(path.join(dist, html), &#39;utf8&#39;)    &#x2F;&#x2F; 由于页面会有图片，&#123; &#39;waitUntil&#39;: &#39;networkidle0&#39; &#125; 即等待网络请求完成后    await page.setContent(contentHtml, &#123; &#39;waitUntil&#39;: &#39;networkidle0&#39; &#125;)    &#x2F;&#x2F; 生成 pdf 文件，注意这个 api 需要在 headless 模式下才能调用    await page.pdf(&#123; path: path.join(dist, html.replace(&#39;.html&#39;, &#39;.pdf&#39;)) &#125;)  &#125; &#x2F;&#x2F; 关掉浏览器  await browser.close()&#125;)()</code></pre><h3 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h3><p>由于 web,js 中的代码会修改网页，所以每次保存完成之后，需要刷新页面，点击下一页。这需要页面重新加载脚本，样式文件等。因此我们需要一个方法不去修改原网页，所幸，这里我们可以用 cloneNode 来复制整个网页的 dom 结构，这样我们就不用修改原来的 dom 了。</p><p>web-v2.js 代码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var doc &#x3D; document.documentElement.cloneNode(true)&#x2F;&#x2F; ...</code></pre><p>这里将 document 深拷贝，之后所有的操作都基于这个深拷贝，就不会影响到原页面</p><h3 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h3><p>上述还有个问题就是需要手动点下一页，然后等待页面加载完成后，重新执行 web-v2.js 。这里也可以完全使用脚本来实现</p><p>Web-v3.js</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async function fetchWeb() &#123;  &#x2F;&#x2F; 深拷贝  var doc &#x3D; document.documentElement.cloneNode(true)  var body &#x3D; doc.querySelector(&#39;body&#39;)  var mainEle &#x3D; body.querySelector(&#39;.main&#39;)  &#x2F;&#x2F; 移除换行符号等特殊字符  var title &#x3D; body.querySelector(&#39;.title&#39;).innerText.replace(&#x2F;\s&#x2F;g, &#39;&#39;)  doc.querySelectorAll(&#39;script&#39;).forEach((s) &#x3D;&gt; s.remove())  body.innerHTML &#x3D; &#39;&#39;  body.appendChild(mainEle)  await fetch(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;&#39;, &#123;    method: &#39;POST&#39;,    headers: &#123;      &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,    &#125;,    body: JSON.stringify(&#123;      title,      html: doc.outerHTML,    &#125;),  &#125;)&#125;&#x2F;&#x2F; 延时函数async function sleep(time) &#123;  return new Promise((resolve) &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      resolve()    &#125;, time)  &#125;)&#125;&#x2F;&#x2F; 跳转下一页function next() &#123;  const btn &#x3D; document.querySelector(&#39;.next&#39;)  btn.click()&#125;&#x2F;&#x2F; total 为需要保存的页数async function fetchAll(total) &#123;  for (let i &#x3D; 0; i &lt; total; i++) &#123;    console.log(&#39;开始&#39;)    await fetchWeb()    &#x2F;&#x2F; 等待 1 s    await sleep(1000)    &#x2F;&#x2F; 点击下一页    next()    &#x2F;&#x2F; 等待 3s 页面基本都加载好了，这里其实可以做的更准确点，比如根据某个元素加载好后开始 fetchWeb    await sleep(3000)  &#125;&#125;</code></pre><p>至此，只需要在浏览器控制台上输入 web-v3 脚本一次，然后运行</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; total 为需要保存的页面数量即可fetchAll(total)</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN 版本升级指北</title>
      <link href="/2021/05/17/RN-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8C%97/"/>
      <url>/2021/05/17/RN-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p>最近客户端打算将 react-native 版本升级到 0.64.1，此前是 0.59 版本。中间踩了不少坑，记录一下升级过程。</p><a id="more"></a><ol><li><p>升级一下 react-native 和 react，由于项目使用了 Typescript，因此还要升级一下对应的 types 库</p><pre class="line-numbers language-none"><code class="language-none">npm i react-native@0.64.1 react@17.0.1 @types&#x2F;react  @types&#x2F;react-native</code></pre></li><li><p>运行后报错: Module xxxx is not a registered callable module.</p><p>根据 <a href="https://github.com/react-native-community/upgrade-support/issues/47">https://github.com/react-native-community/upgrade-support/issues/47</a> 这个 issue 提到的需要配置 metro 中的 resolver 来跳过对 node_modules 中的 react-native 的编译。这让我想到有可能是由于我们用到一个私有包（以下简称 A 吧）。A 这个包里有 react-native 的依赖，并且声明到了 dependencies 里了。因此会存在两个版本的 react-native。</p><p>考虑到这点，我对 A 中的 react-native 也进行了升级。发现即使是相同版本，依然会出现报错。因此打算先按 issue 提到的来进行配置。</p><p>issue 中提到的 resolver 配置如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const blacklist &#x3D; require(&#39;metro-config&#x2F;src&#x2F;defaults&#x2F;blacklist&#39;);module.exports &#x3D; &#123;  transformer: &#123;    getTransformOptions: async () &#x3D;&gt; (&#123;      transform: &#123;        experimentalImportSupport: false,        inlineRequires: false,      &#125;,    &#125;),  &#125;,  resolver: &#123;    blacklistRE: blacklist([      &#x2F;node_modules\&#x2F;.*\&#x2F;node_modules\&#x2F;react-native\&#x2F;.*&#x2F;,    ])  &#125;,&#125;;</code></pre><p>在 0.64.1 里并未找到 blacklist，我这里配置 resolver 为</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const exclusionList &#x3D; require(&#39;metro-config&#x2F;src&#x2F;defaults&#x2F;exclusionList&#39;);module.exports &#x3D; &#123;  transformer: &#123;    getTransformOptions: async () &#x3D;&gt; (&#123;      transform: &#123;        experimentalImportSupport: false,        inlineRequires: false,      &#125;,    &#125;),  &#125;,  resolver: &#123;    blockList: exclusionList([      &#x2F;node_modules\&#x2F;.*\&#x2F;node_modules\&#x2F;react-native\&#x2F;.*&#x2F;,    ]),  &#125;,&#125;;</code></pre><p>这时候可以成功运行。</p><p>更好的办法是，我们不在 A 中将 react-native 设置为 dependency，而仅需要最外层一个 react-native 即可。我们要做到这点，可以将  react-native 从 dependencies 中移除，改为 peerDependencies。同时为了方便开发，我们还应该将其声明到  devDependencies 中。如果做了这些，其实上述 metro 的配置就无需修改了。</p></li><li><p>运行后提示 hook 不能在函数式组件以外使用。我跟着查看了报错的组件，该组件由 A 提供，奇怪的是该组件确实是函数式组件，根据提示，怀疑可能是内外两个版本的 react 导致的，因此类似步骤一所示，将 react 依赖移出即可</p></li><li><p>加载页面时，提示有模块路径引用错误。我们项目中 babel 配置了自定义的 preset（以下简称 B）。B 中使用 babel-plugin-transform-imports 来按需加载 react-native 导出的模块。而由于 react-native 导出的模块路径变更，导致报错。我一开始在想 metro 是否会提供类似 tree-shaking 的处理，搜索后发现 metro 并不支持，见 <a href="https://github.com/facebook/metro/issues/227">https://github.com/facebook/metro/issues/227</a> 。难道只能一个个修改路径了么？</p><p>幸运的是，有这么个 pr <a href="https://github.com/facebook/metro/pull/362">https://github.com/facebook/metro/pull/362</a> ，通过 @babel/plugin-transform-modules-commonjs 将 esm 专程 commonjs 并且实现懒加载，并且还是默认为懒加载，这不就是我需要的么？因此简单处理将 babel-plugin-transform-imports 中关于 react-native 的部分全部删除即可</p></li><li><p>运行提示：A 包中的 TextPropTypes 等文件找不到。看到文档说到：</p><blockquote><p><strong>Remove PropTypes</strong>: We’re removing <code>propTypes</code> from core components in order to reduce the app size impact of React Native core and to favor static type systems which check at compile time instead of runtime</p></blockquote><p>emm，为了减少应用体积已经将 PropTypes 移除了，并且倾向于使用静态类型系统。那就没什么好说了，只能将 PropTypes 相关的移除，后续再慢慢添加类型声明文件。</p></li><li><p>提示： Warning: ReactClass: You’re attempting to include a mixin that is either null or not an object.</p><p>A 包中有部分旧的组件中用到 mixin，react 已经不推荐使用 mixin 啦，并且看到 mixin 的是 NativeMethods，目前没有场景会使用到，先简单移除掉 mixin，后续考虑重构。</p></li><li><p>报错：VirtualizedLists should never be nested inside plain ScrollViews with the same orientation - use another VirtualizedList-backed container instead. 新版本 rn 的 ScrollView 不能嵌套同方向的 VirtualizedList。</p><p>最简单的处理方式是将 ScrollView 改为 FlatList，将原先 ScrollView 中的 children 改为 FlatList 的 ListHeaderComponent, 同时注意 ScrollView 与 FlatList 可能有些 api 不太一样，需要自行调整一下。</p></li><li><p>提示：Calling <code>getNode()</code> on the ref of an Animated component is no longer necessary。Animated 组件不需要通过 getNode 来获取节点了，直接用 ref 即可</p></li><li><p>提示：Animated.event now requires a second argument for options。即此前有默认值的 useNativeDriver，现在需要手动给值了。</p></li><li><p>报错：Invariant Violation: ViewPagerAndroid has been removed from React Native. It can now be installed and imported from ‘@react-native-community/viewpager’ instead of ‘react-native’.  如果有使用到或者是第三方库有使用到 ViewPagerAndroid 的，如 react-native-scrollable-tab-view，记得升级一下，使用 @react-native-community/viewpager。</p></li></ol><p>以上为升级 RN 到 0.64.1 踩过的坑，仅供参考。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 IntersectionObserver 做曝光埋点</title>
      <link href="/2021/04/15/%E5%88%A9%E7%94%A8-IntersectionObserver-%E5%81%9A%E6%9B%9D%E5%85%89%E5%9F%8B%E7%82%B9/"/>
      <url>/2021/04/15/%E5%88%A9%E7%94%A8-IntersectionObserver-%E5%81%9A%E6%9B%9D%E5%85%89%E5%9F%8B%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>前些天接了个紧急的简单需求，有多简单呢，就是一张背景图，然后上面加上一个悬浮的按钮。果然简单！不过按惯例，不可能这么简单。果然第二天就说说加了个需求，需要在这个背景图底部继续增加两行，每行三个商品，需要统计点击和曝光事件。上报点击事件倒是简单，曝光则相对麻烦点。</p><a id="more"></a><p>正如 mdn 上所说的</p><blockquote><p>过去，相交检测通常要用到事件监听，并且需要频繁调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect"><code>Element.getBoundingClientRect()</code></a> 方法以获取相关元素的边界信息。事件监听和调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect"><code>Element.getBoundingClientRect()</code></a> 都是在主线程上运行，因此频繁触发、调用可能会造成性能问题。这种检测方法极其怪异且不优雅。</p></blockquote><p>因此如今的浏览器提供了 IntersectionObserver  这个 api ，每当被监视的元素进入或者退出另外一个元素时(或者 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Viewport">viewport</a> )，或者两个元素的相交部分大小发生变化时，该回调方法会被触发执行。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>在了解如何使用之前，作为开发者我们往往比较关心的一个问题是：这个 API 的兼容性如何？</p><p>在 <a href="https://caniuse.com/?search=IntersectionObserver%20%20">can i use</a> 上看到大部分的浏览器是支持的</p><p><img src="https://i.loli.net/2021/04/15/SJXa9fkoCY1q3AE.png" alt="image.png"></p><p>那有人就问了，如果老板就是要兼容 IE 呢 😂 </p><p>幸好 IntersectionObserver  提供了 <a href="https://github.com/w3c/IntersectionObserver/tree/main/polyfill">polyfill</a> ，我们只需要按照文档引入<code>polyfill</code> 就好了。简单瞄了一下 polyfill 源码应该就是回退到 getBoundingClientRect 方案。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>原先的代码是原生 js 写的，后来（惯例）又加了一些 AB 实验等需求，索性改成 vue 写反而更快了，页面结构大致如下所示。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;template&gt;  &lt;div&gt;    &lt;img class&#x3D;&quot;bg-img&quot; :src&#x3D;&quot;bg-img&quot; &#x2F;&gt;    &lt;img      v-for&#x3D;&quot;product in productList&quot;      :key&#x3D;&quot;product.id&quot;      :src&#x3D;&quot;product.src&quot;      class&#x3D;&quot;product-img&quot;    &#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre><p>第一步，我们需要创建一个 observer</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 声明当观察到元素进出视口时触发的回调函数const callback &#x3D; (changes) &#x3D;&gt; &#123;  changes.forEach(function(change) &#123;    &#x2F;&#x2F; el 即为我们观察的元素    const el &#x3D; change.target;      &#x2F;&#x2F; 上报曝光    console.log(&quot;exposure&quot;, change);      &#x2F;&#x2F; 取消观察    observer.unobserve(el);  &#125;);&#125;&#x2F;&#x2F; IntersectionObserver 可以接收两个参数，第二个参数 opt 可以定义容器（默认为视口）等配置,这里不展开讲，详细可看 mdn 文档const observer &#x3D; new IntersectionObserver(callback，opt || &#123;&#125;);</code></pre><p>第二步，我们需要在页面初始化的时候观察。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">mounted() &#123;[...document.querySelectorAll(&quot;.product-img&quot;)].forEach(item &#x3D;&gt; &#123;    observer.observe(item);  &#125;);&#125;</code></pre><p>大功告成？no.</p><h3 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h3><p>实际上如果这么写的话会有几个问题。</p><ol><li><p>首先就是我们一打开页面，就会发现触发所有的了上报曝光事件。这个问题就出在当我们 observe 的时候，就会触发一次回调，即使元素并没有进出视口。那么我们要做的就是判断元素是否在视口中即可，调整 callback</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 声明当观察到元素进出视口时触发的回调函数const callback &#x3D; (changes) &#x3D;&gt; &#123;  changes.forEach(function(change) &#123;    &#x2F;&#x2F; el 即为我们观察的元素    const el &#x3D; change.target;    if (change.intersectionRatio &gt; 0) &#123;    &#x2F;&#x2F; 上报曝光    console.log(&quot;exposure&quot;, change);    &#x2F;&#x2F; 取消观察    observer.unobserve(el);    &#125;  &#125;);&#125;&#x2F;&#x2F; IntersectionObserver 可以接收两个参数，第二个参数 opt 可以定义容器（默认为视口）等配置,这里不展开讲，详细可看 mdn 文档const observer &#x3D; new IntersectionObserver(callback，opt || &#123;&#125;);</code></pre><p>通过 change.intersectionRatio 可以知道元素在视口中交叉的比例是多少，如果大于 0 则证明元素是在视口中，此时才需要曝光。</p></li><li><p>经过上述的修改，我们打开页面再看，emmm… 还是一开始就把所有的元素曝光都上报了啊。让我们来看看曝光时 change 的一些属性</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#123;  &#x2F;&#x2F; ...其他一些属性  &#x2F;&#x2F; 交叉比例  intersectionRatio: 1  &#x2F;&#x2F; 目标元素的属性  boundingClientRect: &#123;    bottom: 0    height: 0    left: 0    right: 375    top: 0    width: 375    x: 0    y: 0  &#125;&#125;</code></pre><p>可以看到 intersectionRatio = 1 即说明元素确确实实在视口中了，而 boundingClientRect 中的 height 表示当时元素的高度还是 0，再一看 y 也是 0。瞬间想到：mounted 的时候，图片都还没加载好，那么此时页面还没有撑开，自然所有的产品卡片都是在视口中！也就是说我们 observe 的时机不正确。那么正确的时机应该是在页面 onload 之后，而非在组件的 mounted 事件中。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">mounted() &#123;window.addEventListener(&#39;load&#39;, function() &#123;    [...document.querySelectorAll(&quot;.product-img&quot;)].forEach(item &#x3D;&gt; &#123;    observer.observe(item);  &#125;);  &#125;)&#125;</code></pre><p>至此就可以正常上报曝光。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>总结，IntersectionObserver 有如下几个优点：</p><ol><li>提供的 Api 友好，使用起来简单</li><li>兼容性不错，并且提供了 polyfill</li><li>性能方面浏览器做了相关优化</li><li>适用性广泛，应用场景则包括上述的曝光埋点，图片懒加载，无限滚动等等</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inversify 初体验</title>
      <link href="/2021/04/01/inversify-%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2021/04/01/inversify-%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈 styled-components</title>
      <link href="/2021/03/30/%E8%B0%88%E8%B0%88%20styled-components/"/>
      <url>/2021/03/30/%E8%B0%88%E8%B0%88%20styled-components/</url>
      
        <content type="html"><![CDATA[<p>早在刚开始接触 React 的时候就有听闻过 <code>css in js</code> 的理念，中间也简单使用过 <code>styled-components</code>，但用到最后总因为各种原因放弃。这次刚好心血来潮又想重新试试，同时记录一下从个人角度来看 <code>styled-components</code> 的优缺点，以便将来选型时作为参考之用。</p><a id="more"></a><p>基于 create-react-app 搭建的 TypeScript 项目，至于如何加入 styled-components，这里不赘述，按照文档很简单就可以完成了。以下简称为 <code>sc</code>。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>简单使用方法如下:</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import styled from &#39;styled-components&#39;const Title &#x3D; styled.h1&#96;  font-size: 1.5em;&#96;;render(  &lt;Title&gt;    Hello World!  &lt;&#x2F;Title&gt;);</code></pre><p>最终编译出来的是一个独特的 hash 值的样式名，这可以避免我们样式名称被覆盖，而在此之前我们往往需要配置 css modules， 如果是 create react app 创建的项目，往往会用 .module.css 来表示 css 模块。而 sc 则自带了这个特性，我觉得这是他的第一个优点。</p><p>styled-components 可以传 props。</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import styled from &#39;styled-components&#39;const Title &#x3D; styled.h1&lt;&#123;isRed: boolean&#125;&gt;&#96;  font-size: 1.5em;color: $&#123;props &#x3D;&gt; props.isRed ? &#39;red&#39; : &#39;black&#39;&#125;&#96;;const isRed &#x3D; ...render(  &lt;Title isRed&#x3D;&#123;isRed&#125;&gt;    Hello World!  &lt;&#x2F;Title&gt;);</code></pre><p>而在使用 styled-components 之前，我们要做到这个效果往往是在 style 里处理，或者是通过样式名来控制</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&#x2F;&#x2F; 在 style 里处理，不方便复用render(  &lt;h1 style&#x3D;&#123;&#123; color: isRed ? &#39;red&#39; : &#39;black&#39; &#125;&#125;&gt;    Hello World!  &lt;&#x2F;h1&gt;);&#x2F;&#x2F; 通过样式名控制较为繁琐.red &#123; color: &#39;red&#39; &#125;.black &#123; color: &#39;black&#39; &#125;render(  &lt;h1 className&#x3D;&#123;isRed ? &#39;red&#39; : &#39;black&#39;&#125;&gt;    Hello World!  &lt;&#x2F;h1&gt;);</code></pre><p>这是 styled-components 的第二个优点。</p><p>有个场景比较经常出现在维护旧代码的时候，往往有的组件不需要了，我们可以简单移除掉，但是这个组件所使用的样式名却不敢轻易删掉，因为鬼知道这个样式是不是别的地方用到了。而这个则是 sc 中样式组件则不存在这个问题，所以这是第三个优点：便于维护。</p><p>以上是我觉得感知比较强烈的优点，当然还有一些别的优点这里就不说了，具体可以查看文档。</p><p>说完了优点，说说开发时遇到的缺点吧</p><p>第一个就是由于 sc 实际上就是组件，而这个往往会让我分不清哪些是样式组件，哪些是 React 组件，就是显得不够直观。</p><p>第二个是有一些组件，实际上只是一行样式就解决了，那么每次都需要重新写一个 sc 组件，反而显得繁琐。官方是推荐可以使用 <code>css prop</code>  来解决</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import &#123; css &#125; from &#39;styled-components&#x2F;macro&#39;render(  &lt;h1 css&#x3D;&#123;css&#96;font-size: 1.5em;&#96;&#125;&gt;    Hello World!  &lt;&#x2F;h1&gt;);</code></pre><p>这个功能需要有babel-plugin-styled-components 或者 babel-plugin-macro 的支持，create react app 默认支持了,详情看<a href="https://styled-components.com/docs/api#css-prop">文档</a>。</p><p>如果是 Typescript，由于原先的组件上并没有 css 这个属性，则需要额外在全局引入</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import &#123;&#125; from &#39;styled-components&#x2F;cssprop&#39;</code></pre><p>文档中提到 <code>css prop</code> 实际上也是将组件转为样式组件，而如果是在 typescript 中需要传递自定义 prop，我不知道该如何定义类型?</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import &#123; css &#125; from &#39;styled-components&#x2F;macro&#39;const Title &#x3D; css&#96;font-size: 1.5em;color: &#123;props &#x3D;&gt; props.color&#125;&#96;render(  &#x2F;&#x2F; 此时将提示 color 类型错误云云。。  &lt;h1 css&#x3D;&#123;Title&#125; color&#x3D;&quot;red&quot;&gt;    Hello World!  &lt;&#x2F;h1&gt;);</code></pre><p>第三个是样式复用，即如果我有相同的样式想要用在不同的组件上，sc 也是推荐使用 <code>css props</code>，而 css props 的体验是在是不敢说很好。</p><p>就我个人而言目前主要是这三点用着不爽。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>那么 <code>sc</code> 为什么可以通过 <code>styled</code>来给组件添加样式的呢？</p><p>es6 提供了 `` 作为模板字符串，我们通常的用法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const name &#x3D; &#96;$&#123;firstName&#125;$&#123;secondName&#125;&#96;</code></pre><p>而如果 ``是跟随在一个函数时，则该函数将被调用来处理这个模板字符串，这个称为标签模板</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log&#96;hi&#96;&#x2F;&#x2F; 等同于console.log(&#39;hi&#39;)</code></pre><p>关于这部分可以查阅 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates">MDN 相关文档</a></p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">styled.div&#96;color: red&#96;&#x2F;&#x2F; 等同于styled.div([&#39;\n  color: red;\n&#39;])</code></pre><p>在编译后的代码中可以看到一段如下代码，不难猜测出 <code>Object(i.a)</code> 就是 <code>styled.div</code></p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">var n &#x3D; Object(i.a)([&#39;\n  color: red;\n&#39;])</code></pre><p><code>styled.div</code>等同于 <code>styled(&#39;div&#39;)</code>，因而 <code>styled</code> 可以看作一个高阶组件</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const StyledComponent &#x3D; styled(Component)(styles)</code></pre><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>为了解决一两行代码也要用 <code>css prop</code> 的情况，我引入了 <code>tailwindcss</code>，这个 css 框架中的原子性类名理念非常契合我的问题。我觉得这两个框架搭配写起来还是比较顺畅的。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 react 中使用 rxjs</title>
      <link href="/2021/03/24/%E5%9C%A8-react-%E4%B8%AD%E4%BD%BF%E7%94%A8-rxjs/"/>
      <url>/2021/03/24/%E5%9C%A8-react-%E4%B8%AD%E4%BD%BF%E7%94%A8-rxjs/</url>
      
        <content type="html"><![CDATA[<p>最近出于学习目的在临摹一个在线 ppt 的开源项目。原项目使用的是 vue3，我则打算用 react 来实现，同时玩一些暂时不会在工作中使用到的技术，比如 rxjs。本文用于记录在 react 中加入 rxjs 的过程，本人也是在学习过程中，因此以下仅为个人理解，并不代表最佳实践。</p><a id="more"></a><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>每次点击”添加幻灯片”按钮，创建一张幻灯片，并创建一个历史快照，创建历史快照是一个 debounce 后的方法。即如果快速点击多次”添加幻灯片”， 也仅创建一个历史快照。</p><h4 id="React-通常写法"><a href="#React-通常写法" class="headerlink" title="React 通常写法"></a>React 通常写法</h4><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React from &#39;react&#39;import debounce from &#39;lodash&#x2F;debounce&#39;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  const createSnapshot &#x3D; debounce(() &#x3D;&gt; &#123;    console.log(&#39;create snapshot&#39;)  &#125;, 300)  const createSlide &#x3D; () &#x3D;&gt; &#123;    console.log(&#39;create slide&#39;)  &#125;  const handleClick &#x3D; () &#x3D;&gt; &#123;    createSlide()    createSnapshot()  &#125;  return (    &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;  )&#125;export default CreateSlideButton</code></pre><h4 id="改成-rxjs-实现"><a href="#改成-rxjs-实现" class="headerlink" title="改成 rxjs 实现"></a>改成 rxjs 实现</h4><p>在 rxjs 里，数据 / 事件 是一个流的概念。比如我们点击按钮，每点击一次，那么这个事件流就多了一个点击事件。</p><p>我们需要做的就是在组件创建这么个事件流并且订阅，每当事件流有新的事件，那么就会执行我们的回调函数，当然别忘了在组件卸载的时候，需要取消订阅。</p><p>具体来说，通常我们会以 <code>$</code> 结尾来表示这是一个流，订阅这个流实际上就是执行流的 subscribe 方法，subscribe 接收的第一个参数就是当事件流有新事件时执行的回调。而卸载则是指流的 unsubscribe 方法。</p><p>那么如何创建一个流呢？rxjs 提供了很多操作符，通常我们可以通过 <code>fromEvent</code>创建一个事件流</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; fromEvent &#125; from &#39;rxjs&#39;;const clickEvt$ &#x3D; fromEvent(document, &#39;click&#39;);</code></pre><p>但是 react 有自己的合成事件机制，显然上面的写法不太合适。我们需要自己来创建一个流，这个流可以接收 react 事件，同时这个流可以被订阅。我们称这样的流为 Subject。那么现在创建一个流可以这么写</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  const clickEvt$ &#x3D; new Subject();  const handleClick &#x3D; () &#x3D;&gt; &#123;    clickEvt$.next();  &#125;;  return &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;;&#125;;export default CreateSlideButton;</code></pre><p>上述代码通过 <code>const clickEvt$ = new Subject();</code> 创建了一个点击事件流，并且在每次 <code>onClick</code> 的时候，<code>clickEvt$.next();</code>给事件流推送一个事件。</p><p>但是这个写法明显有个问题，每次组件更新的时候都将创建一个新的 <code>clickEvt$</code>，这里我们用<code>useMemo</code>包起来</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useMemo &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  const clickEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  const handleClick &#x3D; () &#x3D;&gt; &#123;    clickEvt$.next();  &#125;;  return &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;;&#125;;export default CreateSlideButton;</code></pre><p>接着我们需要在组件初始化时订阅这个事件流，并且在组件卸载时取消订阅这个事件流。</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useMemo &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  const clickEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  useEffect(() &#x3D;&gt; &#123;    clickEvt$.subscribe(() &#x3D;&gt; &#123;      console.log(&quot;click&quot;);    &#125;);    return () &#x3D;&gt; clickEvt$.unsubscribe();  &#125;, [clickEvt$]);  const handleClick &#x3D; () &#x3D;&gt; &#123;    clickEvt$.next();  &#125;;  return &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;;&#125;;export default CreateSlideButton;</code></pre><p>至此我们点击按钮后，将打印 “click”。</p><p>那么如何实现创建 幻灯片和历史快照自然就不言而喻了</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useMemo &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;import debounce from &quot;lodash&#x2F;debounce&quot;;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  &#x2F;&#x2F; 创建点击事件流  const clickEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  const [createSnapshot, createSlide] &#x3D; useMemo(    () &#x3D;&gt; [      debounce(() &#x3D;&gt; &#123;        console.log(&quot;create snapshot&quot;);      &#125;, 300),      () &#x3D;&gt; &#123;        console.log(&quot;create slide&quot;);      &#125;    ],    []  );  useEffect(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 订阅    clickEvt$.subscribe(() &#x3D;&gt; &#123;      createSlide();      createSnapshot();    &#125;);    &#x2F;&#x2F; 取消订阅    return () &#x3D;&gt; clickEvt$.unsubscribe();  &#125;, [clickEvt$, createSnapshot, createSlide]);  const handleClick &#x3D; () &#x3D;&gt; &#123;    &#x2F;&#x2F; 推送点击事件    clickEvt$.next();  &#125;;  return &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;;&#125;;export default CreateSlideButton;</code></pre><p>还有可以改造的地方么？</p><p>既然我们接受了 frp 的编程思想，是否可以这么思考，我们每次点击，就产生了点击事件流，而点击事件的回调中，我们又派发了创建历史快照这个事件？那么创建历史快照这个事件应该也有自己的流！</p><p>从这个角度我们用同样的方法改造一下代码</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useMemo &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;import debounce from &quot;lodash&#x2F;debounce&quot;;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  const clickEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  &#x2F;&#x2F; 初始化 创建快照事件流  const createSnapshotEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  const [createSnapshot, createSlide] &#x3D; useMemo(    () &#x3D;&gt; [      debounce(() &#x3D;&gt; &#123;        console.log(&quot;create snapshot&quot;);      &#125;, 300),      () &#x3D;&gt; &#123;        console.log(&quot;create slide&quot;);      &#125;    ],    []  );  useEffect(() &#x3D;&gt; &#123;    createSnapshotEvt$.subscribe(() &#x3D;&gt; &#123;      createSnapshot();    &#125;);    return () &#x3D;&gt; createSnapshotEvt$.unsubcribe()  &#125;, [createSnapshotEvt$, createSnapshot]);  useEffect(() &#x3D;&gt; &#123;    clickEvt$.subscribe(() &#x3D;&gt; &#123;      createSlide();      &#x2F;&#x2F; 推送创建快照事件      createSnapshotEvt$.next();    &#125;);    return () &#x3D;&gt; clickEvt$.unsubscribe();  &#125;, [clickEvt$, createSnapshotEvt$, createSlide]);  const handleClick &#x3D; () &#x3D;&gt; &#123;    clickEvt$.next();  &#125;;  return &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;;&#125;;export default CreateSlideButton;</code></pre><p>实际上 createSlide 也可以单独创建事件流，这里不赘述。那么上面写法有什么好处呢？</p><p>好处就是 rxjs 提供了大量的操作符，其中就包括了 <code>debounceTime</code>。因此我们可以这么写</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useMemo &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;import &#123; debounceTime &#125; from &quot;rxjs&#x2F;operators&quot;;const CreateSlideButton &#x3D; () &#x3D;&gt; &#123;  const clickEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  const createSnapshotEvt$ &#x3D; useMemo(() &#x3D;&gt; new Subject(), []);  const [createSnapshot, createSlide] &#x3D; useMemo(    () &#x3D;&gt; [      () &#x3D;&gt; &#123;        console.log(&quot;create snapshot&quot;);      &#125;,      () &#x3D;&gt; &#123;        console.log(&quot;create slide&quot;);      &#125;    ],    []  );  useEffect(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 通过 .pipe 对事件流进行 debounce 操作    createSnapshotEvt$.pipe(debounceTime(300)).subscribe(() &#x3D;&gt; &#123;      createSnapshot();    &#125;);    return () &#x3D;&gt; createSnapshotEvt$.unsubcribe();  &#125;, [createSnapshotEvt$, createSnapshot]);  useEffect(() &#x3D;&gt; &#123;    clickEvt$.subscribe(() &#x3D;&gt; &#123;      createSlide();      createSnapshotEvt$.next();    &#125;);    return () &#x3D;&gt; clickEvt$.unsubscribe();  &#125;, [clickEvt$, createSnapshotEvt$, createSlide]);  const handleClick &#x3D; () &#x3D;&gt; &#123;    clickEvt$.next();  &#125;;  return &lt;div onClick&#x3D;&#123;handleClick&#125;&gt;创建幻灯片&lt;&#x2F;div&gt;;&#125;;export default CreateSlideButton;</code></pre><p>可以看到我们不再需要 lodash 的 debounce 对 createSnapshot 进行操作，而是对事件流进行 debounce 操作。</p><h4 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h4><p>上面举出的例子里 <code>observable</code> 的 <code>observer</code> 很简单，就直接 console.log 就完事儿了。然而在实际的开发场景中，确并非如此简单。上面的代码太长了，因此重新举一个例子</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useState &#125; from &#39;react&#39;import &#123; of &#125; from &#39;rxjs&#39;export default function App() &#123;  const [count, setCount] &#x3D; useState(0)  const sum &#x3D; (val) &#x3D;&gt; setCount(count + val)  useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; of(1, 2, 3).subscribe(sum)    return () &#x3D;&gt; subscription.unsubscribe()  &#125;, [])  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;&#125;</code></pre><p>上面这个例子，我的本意是希望订阅一个 <code>of</code>  流，并且将产出的值相加后展示出来，也就是说我预期是能打印出 <code>0 + 1 + 2 + 3 = 6</code>。但一旦如果按上面的写法，输出将会是 <code>3</code>。如果有开启 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a>，eslint 会提示 <code>React Hook useEffect has a missing dependency: &#39;sum&#39;. Either include it or remove the dependency array</code>。实际上就是因为我们没有正确去配置 <code>useEffect</code> 的依赖，导致 <code>sum</code> 中获取到的 <code>count</code> 一直是 0，因此最终输出为 3。那我们稍加改进</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useState, useCallback &#125; from &#39;react&#39;import &#123; of &#125; from &#39;rxjs&#39;export default function App() &#123;  const [count, setCount] &#x3D; useState(0)  const sum &#x3D; useCallback((val) &#x3D;&gt; setCount(count + val), [count])  useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; of(1, 2, 3).subscribe(sum)    return () &#x3D;&gt; subscription.unsubscribe()  &#125;, [sum])  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;&#125;</code></pre><p>这次我们给 useEffect 添加了 <code>sum</code> 作为依赖，并且给 <code>sum</code> 包裹了 <code>useCallback</code>。这个时候，打开页面发现，页面上的数字不断增加。原因是我们每次 <code>setCount</code> 之后，<code>count</code> 更新导致 <code>sum</code> 更新，同时也导致不断执行 <code>useEffect</code> 中的方法，即不断的 <code>subscribe</code>  与 <code>unsubscribe</code>。</p><p>react 为 setState 提供了一种函数回调的方式，即可以通过 <code>setCount(count =&gt; count + val)</code>这样的形式来获取旧值，那么代码可以改成</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useState, useCallback &#125; from &#39;react&#39;import &#123; of &#125; from &#39;rxjs&#39;export default function App() &#123;  const [count, setCount] &#x3D; useState(0)const sum &#x3D; useCallback((val) &#x3D;&gt; setCount((count) &#x3D;&gt; count + val), [])  useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; of(1, 2, 3).subscribe(sum)    return () &#x3D;&gt; subscription.unsubscribe()  &#125;, [sum])  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;&#125;</code></pre><p>这一次页面显示了预期的 <code>6</code>。</p><p>经过上面的改写，我们获取到了预期的结果，之后我一度考虑是否能通过将 sum 保存到 ref 中，从而将 sum 从 依赖项中移除呢？</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useState, useCallback, useRef &#125; from &#39;react&#39;import &#123; of &#125; from &#39;rxjs&#39;export default function App() &#123;  const [count, setCount] &#x3D; useState(0)  const sum &#x3D; useCallback((val) &#x3D;&gt; setCount((count) &#x3D;&gt; count + val), [])  const latestSum &#x3D; useRef(sum)  useEffect(() &#x3D;&gt; &#123;    latestSum.current &#x3D; sum  &#125;)  useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; of(1, 2, 3).subscribe(latestSum.current)    return () &#x3D;&gt; subscription.unsubscribe()  &#125;, [])  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;&#125;</code></pre><p>很遗憾，上面的写法是能输出预期结果，然而实际上这么写却并非正确。因为上述的例子只是恰好 sum 不会变更，从而只需要 subscribe 一次。假设 sum 会变更，那么 subscribe 订阅的将一直是初始化时的 sum，而非最新的 sum。将上述代码改成</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useState, useCallback, useRef &#125; from &#39;react&#39;import &#123; of &#125; from &#39;rxjs&#39;export default function App() &#123;  const [count, setCount] &#x3D; useState(0)  const sum &#x3D; useCallback((val) &#x3D;&gt; setCount(count + val), [count])  const latestSum &#x3D; useRef(sum)  useEffect(() &#x3D;&gt; &#123;    latestSum.current &#x3D; sum  &#125;)  useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; of(1, 2, 3).subscribe(latestSum.current)    return () &#x3D;&gt; subscription.unsubscribe()  &#125;, [])  return &lt;div&gt;&#123;count&#125;&lt;&#x2F;div&gt;&#125;</code></pre><p>页面将会输出 3，即 latestSum.current 中的 count 一直是 0。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看到对于原代码而言，rxjs 的实现反而多了很多代码，不过上面的例子只是给到一个启发与入门的作用，让我们从函数响应式编程的角度去思考如何组织代码，而往往在更复杂的场景才能真正展示 rxjs 的威力，是否要使用 rxjs 需要根据具体的场景来考量。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 中的 unknown 类型</title>
      <link href="/2021/03/20/TypeScript-%E4%B8%AD%E7%9A%84-unknown-%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/03/20/TypeScript-%E4%B8%AD%E7%9A%84-unknown-%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>早在 TypeScript 3.0 中就新增加了一种 unkown 类型 <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type">New <code>unknown</code> top type</a>，然而目前中文文档似乎还没有相关的说明，而<a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown">英文文档</a>中也仅有简短的一点说明。那么 unknown 的应用场景是什么，为什么需要新增这个类型呢？以下为结合官方 wiki，就比较常见的应用场景做的个人笔记总结。</p><a id="more"></a><p>如果将类型看作一个集合的话，那么顶部类型则包含了所有其他类型，而底部类型则不包含其他所有类型。在 typescript 中，底部类型则是 never。而 unknown  类型与 any 非常相似，都是顶部类型。</p><p>我们知道如果使用了 any，那就几乎意味着放弃了类型保护，我们可以使用 any 做任何事情，而 unknown 却恰恰相反，我们几乎无法利用 unknown 来做任何事情。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f1(a: any) &#123;  a.b(); &#x2F;&#x2F; OK&#125;function f2(a: unknown) &#123;  a.b();  &#x2F;&#x2F; error: Object is of type &#39;unknown&#39;.&#125;</code></pre><p>要使用 unknown 前须通过类型断言等方式确定类型，因此在面对未知类型时，使用 unknown 比 any 更加安全。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">declare interface A &#123;  b: Function;&#125;declare function isA(x: unknown): x is A;function func(x: unknown) &#123;  &#x2F;&#x2F; 类型断言  (x as number).toFixed(2);    &#x2F;&#x2F; 相等  if(x &#x3D;&#x3D;&#x3D; 123) &#123;    x; &#x2F;&#x2F; 123  &#125;    &#x2F;&#x2F; 类型防护  if (typeof x &#x3D;&#x3D;&#x3D; &#39;string&#39; || typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;    x; &#x2F;&#x2F; string | number  &#125;  if (x instanceof Error) &#123;    x; &#x2F;&#x2F; Error  &#125;    &#x2F;&#x2F; 断言函数  if (isA(x)) &#123;    x.b();  &#125;&#125;</code></pre><p>那么 unknown 与 any 具体还有哪些区别呢？</p><ol><li><p>作为顶部类型，则意味着所有的类型都可以赋值给 unknown，然而 unknown 只能赋值给 any 或者 unknown。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Anything is assignable to unknownfunction f21&lt;T&gt;(pAny: any, pNever: never, pT: T) &#123;  let x: unknown;  x &#x3D; 123;  x &#x3D; &quot;hello&quot;;  x &#x3D; [1, 2, 3];  x &#x3D; new Error();  x &#x3D; x;  x &#x3D; pAny;  x &#x3D; pNever;  x &#x3D; pT;&#125;&#x2F;&#x2F; unknown assignable only to itself and anyfunction f22(x: unknown) &#123;  let v1: any &#x3D; x;  let v2: unknown &#x3D; x;  let v3: object &#x3D; x; &#x2F;&#x2F; Error  let v4: string &#x3D; x; &#x2F;&#x2F; Error  let v5: string[] &#x3D; x; &#x2F;&#x2F; Error  let v6: &#123;&#125; &#x3D; x; &#x2F;&#x2F; Error  let v7: &#123;&#125; | null | undefined &#x3D; x; &#x2F;&#x2F; Error&#125;</code></pre></li><li><p>在联合类型中，any 交叉(&amp;)或者联合(|)任何类型, 除了 never 外都为 any，而 unknown 交叉(&amp;)任何类型都为其所交叉类型，联合(|)任何类型(除了 any 外)都为 unknown</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type T00 &#x3D; unknown &amp; null; &#x2F;&#x2F; nulltype T03 &#x3D; unknown &amp; string; &#x2F;&#x2F; stringtype T06 &#x3D; unknown &amp; any; &#x2F;&#x2F; anytype T00 &#x3D; any &amp; null; &#x2F;&#x2F; anytype T02 &#x3D; any &amp; null &amp; undefined; &#x2F;&#x2F; null &amp; undefined (which becomes never)type T03 &#x3D; any &amp; string; &#x2F;&#x2F; any</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type T10 &#x3D; unknown | null; &#x2F;&#x2F; unknowntype T13 &#x3D; unknown | string; &#x2F;&#x2F; unknowntype T16 &#x3D; unknown | any; &#x2F;&#x2F; anytype T10 &#x3D; any | null; &#x2F;&#x2F; anytype T12 &#x3D; any | null | undefined; &#x2F;&#x2F; anytype T13 &#x3D; any | string; &#x2F;&#x2F; any</code></pre></li><li><p>在之前泛型类型默认为 <code>&#123;&#125;</code>, 现在则默认为 unknown。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function foo&lt;T&gt;(x: T): [T, string] &#123;    return [x, x.toString()]    &#x2F;&#x2F;           ~~~~~~~~ TypeScript 3.5 之后将会报错：error! Property &#39;toString&#39; does not exist on type &#39;T&#39;.&#125;</code></pre><p>如果要不报错，可以这么写</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function foo&lt;T extends &#123;&#125;&gt;(x: T): [T, string] &#123;    return [x, x.toString()]&#125;</code></pre></li><li><p>function 如果返回的是 unknown ，则可以没有返回语句</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f27(): unknown &#123;&#125;</code></pre></li></ol><p>简单来说，unknown 主要的场景就是，当我们需要一个值，这个值可以是任何类型，但是在使用这个值前，需要先判断类型以确保类型安全。换句话说，在使用 any 前，可以先试试 unknown。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-OOP.md</title>
      <link href="/2021/02/19/JavaScript-OOP/"/>
      <url>/2021/02/19/JavaScript-OOP/</url>
      
        <content type="html"><![CDATA[<p>在平时的 CodeReview 中要如何去分辨代码的好坏呢？最近看到 <a href="https://github.com/ryanmcdermott/clean-code-javascript">https://github.com/ryanmcdermott/clean-code-javascript</a> 这个仓库的总结，感觉蛮有参考价值的。特别是关于类这一章，涉及很多设计模式的思想。刚好相关的中文仓库似乎缺失了类这章节的翻译，以下为类以及 SOLID 这个章节的翻译并添加个人理解。</p><a id="more"></a><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="最好使用-ES2015-ES6-classes-而非-ES5-的函数"><a href="#最好使用-ES2015-ES6-classes-而非-ES5-的函数" class="headerlink" title="最好使用  ES2015/ES6 classes 而非 ES5 的函数"></a>最好使用  ES2015/ES6 classes 而非 ES5 的函数</h3><p>传统的 ES5 类的继承，构造，以及内部方法可读性非常差，在需要继承（当然你也可以无需继承）的场景下，推荐使用  ES2015/ES6 classes。如果你需要一个大型且极度复杂的对象，那么可以使用 function 替代 class。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const Animal &#x3D; function(age) &#123;  if (!(this instanceof Animal)) &#123;    throw new Error(&quot;Instantiate Animal with &#96;new&#96;&quot;);  &#125;  this.age &#x3D; age;&#125;;Animal.prototype.move &#x3D; function move() &#123;&#125;;const Mammal &#x3D; function(age, furColor) &#123;  if (!(this instanceof Mammal)) &#123;    throw new Error(&quot;Instantiate Mammal with &#96;new&#96;&quot;);  &#125;&#x2F;&#x2F; 调用父类的构造函数，初始化当前子类的 this 的 age 属性  Animal.call(this, age);  &#x2F;&#x2F; 初始化子类的 this 的 furColor 属性  this.furColor &#x3D; furColor;&#125;;&#x2F;&#x2F; 将子类的 prototype 修改为父类的 prototypeMammal.prototype &#x3D; Object.create(Animal.prototype);&#x2F;&#x2F; 修改子类的 prototype.constructor 的指向Mammal.prototype.constructor &#x3D; Mammal;&#x2F;&#x2F; 给子类的 prototype 添加额外的函数Mammal.prototype.liveBirth &#x3D; function liveBirth() &#123;&#125;;const Human &#x3D; function(age, furColor, languageSpoken) &#123;  if (!(this instanceof Human)) &#123;    throw new Error(&quot;Instantiate Human with &#96;new&#96;&quot;);  &#125;  Mammal.call(this, age, furColor);  this.languageSpoken &#x3D; languageSpoken;&#125;;Human.prototype &#x3D; Object.create(Mammal.prototype);Human.prototype.constructor &#x3D; Human;Human.prototype.speak &#x3D; function speak() &#123;&#125;;</code></pre><p>上述的继承实际上就是最常见的组合寄生式继承：</p><ol><li>在子类中调用父类的构造函数用于继承属性</li><li>设置子类自己的属性</li><li>将子类的 prototype 修改为父类的 prototype 用于继承父类的方法</li><li>修改 子类的 prototype.constructor 的指向为子类</li><li>添加子类自己的方法 </li></ol><p>可以看到这个过程极为繁琐。</p><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Animal &#123;  constructor(age) &#123;    this.age &#x3D; age;  &#125;  move() &#123;    &#x2F;* ... *&#x2F;  &#125;&#125;class Mammal extends Animal &#123;  constructor(age, furColor) &#123;    &#x2F;&#x2F; 执行父类的构造函数，继承父类属性值以及方法    super(age);    this.furColor &#x3D; furColor;  &#125;  liveBirth() &#123;    &#x2F;* ... *&#x2F;  &#125;&#125;class Human extends Mammal &#123;  constructor(age, furColor, languageSpoken) &#123;    super(age, furColor);    this.languageSpoken &#x3D; languageSpoken;  &#125;  speak() &#123;    &#x2F;* ... *&#x2F;  &#125;&#125;</code></pre><p>可以看到使用 class 则简单的多，只需要 extends 关键字，并且在子类中的 constructor 的 super 来实现继承。</p><p>这里有个注意点是：子类如果写了 constructor， 而不写 super 或是在调用 this 后再调用 super，则会报错，这是因为 constructor 不写则默认为父类的 constructor，如果写了 constructor，但是没有调用 super，则无法生成 this，这点与 ES5 也是有区别的。即 ES5 子类继承前就有 this 了，而 ES6 的 class 子类则是 super 之后才有的 this。</p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>这种模式在 JavaScript 中非常有用，在诸如 JQuery, Lodash 之类的仓库中，非常常见。这种模式可以让你的代码看起来简洁明了。基于上述原因，我可以直言，使用链式调用然后看看你的代码将是如此优雅。在方法中，返回 this，就可以实现。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Car &#123;  constructor(make, model, color) &#123;    this.make &#x3D; make;    this.model &#x3D; model;    this.color &#x3D; color;  &#125;  setMake(make) &#123;    this.make &#x3D; make;  &#125;  setModel(model) &#123;    this.model &#x3D; model;  &#125;  setColor(color) &#123;    this.color &#x3D; color;  &#125;  save() &#123;    console.log(this.make, this.model, this.color);  &#125;&#125;const car &#x3D; new Car(&quot;Ford&quot;, &quot;F-150&quot;, &quot;red&quot;);car.setColor(&quot;pink&quot;);car.save();</code></pre><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Car &#123;  constructor(make, model, color) &#123;    this.make &#x3D; make;    this.model &#x3D; model;    this.color &#x3D; color;  &#125;  setMake(make) &#123;    this.make &#x3D; make;    &#x2F;&#x2F; NOTE: 返回 this    return this;  &#125;  setModel(model) &#123;    this.model &#x3D; model;    &#x2F;&#x2F; NOTE: 返回 this    return this;  &#125;  setColor(color) &#123;    this.color &#x3D; color;     &#x2F;&#x2F; NOTE: 返回 this    return this;  &#125;  save() &#123;    console.log(this.make, this.model, this.color);     &#x2F;&#x2F; NOTE: 返回 this    return this;  &#125;&#125;const car &#x3D; new Car(&quot;Ford&quot;, &quot;F-150&quot;, &quot;red&quot;).setColor(&quot;pink&quot;).save();</code></pre><h3 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h3><p>据在四人帮的设计模式，我们应该尽可能使用组合而非继承。有很多理由使用继承，同时也有很多理由使用组合。这里最重要的一点是，如果直觉告诉你要使用继承，那么可以试试看使用组合是否能更好地解决问题？</p><p>那你可能会想，什么时候用继承会比较好？这需要视情况而定，但下面罗列了一些继承优于组合的场景：</p><ol><li>你的继承代表 “is-a” 而非 “has-a”（人 是一种 动物 vs 用户 有 用户详情）</li><li>你需要重用基类的代码（人可以像所有动物一样移动）</li><li>你希望修改基类的代码以全局变更所有子类的行为（所有动物移动时都需要消耗热量）</li></ol><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Employee &#123;  constructor(name, email) &#123;    this.name &#x3D; name;    this.email &#x3D; email;  &#125;  &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; 反例：因为员工 有 税收，而不是说 税收是一种 员工class EmployeeTaxData extends Employee &#123;  constructor(ssn, salary) &#123;    super();    this.ssn &#x3D; ssn;    this.salary &#x3D; salary;  &#125;  &#x2F;&#x2F; ...&#125;</code></pre><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class EmployeeTaxData &#123;  constructor(ssn, salary) &#123;    this.ssn &#x3D; ssn;    this.salary &#x3D; salary;  &#125;  &#x2F;&#x2F; ...&#125;class Employee &#123;  constructor(name, email) &#123;    this.name &#x3D; name;    this.email &#x3D; email;  &#125;  setTaxData(ssn, salary) &#123;    this.taxData &#x3D; new EmployeeTaxData(ssn, salary);  &#125;  &#x2F;&#x2F; ...&#125;</code></pre><p>实际上 React 的设计哲学也是提倡组合优于继承,详情可以参考 <a href="https://reactjs.org/docs/composition-vs-inheritance.html#gatsby-focus-wrapper">Composition vs Inheritance</a></p><h2 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h2><p>SOLID 是设计模式需要遵循的几个原则简称：</p><ol><li>单一职责（Single Responsibility Principle, SRP）</li><li>开闭原则（Open/Closed Principle, OCP）</li><li>里氏替换（Liskov Substitution Principle，LSP）</li><li>接口隔离（Interface Segregation Principle，ISP）</li><li>依赖倒置（Dependency Inversion Principle，DIP）</li></ol><p>###单一职责</p><p>如代码整洁之道所说，修改一个类的理由不应该超过一个 。如同一个航班只能带一个行李箱，因此我们将所有行李都塞入这个箱子，我们总是倾向于在一个类里实现许多功能。然而这么做的问题在于你的类无法做到概念上的内聚，并且经常不得不进行修改。最小化一个类的修改次数是非常重要的，这是因为如果一个类充斥过多的功能，当我们对其中一部分修改时，无法预测到这个修改会对依赖这个类的其他模块带来什么影响。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class UserSettings &#123;  constructor(user) &#123;    this.user &#x3D; user;  &#125;  changeSettings(settings) &#123;    if (this.verifyCredentials()) &#123;      &#x2F;&#x2F; ...    &#125;  &#125;  verifyCredentials() &#123;    &#x2F;&#x2F; ...  &#125;&#125;</code></pre><p>UserSettings 类负责修改设置，同时还负责了鉴权，而鉴权应该要从 UserSettings 分离出来。</p><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class UserAuth &#123;  constructor(user) &#123;    this.user &#x3D; user;  &#125;  verifyCredentials() &#123;    &#x2F;&#x2F; ...  &#125;&#125;class UserSettings &#123;  constructor(user) &#123;    this.user &#x3D; user;    this.auth &#x3D; new UserAuth(user);  &#125;  changeSettings(settings) &#123;    if (this.auth.verifyCredentials()) &#123;      &#x2F;&#x2F; ...    &#125;  &#125;&#125;</code></pre><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>“代码实体（类，模块，方法等）应该对拓展开放，对修改闭合”。</p><p>简单来说就是：以增代改。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class AjaxAdapter extends Adapter &#123;  constructor() &#123;    super();    this.name &#x3D; &quot;ajaxAdapter&quot;;  &#125;&#125;class NodeAdapter extends Adapter &#123;  constructor() &#123;    super();    this.name &#x3D; &quot;nodeAdapter&quot;;  &#125;&#125;class HttpRequester &#123;  constructor(adapter) &#123;    this.adapter &#x3D; adapter;  &#125;  fetch(url) &#123;    if (this.adapter.name &#x3D;&#x3D;&#x3D; &quot;ajaxAdapter&quot;) &#123;      return makeAjaxCall(url).then(response &#x3D;&gt; &#123;        &#x2F;&#x2F; transform response and return      &#125;);    &#125; else if (this.adapter.name &#x3D;&#x3D;&#x3D; &quot;nodeAdapter&quot;) &#123;      return makeHttpCall(url).then(response &#x3D;&gt; &#123;        &#x2F;&#x2F; transform response and return      &#125;);    &#125;  &#125;&#125;function makeAjaxCall(url) &#123;  &#x2F;&#x2F; request and return promise&#125;function makeHttpCall(url) &#123;  &#x2F;&#x2F; request and return promise&#125;</code></pre><p>假设将来我们需要添加一个 customAdapter, 那么我们需要：</p><ol><li>添加一个 CustomAdapter 类</li><li>在 HttpRequester 中添加一个 makCustomCall 方法</li><li>修改 fetch 方法，判断 adpater.name</li></ol><p>但是实际上我们只不过是想添加一个自定义的请求方法，却要对 HttpRequester 进行修改。实际上 HttpRequester 应该不关心具体 request 过程。修改如下：</p><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class AjaxAdapter extends Adapter &#123;  constructor() &#123;    super();    this.name &#x3D; &quot;ajaxAdapter&quot;;  &#125;  request(url) &#123;    &#x2F;&#x2F; request and return promise  &#125;&#125;class NodeAdapter extends Adapter &#123;  constructor() &#123;    super();    this.name &#x3D; &quot;nodeAdapter&quot;;  &#125;  request(url) &#123;    &#x2F;&#x2F; request and return promise  &#125;&#125;class HttpRequester &#123;  constructor(adapter) &#123;    this.adapter &#x3D; adapter;  &#125;  fetch(url) &#123;    return this.adapter.request(url).then(response &#x3D;&gt; &#123;      &#x2F;&#x2F; transform response and return    &#125;);  &#125;&#125;</code></pre><p>经过这样调整，不管拓展多少个新 Adapter 都不需要对 HttpRequester 进行修改。</p><h3 id="里氏替换"><a href="#里氏替换" class="headerlink" title="里氏替换"></a>里氏替换</h3><p>“子类对象应该可以直接替换其超类对象被使用”</p><p>对于这个原则有一个比较好的解释是：如果你有一个父类和一个子类，那么用子类任意替换掉父类而不会出错。下面是一个经典的例子，数学上来说，正方形是一种长方形，但是如果你真的使用 “is-a” 来构造的话，很快你就会发现问题所在。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Rectangle &#123;  constructor() &#123;    this.width &#x3D; 0;    this.height &#x3D; 0;  &#125;  setColor(color) &#123;    &#x2F;&#x2F; ...  &#125;  render(area) &#123;    &#x2F;&#x2F; ...  &#125;  setWidth(width) &#123;    this.width &#x3D; width;  &#125;  setHeight(height) &#123;    this.height &#x3D; height;  &#125;  getArea() &#123;    return this.width * this.height;  &#125;&#125;class Square extends Rectangle &#123;  setWidth(width) &#123;    this.width &#x3D; width;    this.height &#x3D; width;  &#125;  setHeight(height) &#123;    this.width &#x3D; height;    this.height &#x3D; height;  &#125;&#125;function renderLargeRectangles(rectangles) &#123;  rectangles.forEach(rectangle &#x3D;&gt; &#123;    rectangle.setWidth(4);    rectangle.setHeight(5);    &#x2F;&#x2F; 这里，如果我们传入的是一个 square，那么计算结果将会是 25，与预期的 20 不符    const area &#x3D; rectangle.getArea();    rectangle.render(area);  &#125;);&#125;const rectangles &#x3D; [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles(rectangles);</code></pre><p>可以看到在设置宽高以及面积时，实际上正方形与长方形的行为时不一致的，那么这里 正方形不应该从 长方形继承。我们可以抽象出一个更高的层级 Shape，长方形与正方形相同的方法可以放在 Shape 基类中，而不同点则各自实现。</p><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Shape &#123;  setColor(color) &#123;    &#x2F;&#x2F; ...  &#125;  render(area) &#123;    &#x2F;&#x2F; ...  &#125;&#125;class Rectangle extends Shape &#123;  constructor(width, height) &#123;    super();    this.width &#x3D; width;    this.height &#x3D; height;  &#125;  getArea() &#123;    return this.width * this.height;  &#125;&#125;class Square extends Shape &#123;  constructor(length) &#123;    super();    this.length &#x3D; length;  &#125;  getArea() &#123;    return this.length * this.length;  &#125;&#125;function renderLargeShapes(shapes) &#123;  shapes.forEach(shape &#x3D;&gt; &#123;    const area &#x3D; shape.getArea();    shape.render(area);  &#125;);&#125;const shapes &#x3D; [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];renderLargeShapes(shapes);</code></pre><h3 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h3><p>JavaScript 没有接口这个概念，因此这一条不像其他语言一样会被严格执行（不过 TypeScript 可以参考一下）。但即便如此，即使是 JavaScript 这样缺少类型系统的语言中，这条原则也是极为重要的。</p><p>接口隔离指的是：客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。</p><p>一个比较好的例子是：一个包含很多设置项的 class。客户端无需设置大量的可选项，因为大部分情况是无需设置所有的选项，将这些选项设为可选就可以避免 “胖接口”。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class DOMTraverser &#123;  constructor(settings) &#123;    this.settings &#x3D; settings;    this.setup();  &#125;  setup() &#123;    this.rootNode &#x3D; this.settings.rootNode;    this.settings.animationModule.setup();  &#125;  traverse() &#123;    &#x2F;&#x2F; ...  &#125;&#125;const $ &#x3D; new DOMTraverser(&#123;  rootNode: document.getElementsByTagName(&quot;body&quot;),  animationModule() &#123;&#125; &#x2F;&#x2F; 多数时候我们并不需要 animationModule  &#x2F;&#x2F; ...&#125;);</code></pre><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class DOMTraverser &#123;  constructor(settings) &#123;    this.settings &#x3D; settings;    this.options &#x3D; settings.options;    this.setup();  &#125;  setup() &#123;    this.rootNode &#x3D; this.settings.rootNode;    this.setupOptions();  &#125;  setupOptions() &#123;    if (this.options.animationModule) &#123;      &#x2F;&#x2F; ...    &#125;  &#125;  traverse() &#123;    &#x2F;&#x2F; ...  &#125;&#125;const $ &#x3D; new DOMTraverser(&#123;  rootNode: document.getElementsByTagName(&quot;body&quot;),  options: &#123;    animationModule() &#123;&#125;  &#125;&#125;);</code></pre><h3 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h3><p>这个原则有两个核心点：</p><ol><li>高层模块不应该依赖低层模块的实现，他们都应该依赖于抽象接口。</li><li>抽象接口不应该依赖具体实现，具体实现应该依赖抽象接口。</li></ol><p>简单来说即高层模块负责定义接口，而低层模块负责实现接口。</p><p>依赖倒置经常会与控制反转（IoC）联系在一起，IoC 是实现 DIP 的一种方式，而要实现 IoC 一种常见的方法是  Dependency Injection (DI，依赖注入) 。</p><p>这两者实际上不是一个概念，DIP 指的是高层模块不应该知道低层模块的具体实现。而依赖注入则是将低层模块的实现提供给高层模块的具体方法。</p><p>这种做法最大的好处是可以减少模块之间的耦合度。</p><p>如刚刚说的，JavaScript 没有接口的概念，因此抽象接口的依赖是隐式的，即对象向外部暴露的方法和属性。下面例子中将 InventoryTracker  视为高层模块，InventoryRequester  为低层模块，接口指的是 InventoryTracker 模块依赖到 InventoryRequester 模块暴露的 requestItem，即隐式要求所有的 InventoryRequester 都应该有 requestItem 方法。那么具体实现其实就是说不应该在 InventoryTracker  去实例化一个 InventoryRequester，而应该通过构造函数注入进来。</p><p><strong>Bad</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class InventoryRequester &#123;  constructor() &#123;    this.REQ_METHODS &#x3D; [&quot;HTTP&quot;];  &#125;  requestItem(item) &#123;    &#x2F;&#x2F; ...  &#125;&#125;class InventoryTracker &#123;  constructor(items) &#123;    this.items &#x3D; items;   &#x2F;&#x2F; 这里我们不应该去实例化一个具体的 Requester，我们应该只使用 Requester 实例的 requestItem    this.requester &#x3D; new InventoryRequester();  &#125;  requestItems() &#123;    this.items.forEach(item &#x3D;&gt; &#123;      this.requester.requestItem(item);    &#125;);  &#125;&#125;const inventoryTracker &#x3D; new InventoryTracker([&quot;apples&quot;, &quot;bananas&quot;]);inventoryTracker.requestItems();</code></pre><p><strong>Good</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class InventoryTracker &#123;  constructor(items, requester) &#123;    this.items &#x3D; items;    this.requester &#x3D; requester;  &#125;  requestItems() &#123;    this.items.forEach(item &#x3D;&gt; &#123;      this.requester.requestItem(item);    &#125;);  &#125;&#125;class InventoryRequesterV1 &#123;  constructor() &#123;    this.REQ_METHODS &#x3D; [&quot;HTTP&quot;];  &#125;  requestItem(item) &#123;    &#x2F;&#x2F; ...  &#125;&#125;class InventoryRequesterV2 &#123;  constructor() &#123;    this.REQ_METHODS &#x3D; [&quot;WS&quot;];  &#125;  requestItem(item) &#123;    &#x2F;&#x2F; ...  &#125;&#125;&#x2F;&#x2F; 这里我们在外部实例化 InventoryRequester 并且注入，我们就可以简单就将 InventoryRequesterV1 替换 InventoryRequesterV2const inventoryTracker &#x3D; new InventoryTracker(  [&quot;apples&quot;, &quot;bananas&quot;],  new InventoryRequesterV2());inventoryTracker.requestItems();</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactNative 文字折叠</title>
      <link href="/2021/01/22/ReactNative-%E6%96%87%E5%AD%97%E6%8A%98%E5%8F%A0/"/>
      <url>/2021/01/22/ReactNative-%E6%96%87%E5%AD%97%E6%8A%98%E5%8F%A0/</url>
      
        <content type="html"><![CDATA[<p> h5 的单行/多行文字溢出截断实现如下</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;&#x2F; 单行div &#123;  white-space: nowrap;  overflow: hidden;  text-overflow: ellipsis;&#125;&#x2F;&#x2F; 多行div &#123;  display: -webkit-box;  overflow: hidden;  -webkit-line-clamp: 2;  -webkit-box-orient: vertical;  text-overflow: ellipsis;&#125;</code></pre><p>在 h5 中，多行文字截断的兼容性并不好，而在 RN 中，实现文字截断则简单的多，只需要给 Text 组件添加 <code>numberOfLines</code> 属性即可。</p><p>但是通常我们还会遇到如下需求：</p><p>文字在不超出 N 行时，全部展示，超出 N 行时截断，并显示 阅读更多 按钮，用于点击展开，展开后 阅读更多 按钮显示为 收起，点击后折叠文字。</p><a id="more"></a><p>如果我们能得知文字初始时是否处于折叠状态，那么就很好办了，通过修改 <code>numberOfLines</code>  的值 0 / N，来变更 展开与折叠 状态。</p><p>但是很可惜，RN 并没有提供 api 来告知文字是否处于折叠状态，因此只能另寻他法。</p><h5 id="尝试一"><a href="#尝试一" class="headerlink" title="尝试一"></a>尝试一</h5><p>参考 github 上的 <a href="https://github.com/facebook/react-native/issues/2496">issue</a> 可以看到这个问题由来已久，有个解法是在 onLayout 时获取 Text 的高度, 对比理论折叠值( N * lineHeight)，如果比理论折叠值大，则说明文字处于折叠状态。</p><p>上面这个方案我尝试了下，在 ios 上表现良好，但是在 安卓 机器上，onLayout 时获取到的 Text 高度却是折叠后的高度，这意味着上述方法将失效。</p><h5 id="尝试二"><a href="#尝试二" class="headerlink" title="尝试二"></a>尝试二</h5><p>接着我又注意到一个 api <code>onTextLayout</code>。<code>onTextLayout</code> 在 Text layout 的时候会被调用，可以获取到 lines，这是个对象数组，包含了每行文字的宽高等信息。我打算尝试一下这个 api 具体的表现如何。奇怪的是<code>onTextLayout</code> 虽然可以使用，但是 TS 的申明文件中 Text 组件却没有这个属性。再则在安卓机上 <code>onTextLayout</code>  返回的 lines 为未折叠时的行数，而在 ios 上则为折叠后的行数（最后一行将包括折叠后未能放下的文字）。看来仅通过 <code>onTextLayout</code>  也是无法判断到是否文字处于折叠状态。</p><h5 id="尝试三"><a href="#尝试三" class="headerlink" title="尝试三"></a>尝试三</h5><p>不过上述的尝试启发了我，如果我们可以得知文字在全部展开时的行数，如果超过 N ，则将 <code>numberOfLines</code>  设置为 N，否则为 0，此时的初始化状态必定是折叠的。那么问题是如何得知文字在全部展开时的行数？如果将文字 <code>numberOfLines</code>  初始值设置为 0，表现将会是一开始全部展开，之后再收起，显然不符合需求。那么我们需要在一个不会被看到的地方暗戳戳地渲染 <code>numberOfLines</code>  为 0 的 Text。这里我是构建了一个 height 为 0 的 ScrollView，在这个 ScrollView 中渲染 <code>numberOfLines</code>  为 0 的 Text，并且通过该 Text 的 onTextLayout 可以获取到文字的行数，并且与 N 进行对比，就可以知道文字是否可折叠。</p><p>最终代码实现如下：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&#x2F;* 该组件的主要用途是测量具有 numberOfLines 属性的 Text 是否会被裁剪，以用于自定义展开更多按钮 原理是在一个高度为 0 的 ScrollView 中进行渲染，获取到渲染后的行数*&#x2F;import React, &#123; Children, isValidElement, cloneElement &#125; from &#39;react&#39;;import &#123; View, ViewStyle, ScrollView &#125; from &#39;react-native&#39;;interface IProps &#123;&#x2F;&#x2F; 最多行数，超出折叠  limitLineNumber: number;  children: React.ReactElement;  onReady: (truncated: boolean) &#x3D;&gt; void;  style: ViewStyle;&#125;const ReadMore &#x3D; (&#123; children, limitLineNumber, onReady, style &#125;: IProps) &#x3D;&gt; &#123;  &#x2F;* 复制出一个不带有 numberOfLines 的 children *&#x2F;  const childrenTemp &#x3D; Children.map(children, (child) &#x3D;&gt; &#123;    if (isValidElement(child)) &#123;      return cloneElement(child as React.ReactElement&lt;any&gt;, &#123;        numberOfLines: 0,        onTextLayout: (e: any) &#x3D;&gt; &#123;          &#x2F;&#x2F; onTextLayout事件：ios 与 安卓 在文字折叠情况时会略微不同，体现在 lines 属性上          &#x2F;&#x2F; ios 是返回折叠后的，而安卓则返回的是折叠之前的          &#x2F;&#x2F; onTextLayout 在 0.59 的文档上并未体现，且 ts 类型也没有，但实际上是可以使用的          onReady(e.nativeEvent.lines?.length &gt; limitLineNumber);        &#125;,      &#125;);    &#125;    return child;  &#125;);  return (    &lt;View style&#x3D;&#123;style&#125;&gt;      &lt;ScrollView style&#x3D;&#123;&#123; height: 0 &#125;&#125;&gt;&#123;childrenTemp&#125;&lt;&#x2F;ScrollView&gt;      &#123;children&#125;    &lt;&#x2F;View&gt;  );&#125;;export default ReadMore;</code></pre><p>使用时:</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const Demo &#x3D; () &#x3D;&gt; &#123;  const onReadMoreReady &#x3D; (truncated: boolean) &#x3D;&gt; &#123;      &#x2F;&#x2F; 根据是否可折叠，判断展示按钮的文字等状态  &#125;;    return &lt;ReadMore onReady&#x3D;&#123;onReadMoreReady&#125; limitLineNumber&#x3D;&#123;2&#125; &gt;    &lt;Text&gt;      any content you need...    &lt;&#x2F;Text&gt;  &lt;&#x2F;ReadMore&gt;&#125;</code></pre><p>⚠️ 以上全部基于 RN 0.59 版本</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次踩坑：webp与ios</title>
      <link href="/2020/12/31/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91%EF%BC%9Awebp%E4%B8%8Eios/"/>
      <url>/2020/12/31/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91%EF%BC%9Awebp%E4%B8%8Eios/</url>
      
        <content type="html"><![CDATA[<p>最近有同事遇到一个问题，有个页面的图片（<a href="http://www.xxx.jpg）在安卓和">www.xxx.jpg）在安卓和</a> pc 都能正常显示，但是用 ios 就展示不了。通常出现在这种情况是因为 WKWebview 不支持 webp 的图片导致的。通过 <a href="https://caniuse.com/?search=webp，可以看到">https://caniuse.com/?search=webp，可以看到</a> safari 在 14.0 之后才支持 webp。</p><a id="more"></a><p>虽然这个场景里的图片后缀名是 jpg，但文件的后缀名并不能准确反映文件的实际格式。因此在 pc 端打开链接后，查看 <code>Content-Type</code> 看到属性为 <code>image/webp</code>, 因此可以确定这个图片文件实际上是 webp。</p><p>这个图片是在后台系统上传的，那么有可能是操作人员从网络下载了一张 webp 的图片，之后修改后缀名并上传。</p><p>上传组件是通过 antdesign 提供的<code>Upload</code>（该组件本质上也是封装了 input 组件）。 在 <code>beforeUpload</code> 可以获取到上传的 file， 上传前通过 <code>file.type</code> 校验过文件的 MIME type 必须是 <code>image/jpeg</code>。</p><p>奇怪的这里 webp 文件，如果后缀名改成 jpg, 则 file.type 显示的是 <code>image/jpeg</code> 而非 <code>image/webp</code>, 即 file.type 获取到类型会收到后缀名的影响，并不是准确的文件类型。</p><p>根据 MDN 的描述</p><blockquote><p> Based on the current implementation, browsers won’t actually read the bytestream of a file to determine its media type. It is assumed based on the file extension; a PNG image file renamed to .txt would give “<em>text/plain</em>“ and not “<em>image/png</em>“. Moreover, <code>file.type</code> is generally reliable only for common file types like images, HTML documents, audio and video. Uncommon file extensions would return an empty string. Client configuration (for instance, the Windows Registry) may result in unexpected values even for common types. <strong>Developers are advised not to rely on this property as a sole validation scheme.</strong></p></blockquote><p>确实浏览器会依据后缀名来判断 File.type 而非真正去读取文件流内容。</p><p>那么如何判断文件的类型是否为我们需要的类型呢？有同事给了段代码:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var reader &#x3D; new FileReader();reader.onload &#x3D; function() &#123;  const isJPG &#x3D; z &#x3D;&gt; [255,216,255].every((v, k) &#x3D;&gt; z.charCodeAt(k)&#x3D;&#x3D;&#x3D;v);  const isWEBP &#x3D; z &#x3D;&gt; [87,69,66,80].every((v, k) &#x3D;&gt; z.charCodeAt(k+8)&#x3D;&#x3D;&#x3D;v);  const isPNG &#x3D; z &#x3D;&gt; [137,80,78,71,13,10,26,10].every((v, k) &#x3D;&gt; z.charCodeAt(k) &#x3D;&#x3D;&#x3D; v);  const isGIF &#x3D; z &#x3D;&gt; [71,73,70].every((v, k) &#x3D;&gt; z.charCodeAt(k) &#x3D;&#x3D;&#x3D; v);  var res &#x3D; reader.result;  console.log(isJPG(res));  console.log(isWEBP(res));  console.log(isPNG(res));  console.log(isGIF(res));&#125;;reader.readAsBinaryString($0.files[0]);</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给 RN 添加 mobx</title>
      <link href="/2020/12/14/%E7%BB%99-RN-%E6%B7%BB%E5%8A%A0-mobx/"/>
      <url>/2020/12/14/%E7%BB%99-RN-%E6%B7%BB%E5%8A%A0-mobx/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>项目组中 RN 之前使用的状态管理是小伙伴自行封装 redux， redux-saga 的一个组件库，然而由于文档不全，使用起来不方便等原因，经过讨论，决定替换成 mobx。主要参考官方文档： <a href="https://mobx.js.org/react-integration.html#react-integration。本文记录我将">https://mobx.js.org/react-integration.html#react-integration。本文记录我将</a> mobx 加入 RN 的过程以及使用 mobx 的一些注意事项（实际上与普通的 React 项目差不多）</p><a id="more"></a><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li><p>在 src 目录下新增一个 stores 文件夹用于存放 mobx 相关的代码</p></li><li><p>编写 observable state，这里我写了一个 Counter.ts 并且新建 stores.ts 管理所有的状态：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Counter.tsimport &#123; makeAutoObservable &#125; from &#39;mobx&#39;;class Counter &#123;  count &#x3D; 0;  constructor() &#123;    makeAutoObservable(this);  &#125;  &#x2F;&#x2F; 注意要使用箭头函数，否则需要用 action.bound 来绑定 this，否则指向 React 组件  increase &#x3D; () &#x3D;&gt; &#123;    this.count +&#x3D; 1;  &#125;;  decrease &#x3D; () &#x3D;&gt; &#123;    this.count -&#x3D; 1;  &#125;;&#125;export default Counter;&#x2F;&#x2F; stores.tsimport Counter from &#39;.&#x2F;Counter&#39;;export default &#123;  counter: new Counter(),&#125;;</code></pre></li><li><p>根据 mobx 文档，组件要使用外部状态有三种写法：</p><ol><li>通过 props 将 状态传递到组件</li><li>直接通过 import 进来</li><li>通过 React context 引入到组件</li></ol><p>为了方便使用，考虑 2，3 中写法，文档中推荐使用 context，那么就这里尝试使用 context。</p></li><li><p>编写 withStores.ts 函数，这是一个高阶组件，主要的作用是给根元素用 Provider 包裹起来，并且根元素通常也是需要 observe 的，因此这里也顺便将其转成可观测的组件：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; withStores.tsimport React, &#123; createContext &#125; from &#39;react&#39;;import &#123; observer &#125; from &#39;mobx-react-lite&#39;;import stores from &#39;.&#x2F;stores&#39;;&#x2F;&#x2F; 初始化 Contextexport const StoresContext &#x3D; createContext&lt;typeof stores&gt;(stores);const withStores &#x3D; &lt;P extends object&gt;(  WrappedComponent: React.FunctionComponent&lt;P&gt;,) &#x3D;&gt; (props: P) &#x3D;&gt; &#123;  &#x2F;&#x2F; 转成可观测的组件  const ObserverWrappedComponent &#x3D; observer(WrappedComponent);  return (    &lt;StoresContext.Provider value&#x3D;&#123;stores&#125;&gt;      &lt;ObserverWrappedComponent &#123;...props&#125; &#x2F;&gt;    &lt;&#x2F;StoresContext.Provider&gt;  );&#125;;export default withStores;</code></pre></li><li><p>接下来的使用就简单了：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect, useContext &#125; from &#39;react&#39;;import &#123; TouchableOpacity, View, Text &#125; from &#39;react-native&#39;;import &#123; withStores, StoresContext &#125; from &#39;@&#x2F;stores&#39;;import Child from &#39;.&#x2F;Child&#39;;const MobxDemo &#x3D; () &#x3D;&gt; &#123;  const &#123; counter &#125; &#x3D; useContext(StoresContext);  return (    &lt;View&gt;      &lt;Text&gt;count: &#123;counter.count&#125;&lt;&#x2F;Text&gt;      &lt;TouchableOpacity onPress&#x3D;&#123;counter.increase&#125;&gt;        &lt;Text&gt;increase: +&lt;&#x2F;Text&gt;      &lt;&#x2F;TouchableOpacity&gt;      &lt;TouchableOpacity onPress&#x3D;&#123;counter.decrease&#125;&gt;        &lt;Text&gt;decrease: -&lt;&#x2F;Text&gt;      &lt;&#x2F;TouchableOpacity&gt;      &lt;Child &#x2F;&gt;    &lt;&#x2F;View&gt;  );&#125;;export default withStores(MobxDemo);&#x2F;&#x2F; Child.tsximport React, &#123; useContext &#125; from &#39;react&#39;;import &#123; observer &#125; from &#39;mobx-react-lite&#39;;import &#123; Text &#125; from &#39;react-native&#39;;import &#123; StoresContext &#125; from &#39;@&#x2F;stores&#39;;export const Child &#x3D; () &#x3D;&gt; &#123;  const &#123; counter &#125; &#x3D; useContext(StoresContext);  return &lt;Text&gt;child: &#123;counter.count&#125;&lt;&#x2F;Text&gt;;&#125;;export default observer(Child);</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svg 与字体</title>
      <link href="/2020/12/10/svg-%E4%B8%8E%E5%AD%97%E4%BD%93/"/>
      <url>/2020/12/10/svg-%E4%B8%8E%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>继上一篇 《svg 图片的上传与下载》后，产品要求下载的 svg 需要使用 “OCR-B 10 BT” 这个字体。下面记录下遇到的坑。</p><a id="more"></a><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><code>jsbarcode</code> 这个库提供了一个 <code>font</code> 配置项。例如这里配置 </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">JsBarcode(svg, barcode, &#123;  font: &#39;Arial&#39;&#125;);</code></pre><p>这个配置的作用是在 svg 的 text 节点的 style 属性上添加<code>font:Arial</code></p><p>那么问题如果是 OCR-B 10 BT，我们直接配置成</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">JsBarcode(svg, barcode, &#123;  font: &#39;OCR-B 10 BT&#39;&#125;);</code></pre><p>那么结果会变成:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;text style&#x3D;&quot;font: OCR-B 10 BT&quot;&gt;xxx&lt;&#x2F;text&gt;</code></pre><p>这将会导致无法识别出 font 的属性，而 jsbarcode 并没有单独提供 font-family 配置。正确的写法可以如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">JsBarcode(svg, barcode, &#123;  font: &#96;&quot;OCR-B 10 BT&quot;&#96;&#125;);</code></pre><p>到了这一步并没有完全解决问题，对于系统有安装过 OCR-B 10 BT 字体的用户是可以正常展示下载的 svg，然而对于没有安装过这个字体的则会展示默认字体。这里分成两种场景：1. 在我们的网站上展示 2. 下载后的 svg 展示</p><p>对于第一个场景，在 web 通过 font-face 引入字体文件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">@font-face &#123;    font-family: &#39;OCR-B 10 BT&#39;;    src: url(&#39;fonts&#x2F;webfont.eot&#39;);    src:url(&#39;fonts&#x2F;webfont.woff&#39;) format(&#39;woff&#39;),       url(&#39;fonts&#x2F;webfont.woff2&#39;) format(&#39;woff2&#39;),        url(&#39;fonts&#x2F;webfont.ttf&#39;) format(&#39;truetype&#39;);    font-weight: normal;    font-style: normal;&#125;</code></pre><p>然而在第二个场景则需要将字体文件放到 svg 里面，注意这个会导致 svg 体积增大。</p><p>首先我们需要在 svg 中定义 style：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const defs &#x3D; document.createElementNS(&#39;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&#39;, &#39;defs&#39;);const style &#x3D; document.createElementNS(&#39;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&#39;, &#39;style&#39;);style.type &#x3D; &#39;text&#x2F;css&#39;;&#x2F;&#x2F; myFontStyle 是我们定义的样式，实际上就是一段定义 font-face 的字符串style.innerHTML &#x3D; myFontStyle;defs.appendChild(style);svgElement.appendChild(defs);</code></pre><p>可以通过 <a href="https://www.fontsquirrel.com/tools/webfont-generator">https://www.fontsquirrel.com/tools/webfont-generator</a> 这里选择 EXPERT 模式，在 css 的勾选栏选中 Base64 编码，生成的 zip 包中的 css 文件内容就包含我们编码成 base64 后的样式。将 myFontStyle 替换成 文件内容即可。</p><p>至此给 svg 定义字体的需求就算是完成了，不过真的不推荐将字体塞进 svg 中，否则文件体积将会飙升 ☠️</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾项目中实践的 graphql</title>
      <link href="/2020/11/16/%E5%9B%9E%E9%A1%BE%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E8%B7%B5%E7%9A%84-graphql/"/>
      <url>/2020/11/16/%E5%9B%9E%E9%A1%BE%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E8%B7%B5%E7%9A%84-graphql/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>早些时候在公司内部的做过一个内部项目 <code>api-docs</code>，该项目是提供一个 Api 管理文档平台，类似于 YApi 。项目是半路接过来的，前端使用 <code>vue</code>，服务端使用 <code>eggjs</code> 提供符合 restful 规范的接口，数据库则选择的是 <code>mongodb</code>。</p><p>在不断的迭代中，遇到以下一些问题</p><ol><li>首页和测试模块都展示了 api 列表，但是首页与测试模块所展示的字段存在一些异同点，基于此，有两种做法：<ol><li>提供两个不同的接口</li><li>提供同一个接口，根据请求参数判断需要下发的字段</li></ol></li><li>需要对外开放查询接口，不同部门需求的字段信息不同</li><li>由于是内部使用，接口 ( 需求 ) 改动比较频繁，仅仅是修改前端展示的数据却需要频繁修改服务端接口，当然可以将页面需要的字段全部下发，不过这么做有点浪费带宽。</li></ol><p>因此我引入了 <code>graphql</code> 来解决上述的问题。基本想法是前端自行构建需要的字段，服务端无需变更。</p><p>本文尝试去还原引入的过程是防止遗忘( 实际上时间隔得比较久了，一些细节确实已经模糊了 )。由于当时也是摸石头过河，可能会有一些不是最佳实践的地方，还望指教。</p><a id="more"></a><p>文中涉及到的库版本：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 服务端dataloader: 1.4.0egg: 2.0.0egg-graphql: 2.3.0graphql-type-json: 0.2.1&#x2F;&#x2F; 前端graphql：14.5.8apollo-boost：0.1.23</code></pre><h4 id="前端处理"><a href="#前端处理" class="headerlink" title="前端处理"></a>前端处理</h4><p>前端我是使用了 apollo 来发送请求的，引入 apollo</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import Vue from &quot;vue&quot;;import VueApollo from &quot;vue-apollo&quot;;import ApolloClient from &quot;apollo-boost&quot;;import API from &quot;@&#x2F;config&#x2F;api&quot;;const apolloClient &#x3D; new ApolloClient(&#123;  uri: &#39;&#x2F;graphql&#39;&#125;);const apolloProvider &#x3D; new VueApollo(&#123;  defaultClient: apolloClient&#125;);Vue.use(VueApollo);export default apolloProvider;</code></pre><p>构造一个查询 api 列表的语句</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import gql from &quot;graphql-tag&quot;;const apiListQuery &#x3D; gql&#96;    query($pageInfo: PageInfo)&#123;      apis(pageInfo: $pageInfo)&#123;        nodes&#123;          _id          name        &#125;        total      &#125;    &#125;  &#96;</code></pre><p>还可以通过开发者工具 graphiql 快速构造正确的查询语句，这个后面会结合 eggjs 介绍。</p><p>发送请求</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">function getList &#x3D; async () &#x3D;&gt; &#123;  const pageInfo &#x3D; &#123;    pageSize: 20,    currentPage: 1&#125;;  await apolloProvider.defaultClient.query(&#123;    query: apiListQuery,    variables: &#123;      pageInfo    &#125;  &#125;);&#125;</code></pre><p>或者简单通过 axios 发送</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">axios(&#123;  url: &#39;http:&#x2F;&#x2F;xxxxx&#x2F;graphql&#39;,  method: &#39;POST&#39;,  data: &#123;    query: &#96;            query ($filter: Api_Filter, $pageInfo: PageInfo) &#123;              apis(filter: $filter, pageInfo: $pageInfo) &#123;                  nodes &#123;                      _id                      name                  &#125;                  total              &#125;          &#125;&#96;,    variables: &#123;      pageInfo: &#123;        pageSize: 20,        currentPage: 1,      &#125;    &#125;,  &#125;,&#125;);</code></pre><h4 id="服务端处理"><a href="#服务端处理" class="headerlink" title="服务端处理"></a>服务端处理</h4><p>仅改造旧接口中有上述需求的 get 请求，对于其他没有必要全部转为 graphql 的接口不做变更。</p><p>egg 对 graphql 做了一定的支持: <a href="https://github.com/eggjs/egg-graphql，其中的配置可以参考文档。">https://github.com/eggjs/egg-graphql，其中的配置可以参考文档。</a></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; congfig.jsgraphql: &#123;  router: &#39;&#x2F;graphql&#39;,  &#x2F;&#x2F; 是否加载到 app 上，默认开启  app: true,  &#x2F;&#x2F; 是否加载到 agent 上，默认关闭  agent: false,  &#x2F;&#x2F; 是否加载开发者工具 graphiql, 默认开启。路由同 router 字段。使用浏览器打开该可见。  graphiql: true&#125;&#x2F;&#x2F; pluginexports.graphql &#x3D; &#123;  enable: true,  package: &#39;egg-graphql&#39;&#125;</code></pre><p>目录结构：</p><pre class="line-numbers language-none"><code class="language-none">.├── app│   ├── graphql│   │   ├── project│   │   │   └── schema.graphql│   │   ├── api  &#x2F;&#x2F; api 模型│   │   │   ├── connector.js  │   │   │   ├── resolver.js│   │   │   └── schema.graphql│   ├── model│   │   └── api.js│   ├── public│   └── router.js</code></pre><p>在 app 下新增一个 graphql 文件夹。</p><p>下面再新建一个 api 文件夹，根据 GraphQL 的规范，将 GraphQL 相关逻辑分成 Schema, Resolvers, Models, 和 Connectors。</p><p> schema.graphql 中描述数据模型，有点像 typescript 中的 interface。</p><p>graphql 的数据模型入口在 project/schema.graphql</p><pre class="line-numbers language-none"><code class="language-none">type Apis &#123;  nodes: [Api],  total: Int&#125;type Query &#123;  apis(filter: Api_Filter, pageInfo: PageInfo): Apis&#125;</code></pre><p>api / schema.graphql 的内容如下</p><pre class="line-numbers language-none"><code class="language-none">type Api_Options &#123;&#x2F;&#x2F; 。。。&#125;type Api &#123;  _id: String  name: String  options: Api_Options&#125;</code></pre><p>声明的 type 可以被别的 type 引用。</p><p>resolver 是对接到用户查询</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module.exports &#x3D; &#123;  Query: &#123;    apis (root, params, ctx) &#123;      return ctx.connector.api.find(params)    &#125;,  &#125;,&#125;</code></pre><p>上面我们看到 ctx 有个 connector 属性，实际上对应的就是我们的 connector 文件，connector 主要负责取数逻辑，类似于 controller 的职能。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">class ApiConnector &#123;  constructor (ctx) &#123;    this.ctx &#x3D; ctx  &#125;  async find (params) &#123;    &#x2F;&#x2F; 获取到参数    const &#123; pageInfo &#125; &#x3D; params    const &#123; currentPage, pageSize &#125; &#x3D; pageInfo    const apis &#x3D; await this.ctx.model.Api.find()      .sort(&#123;        createTime: -1      &#125;)      .skip((Number(currentPage) - 1) * Number(pageSize))      .limit(Number(pageSize))      .exec()    const total &#x3D; await this.ctx.model.Api.find()      .count()      .exec()    return &#123;      nodes: apis,      total    &#125;  &#125;&#125;module.exports &#x3D; ApiConnector</code></pre><p>至此完成了一个简单的发 graphql 请求，到服务端处理的并返回的过程。</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>DataLoader：graphql 支持嵌套查询，有时候会出现严重的N+1查询性能问题。为了解决这个问题，facebook 提出 dataloader 这个方案。</p><ol><li>具体可以看 <a href="https://zhuanlan.zhihu.com/p/30604868">https://zhuanlan.zhihu.com/p/30604868</a> 的说明。</li><li>dataloader 要求返回的结果和传入的 key 一致，而 mongo find 与 $in 是不保证顺序的，请注意要转成正确的顺序。</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GraphQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode merge-diffs 插件开发</title>
      <link href="/2020/10/30/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2020/10/30/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>当前的项目由于不是严格按照敏捷开发进行的，经常有功能分支需要分别上到 测试，预发以及开发环境。这个就导致了功能分支比较多，且开发要在临上线前整理需上线的分支，在上到正式环境之前需要合并到一个临时分支，之后再统一上到 master 分支。因此经常会遗漏掉一些分支。用 git log 可以对比出两个分支合并分支的区别，从而知道有哪些分支合并到测试分支，但是并没合并到 master。 那么这些分支就有可能是需要上线到 master 的。我个人比较习惯使用命令行 + vscode 来使用 git，但是命令行不太直观，且交互比较麻烦，因此打算写个 VSCode 插件。</p><a id="more"></a><p>关于个人项目（排除单纯为了折腾技术的目的）我有一个经验是追求的不应该是技术方案完美，而是能尽快作出需要的功能（否则极可能中途放弃），之后再不断迭代直至自己满意，因此这个过程中可能会有一些不够十全十美的地方，还望见谅。</p><p>代码地址：<a href="https://github.com/KNighD/merge-diffs">https://github.com/KNighD/merge-diffs</a></p><h4 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h4><p>这里我选择使用 Typescript 来实现插件，要说原因，主要是可以提示参数类型吧，毕竟不太熟悉文档。</p><p>由于存在输入时间之类的交互，因此还是需要使用到 webview 的，html 部分考虑使用 vue3 来实现（虽然react 写起来更熟悉，但是想折腾一下）</p><p>总体的想法是在页面输入查询条件，然后在与 node 端进行通信，执行命令查询出结果处理完成后回传给页面并做展示。界面 UI 的话就参考 Git History。</p><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;&#x2F; 安装脚手架npm install -g yo generator-code&#x2F;&#x2F; 生成模板代码yo code</code></pre><p>题外话：github 上的主分支已经改叫 main 了。。</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>初始代码模板入口是 <code>src/extension.ts</code>，功能就是在命令面板输入 <code>Hello World</code>，将会弹出一句提示。</p><p>用 vscode 打开生成的项目，按 F5 将会弹出一个新窗口，在新窗口的命令面板输入 <code>Hello World</code>，如果弹出一句提示，就表明项目初始化成功了。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; package.json&#123;  &quot;activationEvents&quot;: [  &#x2F;&#x2F; 当命令运行时启动      &quot;onCommand:merge-logs.showMergeLogs&quot;    ],    &quot;contributes&quot;: &#123;      &quot;commands&quot;: [      &#x2F;&#x2F; 定义命令        &#123;          &quot;command&quot;: &quot;merge-logs.showMergeLogs&quot;,          &#x2F;&#x2F; 命令面板上展示的          &quot;title&quot;: &quot;MergeLogs: show&quot;        &#125;      ]    &#125;&#125;</code></pre><h4 id="打开一个-webview"><a href="#打开一个-webview" class="headerlink" title="打开一个 webview"></a>打开一个 webview</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let show &#x3D; vscode.commands.registerCommand(&#39;merge-logs.showMergeLogs&#39;, () &#x3D;&gt; &#123;    const panel &#x3D; vscode.window.createWebviewPanel(      &#39;testWebview&#39;,      &#x2F;&#x2F; title      &#39;MergeLogs&#39;,      &#x2F;&#x2F; 显示在编辑器的哪个部位      vscode.ViewColumn.One,      &#123;        &#x2F;&#x2F; 启用JS，默认禁用        enableScripts: true,        &#x2F;&#x2F; webview被隐藏时保持状态，避免被重置        retainContextWhenHidden: true,      &#125;    )    panel.webview.html &#x3D; &#96;&lt;html&gt;&lt;body&gt;test merge logs&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#96;  &#125;)  context.subscriptions.push(show)</code></pre><p>WebView 加载的资源路径可以通过以下方法获取</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const getRelativeResource &#x3D; (webview: Webview, relativePath: string) &#x3D;&gt; &#123;  return webview.asWebviewUri(Uri.file(path.join(context.extensionPath, relativePath)));&#125;;panel.webview.html &#x3D; &#96;&lt;html&gt;&lt;head&gt;&lt;script src&#x3D;&#39;$&#123;getRelativeResource(panel.webview, &#39;.&#x2F;test.js&#39;)&#125;&#39;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;test merge logs&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#96;;&#125;);</code></pre><p>调试的时候需要在开发窗口打开命令面板，输入 <code>Open Webview Developer Tools</code> </p><h4 id="开发-web-页面"><a href="#开发-web-页面" class="headerlink" title="开发 web 页面"></a>开发 web 页面</h4><p>我将 web 页面放在 /client 目录下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm init vite-app client cd clientnpm i</code></pre><p>项目是基于 Typescript 的，而 client 是 vue，此时根目录的 eslint 会报错，我们先将 client 目录下的文件忽略掉,将来在 client 中单独添加 eslint。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; .eslint.json&quot;ignorePatterns&quot;: [&quot;&#x2F;client&quot;]</code></pre><p>项目打包后资源文件会带上 hash 值，按照 webpack 的经验，应该可以采取两种处理方式：</p><ol><li>修改打包配置将 public path 替换成 getRelativeResource 后获取到的地址, 动态读取打包后的 html</li><li>webview 写死 html 模板，修改打包配置，让打包后的资源不带 hash,见 <a href="https://github.com/vitejs/vite/issues/378">https://github.com/vitejs/vite/issues/378</a></li></ol><p>这里采用第二种方案，在 client 下添加 <code>vite.config.js</code> </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; vite.config.jsexport default &#123;  rollupOutputOptions: &#123;    entryFileNames: &#96;[name].js&#96;,    chunkFileNames: &#96;[name].js&#96;,    assetFileNames: &#96;[name].[ext]&#96;,  &#125;,&#125;</code></pre><p>🤔不过还有一个问题，调试起来非常麻烦，每次修改完都需要 build 一下</p><h4 id="实现简单通信"><a href="#实现简单通信" class="headerlink" title="实现简单通信"></a>实现简单通信</h4><p>在页面上添加一个简单的按钮，点击这个按钮后，将会发一个 getLogs 的命令给插件端，插件端接收之后，执行 <code>git log</code>,并返回结果。</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; App.vue&lt;template&gt;  &lt;button @click&#x3D;&quot;sendMessage&quot;&gt;sendMessage&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      vscode: null,    &#125;  &#125;,  mounted() &#123;    &#x2F;&#x2F; 初始化 vscode 对象    this.vscode &#x3D; acquireVsCodeApi()    &#x2F;&#x2F; 监听来自 vscode 插件的信息    window.addEventListener(&#39;message&#39;, (event) &#x3D;&gt; &#123;      const message &#x3D; event.data      console.log(message)    &#125;)  &#125;,  methods: &#123;    sendMessage() &#123;      &#x2F;&#x2F; 发送消息给插件      this.vscode.postMessage(&#39;getLogs&#39;)    &#125;,  &#125;,&#125;&lt;&#x2F;script&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 插件端接收到消息panel.webview.onDidReceiveMessage(  async (message) &#x3D;&gt; &#123;    if (message &#x3D;&#x3D;&#x3D; &#39;getLogs&#39;) &#123;      try &#123;        const logs &#x3D; await getLogs();        panel.webview.postMessage(logs);      &#125; catch (error) &#123;        panel.webview.postMessage(error);      &#125;    &#125;  &#125;,  undefined,  context.subscriptions);&#125;</code></pre><p>使用 <code>child_process</code> 并执行 node 命令，并封装成 Promise：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const getLogs &#x3D; () &#x3D;&gt; &#123;  return new Promise((resolve, reject) &#x3D;&gt; &#123;    cp.exec(      &#96;git log&#96;,      (err: Error, stdout: string, stderr: string) &#x3D;&gt; &#123;        if (stderr || err) &#123;          return reject(stderr || err);        &#125;        return resolve(stdout);      &#125;    );  &#125;);&#125;;</code></pre><p>⚠️ 由于 exec 会衍生子 shell，因此在每次执行 shell 命令时要确认当前的路径是否正确。</p><p>至此一个大体的框架就完成了。</p><p>后续的开发主要是用 <code>git branch --merged</code> 查询分支合并情况，然后分别对比两个分支的合并分支的异同，并展示到页面上，这里不进行赘述。</p><h4 id="添加-UI-组件库"><a href="#添加-UI-组件库" class="headerlink" title="添加 UI 组件库"></a>添加 UI 组件库</h4><p>组件库这里看到 ant-desin-vue 支持 vue3 了，打算试试。版本需要 2.0.0-beta.5 及以上。</p><p>按需引入，原先是是用 babel-plugin-import 来处理的，不过还没研究如何在 vite 中添加，就打算使用 <code>import Button from &#39;ant-design-vue/lib/button&#39;;</code> 这样的写法，然而运行的时候，vite 会提示:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[vite] Avoid deep import &quot;ant-design-vue&#x2F;lib&#x2F;button&quot; (imported by &#x2F;src&#x2F;main.js)because &quot;ant-design-vue&quot; has been pre-optimized by vite into a single file.Prefer importing directly from the module entry:import &#123; ... &#125; from &quot;ant-design-vue&quot; If the dependency requires deep import to function properly, add the deep path to optimizeDeps.include in vite.config.js.</code></pre><p>意思是 vite 已经做了按需引入的优化了，那么应该直接导入就好了。</p><h4 id="vue3-的-eslint-配置"><a href="#vue3-的-eslint-配置" class="headerlink" title="vue3 的 eslint 配置"></a>vue3 的 eslint 配置</h4><p>填之前的坑，顺便补上 prettier 配置，最终根目录的 eslint 配置如下</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;root&quot;: true,  &quot;parser&quot;: &quot;vue-eslint-parser&quot;,  &quot;parserOptions&quot;: &#123;    &quot;parser&quot;: &quot;@typescript-eslint&#x2F;parser&quot;,    &quot;ecmaVersion&quot;: 6,    &quot;sourceType&quot;: &quot;module&quot;  &#125;,  &quot;extends&quot;: [&quot;plugin:vue&#x2F;vue3-recommended&quot;],  &quot;plugins&quot;: [&quot;@typescript-eslint&quot;, &quot;prettier&quot;],  &quot;rules&quot;: &#123;    &quot;@typescript-eslint&#x2F;naming-convention&quot;: &quot;warn&quot;,    &quot;curly&quot;: &quot;warn&quot;,    &quot;eqeqeq&quot;: &quot;warn&quot;,    &quot;no-throw-literal&quot;: &quot;warn&quot;,    &quot;semi&quot;: &quot;off&quot;,    &quot;vue&#x2F;singleline-html-element-content-newline&quot;: &quot;off&quot;  &#125;&#125;</code></pre><h4 id="vite-别名"><a href="#vite-别名" class="headerlink" title="vite 别名"></a>vite 别名</h4><p>目前似乎没有支持多目录 vue 项目的 vscode 插件，见 <a href="https://github.com/vuejs/vetur/issues/424。我这里使用的是">https://github.com/vuejs/vetur/issues/424。我这里使用的是</a> vetur，为了避免报错，在 vite 中配置 alias。（吐槽一下：总觉得 vscode / ts 对 react 的支持还是比 vue 要好上不少的）</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">alias: &#123;  &#x2F;&#x2F; import useInit from &#39;&#x2F;@&#x2F;composables&#x2F;useInit&#39;  &#39;&#x2F;@&#x2F;&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#x2F;&#39;),&#125;</code></pre><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>由于输出安装包时无需用到 client 的源码，因此可以在 .vscodeignore 中加入 client，同时修改 vite 的输出目录，以及插件中引用 client 资源的目录。</p><p>如果此前没有发布过，可以参考 <a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension#publishing-extensions。">https://code.visualstudio.com/api/working-with-extensions/publishing-extension#publishing-extensions。</a></p><p>需要在 package.json 中添加 <code>publisher name</code> 和 <code>repository</code>，运行 <code>vsce package</code> 可以打出一个 .vsix 的拓展包用于安装。</p><p>如果此前有发布过插件，那么有可能个人访问令牌已经失效了，需要到 <a href="https://aka.ms/SignupAzureDevOps">https://aka.ms/SignupAzureDevOps</a> 上重新创建新的个人访问令牌。</p><p>创建个人访问令牌要注意<code>Organization</code>要选择<code>all accessible organizations</code>，<code>Scopes</code>要选择<code>Full access</code>，否则发布会失败。</p><p>之后添加一下 icon ，再补全一下 README 就可以发布了</p><pre class="line-numbers language-none"><code class="language-none">vsce publish</code></pre><h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><p>以下为个人观点：总体上感觉 Vue3 的组合式 api 和 react 的 hooks 想做的都是同一件事：将原先跟生命周期绑定在一起的逻辑抽离出来，使得代码的关注点更为清晰，同时也更易于复用，作为 hoc / mixins 的一个替代方案。</p><p>不同点是 react 是越来越偏向函数式，比如 useEffect 完全脱离了生命周期的概念，声明式编程。而 vue 依然是命令式，提供了onMounted 之类的 api。</p><p>至于 vite 还没仔细去研究，不过配置确实是少了很多，更容易上手的样子，似乎是基于 rollup ？还有待踩坑。</p>]]></content>
      
      
      <categories>
          
          <category> VSCode插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN瀑布流</title>
      <link href="/2020/10/20/RN%E7%80%91%E5%B8%83%E6%B5%81/"/>
      <url>/2020/10/20/RN%E7%80%91%E5%B8%83%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>电商以及图片网站经常可以看到瀑布流的列表，即多列等宽的列表，但是每一列中的元素高度不一定一致。这在 web 是一个很常见的设计且有很多组件可供使用，而在 ReactNative 中，少有成熟的瀑布流组件，大多数组件要么是多年前维护的，要么 star 数较少，或者干脆有一些不维护了，总之就是用着不放心。因此在产品同学的要求下，实现了一个 RN 瀑布流组件。这里只记录思路，具体代码后面添加了较多业务相关的，就不贴了。</p><a id="more"></a><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ol><li><p>支持上拉加载，下拉刷新</p></li><li><p>支持多列可定制</p></li><li><p>性能尽量好</p></li><li><p>自定义元素</p></li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li><p>整个瀑布流通过 FlatList 来实现，通过设置 columnsNum 与 renderItem，将每一列又分别渲染成一个 FlatList。内层并列的 FlatList 将会撑开且不会产生多余的滚动条，滚动时是外层的 FlatList。</p></li><li><p>接收 data 时，判断每一项应该属于哪一列， 如果项的高度不能提前获得，那么要在项的 onLayout 时获取高度，之后判断下一项属于哪一列</p></li><li><p>下拉采用 RN 提供的 RefreshControl 就可以完成，而上拉的事件，单列表可以通过 onReachEnd 触发，而对于我们这种实现方式则只能通过 onScroll 自行判断是否到达底部</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 由于 onEndReached 在渲染 data 项时会多次触发，且 props 及 state 未变化时不会触发，因此自行实现const handleScroll &#x3D; (event: NativeSyntheticEvent&lt;NativeScrollEvent&gt;) &#x3D;&gt; &#123;  const &#123;    nativeEvent: &#123;      contentOffset: &#123; y: scrollTop &#125;,      contentSize: &#123; height: scrollHeight &#125;,      layoutMeasurement: &#123; height &#125;,    &#125;,  &#125; &#x3D; event;  if (scrollHeight - height - scrollTop &lt;&#x3D; onEndReachedThreshold) &#123;    if (onEndReached) &#123;      onEndReached(event);    &#125;  &#125;  if (props.onScroll) &#123;    props.onScroll(event);  &#125;&#125;;</code></pre></li></ol><p>这样一个简单的 瀑布流就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-native 通讯录字母列表</title>
      <link href="/2020/09/22/react-native-%E9%80%9A%E8%AE%AF%E5%BD%95%E5%AD%97%E6%AF%8D%E5%88%97%E8%A1%A8/"/>
      <url>/2020/09/22/react-native-%E9%80%9A%E8%AE%AF%E5%BD%95%E5%AD%97%E6%AF%8D%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>需求：实现一个选择快递的页面，操作类似于通讯录，设计图如下</p><img src="https://i.loli.net/2020/10/20/OwH5A3bRgSuiBKt.png" alt="image.png" style="zoom: 50%"><p>上半部分的搜索交互及实现这里就不赘述，重点探讨字母列表的实现。</p><a id="more"></a><p>需要实现的点：</p><ol><li>主列表分组，头部不吸顶</li><li>字母列表可以滑动或点击，变更当前选中的字母，且主列表跟随滑动定位</li><li>主列表滚动时，字母列表当前选中的字母对应变化</li></ol><p>搜索了目前已有的开源组件，要么最后一次更新的时间也比较久远，要么不适用于我们的场景，要么 star 数量不多 😂。因此打算重新造个轮子，即使将来有什么问题，也能自行维护。</p><h4 id="AlphabetList"><a href="#AlphabetList" class="headerlink" title="AlphabetList"></a>AlphabetList</h4><p>将我们的组件命名为 AlphabetList，它将接收一个 dataSource ：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;AlphabetList dataSource&#x3D;&#123;dataSource&#125; &#x2F;&gt;</code></pre><p>dataSource 的结构如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface IListItem &#123;  name: string;  value: string | number;&#125;interface ISectionItem &#123;sectionKey: string;data: &#123;name: string;value: string&#125;[]&#125;interface DataSource: SectionItem[]</code></pre><p>例如：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">[  &#123;    sectionKey: &#39;常&#39;,    data: [      &#123;        name: &#39;顺丰物流&#39;,        value: &#39;1&#39;,      &#125;,      &#123;        name: &#39;京东快递&#39;,        value: &#39;2&#39;,      &#125;,    ],  &#125;,  &#123;    sectionKey: &#39;A&#39;,    data: [      &#123;        name: &#39;安能物流&#39;,        value: &#39;3&#39;,      &#125;,      &#123;        name: &#39;澳大利亚邮政&#39;,        value: &#39;4&#39;,      &#125;,    ],  &#125;]</code></pre><p>AlphabetList 的结构如下：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;View&gt;  &#123;&#x2F;* 主列表 *&#x2F;&#125;  &lt;MainList &#x2F;&gt;  &#123;&#x2F;* 右侧字母列表 *&#x2F;&#125;  &lt;SideBar &#x2F;&gt;&lt;&#x2F;View&gt;</code></pre><h4 id="MainList"><a href="#MainList" class="headerlink" title="MainList"></a>MainList</h4><p>主列表分组 Main，那么使用 SectionList 是一个不错的选择（当然也可以用 FlatList 来实现）</p><p>当滚动 MainList 时，通过 <code>onListViewableItemsChanged</code> 的回调可以得到当前窗口可视的分组，从而改变当前选中的字母</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const MainList &#x3D; (&#123;    dataSource,    onMainListViewableItemsChanged,  &#125;) &#x3D;&gt; &#123;  return (    &lt;SectionList      renderItem&#x3D;&#123;(&#123; item &#125;) &#x3D;&gt; (&lt;ListItem item&#x3D;&#123;item&#125; &#x2F;&gt;)&#125;      renderSectionHeader&#x3D;&#123;(&#123; section &#125;) &#x3D;&gt; &lt;SectionHeader section&#x3D;&#123;section&#125; &#x2F;&gt;&#125;      keyExtractor&#x3D;&#123;(item) &#x3D;&gt; &#96;$&#123;item.value&#125;&#96;&#125;      sections&#x3D;&#123;dataSource&#125;      stickySectionHeadersEnabled&#x3D;&#123;false&#125;      onViewableItemsChanged&#x3D;&#123;onMainListViewableItemsChanged&#125;    &#x2F;&gt;  );&#125;;export default MainList;</code></pre><p>在 AlphabetList 中：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const AlphabetList &#x3D; (&#123; dataSource &#125;: IProps) &#x3D;&gt; &#123;  &#x2F;&#x2F; 右侧字母表列表  const letterlist &#x3D; dataSource.map((item) &#x3D;&gt; &#123;    return item.sectionKey;  &#125;);  const [currentSectionKey, setCurrentSectionKey] &#x3D; useState(letterlist);  const onMainListViewableItemsChanged &#x3D; (info: &#123;    viewableItems: ViewToken[];  &#125;) &#x3D;&gt; &#123;    &#x2F;&#x2F; 将选中的字母设置为当前第一个可见 section 的 sectionKey    setCurrentSectionKey(info.viewableItems[0].section.sectionKey);  &#125;;  return (    &lt;View style&#x3D;&#123;styles.container&#125;&gt;      &#123;&#x2F;* 主列表 start *&#x2F;&#125;      &lt;MainList        dataSource&#x3D;&#123;dataSource&#125;        onMainListTouchStart&#x3D;&#123;() &#x3D;&gt; setCurrentResponder(&#39;mainList&#39;)&#125;        onMainListViewableItemsChanged&#x3D;&#123;onMainListViewableItemsChanged&#125;      &#x2F;&gt;      &#123;&#x2F;* 主列表 end *&#x2F;&#125;      &#123;&#x2F;* 右侧字母列表 start *&#x2F;&#125;      &lt;SideBar &#x2F;&gt;      &#123;&#x2F;* 右侧字母列表 end *&#x2F;&#125;    &lt;&#x2F;View&gt;  );&#125;;export default AlphabetList;</code></pre><h4 id="SideBar"><a href="#SideBar" class="headerlink" title="SideBar"></a>SideBar</h4><p>侧边栏的实现比起来则要复杂一些，这里使用一个绝对定位的 FlatList，实际上简单使用 View 去实现也是可以的。</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const SideBar &#x3D; (&#123;  letterlist,  &#x2F;&#x2F; 回调  handleSideBarItemRespond,  currentSectionKey&#125;: IProps) &#x3D;&gt; &#123;  return (    &lt;FlatList      style&#x3D;&#123;styles.wrap&#125;      scrollEnabled&#x3D;&#123;false&#125;      data&#x3D;&#123;letterlist&#125;      renderItem&#x3D;&#123;(&#123; item, index &#125;) &#x3D;&gt; (        &lt;Item          item&#x3D;&#123;item&#125;          handleSideBarItemRespond&#x3D;&#123;handleSideBarItemRespond&#125;          letterlist&#x3D;&#123;letterlist&#125;        &#x2F;&gt;      )&#125;      keyExtractor&#x3D;&#123;item &#x3D;&gt; item&#125;    &#x2F;&gt;  );&#125;;</code></pre><p>一开始我的想法是通过监听 Item 的 onPress | onPressIn ，从一项滑动到另一项的时候，依次触发事件，实验后发现，在释放手势之前，仅会有一个响应的元素。</p><p>这里就得提一下 RN 的手势系统了。</p><h5 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h5><p>在 React Native 中，响应手势的基本单位是<code>responder</code>，并且仅有一个 <code>responder</code> 拥有控制权。在 View 上有这些属性：</p><ol><li>onStartShouldSetResponder：点击时是否变成一个 responder</li><li>onMoveShouldSetResponder：滑动时是否变成一个 responder</li><li>onResponderGrant： 点击时的回调</li><li>onResponderMove：移动时的回调</li><li>onResponderTerminationRequest：当别的元素希望成为 responder 时，是否要释放当前的 responder？</li><li>onResponderRelease：当 reponder 释放时的回调</li><li>等等</li></ol><p>通过上述这些 API 我们就能很容易的实现一些手势。初次之外，RN 还提供了更高级的抽象 PanResponder，它可以给我们提供更多手势信息，这里不展开解释。</p><p>不过当我尝试在每个 Item 上设置手势响应，并且设置  onResponderTerminationRequest 为 <code>() =&gt; true</code>，手势依然没有在切换 Item 时释放原 responder。</p><p>因此只能通过计算高度来获取滑动时当前的字母</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; evt.nativeEvent.pageY: 触摸事件的 pageY&#x2F;&#x2F; sideBarTop: SideBar 的 pageY&#x2F;&#x2F; letterHeight：每个字母的高度const index &#x3D; Math.floor((evt.nativeEvent.pageY - sideBarTop) &#x2F; letterHeight);</code></pre><p>要获取元素距离屏幕的高度，可以在 onLayout 的时候，调用 measure 来获取：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const SideBar &#x3D; (&#123;  letterlist,  handleSideBarItemRespond,  currentSectionKey,  letterHeight,&#125;: IProps) &#x3D;&gt; &#123;  const [sideBarTop, setSideBarTop] &#x3D; useState(0);  const sideBarRef &#x3D; useRef&lt;View&gt;(null);  const measure &#x3D; () &#x3D;&gt; &#123;    if (sideBarRef.current) &#123;      sideBarRef.current.measure((x, y, width, height, pageX, pageY) &#x3D;&gt; &#123;        setSideBarTop(pageY);      &#125;);    &#125;  &#125;;  return (    &lt;View onLayout&#x3D;&#123;measure&#125; ref&#x3D;&#123;sideBarRef&#125;&gt;      &lt;FlatList&lt;string&gt;        &#x2F;&#x2F; ...      &#x2F;&gt;    &lt;&#x2F;View&gt;  );&#125;;</code></pre><p>然后就是 Item 的实现：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const Item &#x3D; (&#123;  item,  handleSideBarItemRespond,  isCurrentSectionKey,  letterlist,  letterHeight,  sideBarTop,&#125;: &#123;  item: string;  isFirst: boolean;  handleSideBarItemRespond: (item: string) &#x3D;&gt; void;  letterlist: string[];  letterHeight: number;  sideBarTop?: number;&#125;) &#x3D;&gt; &#123;  const panResponder &#x3D; PanResponder.create(&#123;    onStartShouldSetPanResponderCapture: () &#x3D;&gt; true,    onStartShouldSetPanResponder: () &#x3D;&gt; true,    &#x2F;&#x2F; 尝试通过 onResponderTerminationRequest 来终止手势，发现不生效，只能通过计算偏移量来获取当前选中    onPanResponderTerminationRequest: () &#x3D;&gt; true,    onPanResponderGrant: () &#x3D;&gt; &#123;      handleSideBarItemRespond(item);    &#125;,    onPanResponderMove: (evt, gs) &#x3D;&gt; &#123;      if (!sideBarTop) &#123;        return;      &#125;      const index &#x3D; Math.floor(        (evt.nativeEvent.pageY - sideBarTop) &#x2F; letterHeight,      );      if (index &gt;&#x3D; 0 &amp;&amp; index &lt; letterlist.length) &#123;        &#x2F;&#x2F; 触发侧边字母选中的回调        handleSideBarItemRespond(letterlist[index]);      &#125;    &#125;,  &#125;);  return (    &lt;View &#123;...panResponder.panHandlers&#125;&gt;      &lt;Text&gt;        &#123;item&#125;      &lt;&#x2F;Text&gt;    &lt;&#x2F;View&gt;  );&#125;;</code></pre><p>到此为止，侧边栏的逻辑已经完成。现在处理侧边栏事件的回调逻辑, 主要通过 scrollToLocation 来实现列表滚动到对应的位置</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const AlphabetList &#x3D; (&#123; dataSource, companyList, onCompanySelect &#125;: IProps) &#x3D;&gt; &#123;  &#x2F;&#x2F; ...  const mainListRef &#x3D; useRef&lt;SectionList&lt;IListItem&gt;&gt;(null);  const handleSideBarItemRespond &#x3D; (item: string) &#x3D;&gt; &#123;    if (!mainListRef.current) &#123;      return;    &#125;  &#x2F;&#x2F; 记录当前选中的字母    setCurrentSectionKey(item);    mainListRef.current.scrollToLocation(&#123;      sectionIndex: dataSource.findIndex((data) &#x3D;&gt; data.sectionKey &#x3D;&#x3D;&#x3D; item),      itemIndex: 0,      animated: false,    &#125;);  &#125;;  return (    &lt;View style&#x3D;&#123;styles.container&#125;&gt;      &#123;&#x2F;* 主列表 start *&#x2F;&#125;      &lt;MainList        &#x2F;&#x2F; ...        ref&#x3D;&#123;mainListRef&#125;      &#x2F;&gt;      &#x2F;&#x2F; ...    &lt;&#x2F;View&gt;  );&#125;;</code></pre><p>这里需要通过 React.forwardRef 获取到 MainList 的 ref</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const MainList: React.ForwardRefRenderFunction&lt;  SectionList&lt;IListItem&gt;,  IProps&gt; &#x3D; (  &#123;    dataSource,    &#x2F;&#x2F; ...  &#125;,  ref,) &#x3D;&gt; &#123; &#x2F;&#x2F; ...  return (    &lt;SectionList      &#x2F;&#x2F; ...      ref&#x3D;&#123;ref&#125;    &#x2F;&gt;  );&#125;;export default React.forwardRef(MainList)</code></pre><p>到这一步，已经基本完成了一个通讯录字母列表。</p><h4 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h4><p>在完成上述功能后，由于点击侧边栏会滚动主列表，此时也会触发 MainList 的 onViewableItemsChanged，因此需要一个标识来区分是什么动作触发的：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const AlphabetList &#x3D; (&#123; dataSource, companyList, onCompanySelect &#125;: IProps) &#x3D;&gt; &#123;  &#x2F;&#x2F; 标识位：用于区分当前的操作是由什么触发的  const [currentResponder, setCurrentResponder] &#x3D; useState(&#39;&#39;);  const mainListRef &#x3D; useRef&lt;SectionList&lt;IListItem&gt;&gt;(null);  &#x2F;&#x2F; 右侧字母表列表  const letterlist &#x3D; dataSource.map((item) &#x3D;&gt; &#123;    return item.sectionKey;  &#125;);  const [currentSectionKey, setCurrentSectionKey] &#x3D; useState(letterlist[0]);  const handleSideBarItemRespond &#x3D; (item: string) &#x3D;&gt; &#123;    if (!mainListRef.current) &#123;      return;    &#125;    setCurrentResponder(&#39;sideBar&#39;);  &#x2F;&#x2F; ...  &#125;;  const onMainListViewableItemsChanged &#x3D; (info: &#123;    viewableItems: ViewToken[];  &#125;) &#x3D;&gt; &#123;    if (      &#x2F;&#x2F; 侧边栏触发的滚动则不触发      currentResponder &#x3D;&#x3D;&#x3D; &#39;sideBar&#39; ||      !info.viewableItems[0].section.sectionKey    ) &#123;      return;    &#125;    setCurrentSectionKey(info.viewableItems[0].section.sectionKey);  &#125;;  return (    &lt;View style&#x3D;&#123;styles.container&#125;&gt;      &#123;&#x2F;* 主列表 start *&#x2F;&#125;      &lt;MainList       &#x2F;&#x2F; ...        onMainListTouchStart&#x3D;&#123;() &#x3D;&gt; setCurrentResponder(&#39;mainList&#39;)&#125;        &#x2F;&#x2F; ...      &#x2F;&gt;      &#123;&#x2F;* 主列表 end *&#x2F;&#125;      &#x2F;&#x2F; ...    &lt;&#x2F;View&gt;  );&#125;;</code></pre><h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><p>功能是基本上完成了，然而由于这里的数据量比较多，大概有 600 条数据，且由于 SectionList 也是基于 VirtualList，因此导致了以下长列表固有的几个问题：</p><ol><li>快速滚动 MainList，当 SectionList 来不及渲染时，会导致屏幕空白</li><li>当使用 scrollToLocation 时，如果定位到来不及渲染的区域，将会报错，提示需要设置 getItemLayout 属性，这个属性是用于计算主列表每一项高度以及偏移量的</li></ol><p>在尝试了一些优化的手段后，如 React.memo, initialNumToRender，getItemLayout 等属性依然无法有效解决上述问题。。</p><p>RN 的 list 真的是让人一言难尽。。不知道是否原生组件或者 flutter 对长列表的支持会更好一点呢 😂</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> TypeScript 的 enum 类型收窄问题</title>
      <link href="/2020/09/21/TypeScript-%E7%9A%84-enum-%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/09/21/TypeScript-%E7%9A%84-enum-%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在项目中看到一段小伙伴写的代码，简化后大概如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">enum A &#123;  &quot;ONE&quot; &#x3D; 1,  &quot;TWO&quot; &#x3D; 2&#125;const a &#x3D; Math.random() &gt; 0.5 ? A.ONE : A.TWOconst b &#x3D; Math.random() &gt; 0.5 ? a : 0if(b &#x3D;&#x3D;&#x3D; 1 || b &#x3D;&#x3D;&#x3D; 2) &#123;&#125;</code></pre><p>此时，b === 2 处 ts 会提示:</p><pre class="line-numbers language-none"><code class="language-none">This condition will always return &#39;false&#39; since the types &#39;0&#39; and &#39;2&#39; have no overlap.ts(2367)</code></pre><p>为何 TypeScript 会提示 0 与 2 没有重合的地方呢？</p><a id="more"></a><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>鼠标悬浮在 b === 1 时，提示 b 的类型为 A ｜ 0 的联合类型，而到了 b === 2 时，却变成了 <code>b: 0</code>。那么也就是说 TypeScript 在判断 b !== 1 时，就判定 b 不可能为类型 A，此时将类型收窄为 0。而 0 不可能 assgin 给 2，因此报错。上网搜索似乎也没有得到为何时这种收窄策略的原因，仅有一个可能有关联的 <a href="https://github.com/Microsoft/TypeScript/issues/9998">https://github.com/Microsoft/TypeScript/issues/9998</a> , 然而至今还是 open 的。</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>那我们要怎么解决这个报错呢？实际上我们将判断的右值改成 enum 即可，且逻辑更清晰，维护更简单：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">if(b &#x3D;&#x3D;&#x3D; A.ONE || b &#x3D;&#x3D;&#x3D; A.TWO) &#123;&#x2F;&#x2F; no error&#125;</code></pre><p>或者下面这种也可以（不是很推荐，没有发挥出 enum 应有的作用）</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">if(b as A &#x3D;&#x3D;&#x3D; 1 || b &#x3D;&#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; no error&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次bug排查</title>
      <link href="/2020/09/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1bug%E6%8E%92%E6%9F%A5/"/>
      <url>/2020/09/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1bug%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>测试同学提了一个测试环境表格无法切换每页条数的 bug。</p><h4 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h4><p>在测试环境操作后发现，确实存在该问题，但是切换到对应测试分支，本地运行，未能重现。</p><a id="more"></a><p>在测试环境的操作发现实际上切换每页条数的回调 onShowSizeChange 确实会触发，但是此后又变回原每页条数。</p><p>对于测试环境与本地开发的表现不一致，在排除了各种可能性之后，猜测是依赖版本不一致导致的。</p><p>版本不一致出现问题此前已经出现过一次：我本地的有段代码提示了一个 eslint 的 no-throw-literal，但是别的同事都没有报错， eslintrc 的配置是一样的。最终发现是我的 umi 版本比较高，其中依赖的 @typescript-eslint/eslint-plugin 在 2.13.0 新增了 no-throw-literal 这个配置，而别的小伙伴们的版本低于此，故不会报错。</p><p>因此执行命令 <code>npm ci</code> ，该命令会按照 packge-lock.json 中记录的版本进行安装,下面是这个命令的说明</p><blockquote><p>This command is similar to <code>npm-install</code>, except it’s meant to be used in automated environments such as test platforms, continuous integration, and deployment – or any situation where you want to make sure you’re doing a clean install of your dependencies. It can be significantly faster than a regular npm install by skipping certain user-oriented features. It is also more strict than a regular install, which can help catch errors or inconsistencies caused by the incrementally-installed local environments of most npm users.</p></blockquote><p>重新安装依赖之后果然本地可以重现该问题。</p><p>此后经过 debug 发现，切换 pageSize 会先后触发 onShowSizeChange 和表格的 onChange，表格的 onChange 重新将 pageSize 设置回去。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最终如何解决上述 bug 就不赘述了。</p><p>主要想总结的是：遇到 bug，如果出现代码和运行环境之类的各种条件都一致，但是表现就是不一致的情况，那么很有可能是依赖包的版本不一致导致的 👻</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易 redux</title>
      <link href="/2020/09/14/%E7%AE%80%E6%98%93-redux/"/>
      <url>/2020/09/14/%E7%AE%80%E6%98%93-redux/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Redux 常常配合 react-redux 作为状态管理应用在 React 的项目中，并且基于 redux 发展出了 dva 之类的诸多状态管理工具。</p><p>说来惭愧，虽然在项目中常常使用到，但是并未阅读过 redux 的源码，了解其原理。本文作为学习笔记，并根据 redux 的比较核心的 createStore 这部分代码实现一个简易版本的 redux，以便将来回顾。</p><a id="more"></a><h4 id="redux-demo"><a href="#redux-demo" class="headerlink" title="redux demo"></a>redux demo</h4><p>redux 提供了使用 demo 如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; createStore &#125; from &#39;redux&#39;&#x2F;** * 这是个 reducer，纯函数，用于描述状态是如何转变的 * reducer 接收 state 和 action 作为参数 *&#x2F;function counter(state &#x3D; 0, action) &#123;  switch (action.type) &#123;    case &#39;INCREMENT&#39;:      return state + 1    case &#39;DECREMENT&#39;:      return state - 1    default:      return state  &#125;&#125;&#x2F;&#x2F; createStore：接收 reducer 作为参数，以此构建一个 storelet store &#x3D; createStore(counter)&#x2F;&#x2F; 订阅 store, 每次 dispatch 的时候，都将触发回调store.subscribe(() &#x3D;&gt; console.log(store.getState()))&#x2F;&#x2F; dispath 一个 actionstore.dispatch(&#123; type: &#39;INCREMENT&#39; &#125;)</code></pre><h4 id="简化的数据流"><a href="#简化的数据流" class="headerlink" title="简化的数据流"></a>简化的数据流</h4><img src="https://i.loli.net/2020/11/09/UscH6njLXxCVDvu.png" alt="fiber" style="zoom:50%;" /><p>以上的数据流简化了 combineReducers 等过程</p><h4 id="简易-redux"><a href="#简易-redux" class="headerlink" title="简易 redux"></a>简易 redux</h4><p>可以看出 redux 实际上就是一个发布订阅模式，简易版实现如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const createStore &#x3D; (reducer) &#x3D;&gt; &#123;  let state  &#x2F;&#x2F; 订阅的回调  let listeners &#x3D; []  &#x2F;&#x2F; 获取 state  const getState &#x3D; () &#x3D;&gt; &#123;    return state  &#125;  const dispatch &#x3D; (action) &#x3D;&gt; &#123;    &#x2F;&#x2F; 更新 state    state &#x3D; reducer(state, action)    &#x2F;&#x2F; 一旦 dispatch 就执行所有订阅的回调    listeners.forEach((listener) &#x3D;&gt; listener())  &#125;  const subscribe &#x3D; (listener) &#x3D;&gt; &#123;    &#x2F;&#x2F; 收集回调    listeners.push(listener)    return () &#x3D;&gt; &#123;      &#x2F;&#x2F; 取消订阅      listeners &#x3D; listeners.filter((l) &#x3D;&gt; l !&#x3D;&#x3D; listener)    &#125;  &#125;  return &#123;    getState,    dispatch,    subscribe,  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>告别魔法数字</title>
      <link href="/2020/09/12/%E5%91%8A%E5%88%AB%E9%AD%94%E6%B3%95%E6%95%B0%E5%AD%97/"/>
      <url>/2020/09/12/%E5%91%8A%E5%88%AB%E9%AD%94%E6%B3%95%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>在以往的开发中往往会出现类似以下的代码</p> <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if(status &#x3D;&#x3D;&#x3D; 1) &#123;   &#x2F;&#x2F; do something&#125; else if(status &#x3D;&#x3D;&#x3D; 2) &#123;   &#x2F;&#x2F; do something&#125; else if (status &#x3D;&#x3D;&#x3D; 3) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><p>上面代码中的 <code>1</code>，<code>2</code>，<code>3</code>就是所谓的魔法数字，即没有注释的情况下我们很难知道 1，2，3 代表的到底是什么 status。</p><a id="more"></a><h4 id="常量对象"><a href="#常量对象" class="headerlink" title="常量对象"></a>常量对象</h4><p>在 javascript 中，我们可以将这些数字维护在一个常量对象中</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const STATUS &#x3D; &#123;  ERROR: 1,  NORMAL: 2,  SUCCESS: 3&#125;</code></pre><p>使用时就可以使用 STATUS.ERROR 来替换掉 1。</p><p>这样可以很清晰就分清楚 1，2，3 这些数值对应的是什么含义。同时如果将来 ERROR 不再是 1，我们也只需要维护 STATUS 即可。</p><h4 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h4><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>而在 TypeScript 中，我们则可以使用枚举类型来维护这些数值。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">enum STATUS &#123;  ERROR &#x3D; 1,  NORMAL,  SUCCESS&#125;</code></pre><p>使用时同样是 STATUS.ERROR 替换掉 1 即可。</p><p>关于 enums 的使用<a href="https://www.tslang.cn/docs/handbook/enums.html">文档</a>里描述的已经很清楚，这里不再赘述。</p><h4 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h4><p>值得一提的是 enums 提供了常量对象不具备的反向映射（value<code>-&gt;</code>name ）。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const STATUS &#x3D; &#123;  ERROR: 1,  NORMAL: 2,  SUCCESS: 3&#125;&#x2F;&#x2F; 输出：&quot;ERROR&quot;STATUS[1]</code></pre><p>这是因为 ts 将上述的 enums 编译成以下代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var STATUS;(function (STATUS) &#123;  STATUS[STATUS[&quot;ERROR&quot;] &#x3D; 1] &#x3D; &quot;ERROR&quot;;  STATUS[STATUS[&quot;NORMAL&quot;] &#x3D; 2] &#x3D; &quot;NORMAL&quot;;  STATUS[STATUS[&quot;SUCCESS&quot;] &#x3D; 3] &#x3D; &quot;SUCCESS&quot;;&#125;)(STATUS || (STATUS &#x3D; &#123;&#125;));</code></pre><p>⚠️ 但如果是字符串枚举成员则不会生成反向映射。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">enum STATUS &#123;  ERROR &#x3D; &quot;1&quot;,  NORMAL &#x3D; &quot;2&quot;,  SUCCESS &#x3D; &quot;3&quot;&#125;&#x2F;&#x2F; 编译后var STATUS;(function (STATUS) &#123;  STATUS[&quot;ERROR2&quot;] &#x3D; &quot;1&quot;;  STATUS[&quot;NORMAL&quot;] &#x3D; &quot;2&quot;;  sSTATUS[&quot;SUCCESS&quot;] &#x3D; &quot;3&quot;;&#125;)(STATUS || (STATUS &#x3D; &#123;&#125;));</code></pre><p>并且对于重复定义的枚举类型，将会合并成员：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">enum STATUS &#123;  ERROR &#x3D; 1,&#125;enum STATUS &#123;  NORMAL &#x3D; 2,&#125;&#x2F;&#x2F; 等效于enum STATUS &#123;  ERROR &#x3D; 1,  NORMAL &#x3D; 2,&#125;</code></pre><h4 id="const-枚举"><a href="#const-枚举" class="headerlink" title="const 枚举"></a>const 枚举</h4><p>关于枚举，还有一种不是常见的写法</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const enum STATUS &#123;  ERROR &#x3D; 1,&#125;</code></pre><p>即声明前有个关键字 const。</p><p>与常规枚举不同的地方在于</p><ol><li>const 枚举不会编译出额外的代码</li></ol><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const enum STATUS &#123;  ERROR &#x3D; 1,&#125;console.log(STATUS.ERROR)&#x2F;&#x2F; 最终的编译出的代码不包含 STATUSconsole.log(1 &#x2F;* ERROR *&#x2F;);</code></pre><ol start="2"><li>也正因为编译阶段就会确定下枚举的成员，const 枚举不可以包含计算成员</li></ol><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const geterror &#x3D; () &#x3D;&gt; 3const enum STATUS &#123;  &#x2F;&#x2F; In &#39;const&#39; enum declarations member initializer must be constant expression.  ERROR &#x3D; geterror()&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 泛型组件</title>
      <link href="/2020/09/08/React%20%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/09/08/React%20%E6%B3%9B%E5%9E%8B%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>场景：封装一个 antd 的 Radio 组件时，需要从父组件获取到 value 的类型。其 props 接口定义如下</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface CustomRadioProps&lt;ValueType&gt; &#123;  options: Option&lt;ValueType&gt;[];  value: ValueType;  onChange: (value: ValueType) &#x3D;&gt; void;&#125;</code></pre><p>使用时这里假设传进去的是个 number 类型</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;CustomRadio&lt;number&gt;  onChange&#x3D;&#123;handleTypeChange&#125;  options&#x3D;&#123;[    &#123;      label: &#39;1&#39;,      value: 1,    &#125;,    &#123;      label: &#39;1&#39;,      value: 2,    &#125;,  ]&#125;  value&#x3D;&#123;1&#125;&#x2F;&gt;</code></pre><p>那么这个 CustomRadioProps 称为泛型组件。</p><p>那么如何定义一个泛型组件？</p><a id="more"></a><h4 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h4><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">class CustomRadio&lt;T&gt; extends React.Component&lt;Props&lt;T&gt;&gt; &#123; &#x2F;&#x2F; ...&#125;</code></pre><h4 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h4><p>对于用 function 声明的函数式组件实际上于泛型函数是一样的写法：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function CustomRadio&lt;T&gt;(props: IProps&lt;T&gt;) &#123;&#x2F;&#x2F; ...&#125;</code></pre><p>然而对于用箭头函数不可以这么写：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const CustomRadio: React.FunctionComponent&lt;IProps&lt;T&gt;&gt; &#x3D; props &#x3D;&gt; &#123; &#x2F;*...*&#x2F; &#125; </code></pre><p>箭头函数组件正确的写法：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">const IconRadioGroup &#x3D; &lt;T extends any&gt;(props: IProps&lt;T&gt;) &#x3D;&gt; &#123;&#x2F;&#x2F; ...&#125;</code></pre><p>这里 T 必须要使用 extends, 用 <code>T extends any</code> 来表明接收任意类型，如果只能 number 或者 string类型，则改成  <code>T extends number｜string</code> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js获取后缀名</title>
      <link href="/2020/09/02/js%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/"/>
      <url>/2020/09/02/js%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Code Review 的时候看到小伙伴提交了一段用于提取文件拓展名的代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 截取图片后缀信息&#x2F;&#x2F; example: &#39;www.baidu.com&#x2F;somepic.jpg?h&#x2F;w&#x2F;&#39;&#x2F;&#x2F; return: &#39;.jpg&#39;const getExtension &#x3D; (url &#x3D; &#39;&#39;) &#x3D;&gt; &#123;  const end &#x3D; url.indexOf(&#39;?&#39;) || undefined;  const start &#x3D; url.lastIndexOf(&#39;.&#39;, end);  return url.substring(start, end);&#125;;</code></pre><p>这种写法固然没错，那么是否有别的写法嘞?</p><a id="more"></a><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const getExtension &#x3D; (url &#x3D; &#39;&#39;) &#x3D;&gt; &#123;  const extensionName &#x3D; url.split(&#39;.&#39;).pop()  return extensionName ? &#96;.$&#123;extensionName&#125;&#96; : &#39;&#39;&#125;</code></pre><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>正则表达式</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const getExtension &#x3D; (url &#x3D; &#39;&#39;) &#x3D;&gt; &#123;  const matches &#x3D; url.match(&#x2F;.*(\.[^?]+)&#x2F;)  return matches ? matches[1] : &#39;&#39;&#125;</code></pre><p>可能有些同学对正则不太熟悉，以下对这个正则做一下解释：</p><ol><li><code>.*</code>： . 表示非换行符号， * 用于消耗尽可能多的字符</li><li><code>()</code> 括号表示捕获组，这里 <code>()</code> 中的表达式就是用于捕获后缀名。</li><li><code>\.</code> 表示 . 的转义</li><li><code>[^\?+]</code>: ^ 表示非， + 表示一个或者多个。因此 <code>[^?+]</code> 即表示非 ？的多个字符</li></ol><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>如果是在 node 的环境，本地的文件名可以通过 path 模块提供的 extname 获取：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const &#123; extname &#125; &#x3D; require(&#39;path&#39;)console.log(extname(&#39;some-pic.jpg&#39;))&#x2F;&#x2F; .jpg</code></pre><p>那如果是远程地址呢？可以通过 url 模块得到 pathname 之后再用 extname 来获取：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const &#123; extname &#125; &#x3D; require(&#39;path&#39;)const &#123; parse &#125; &#x3D; require(&#39;url&#39;);const getExtension &#x3D; (url &#x3D; &#39;&#39;) &#x3D;&gt; extname(parse(url).pathname)</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript中的const断言</title>
      <link href="/2020/08/26/TypeScript%E4%B8%AD%E7%9A%84const%E6%96%AD%E8%A8%80/"/>
      <url>/2020/08/26/TypeScript%E4%B8%AD%E7%9A%84const%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近在使用 ant design 的 Table 组件，遇到一个问题，定义 Table 的 columns 属性如下：</p><a id="more"></a><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const columns: ColumnProps&lt;MyRecord&gt;[] &#x3D; [&#123;  title: &#39;ID&#39;,  dataIndex: &#39;id&#39;,  align: &#39;center&#39;,&#125;]</code></pre><p>此时 TS 提示：</p><pre class="line-numbers language-none"><code class="language-none">Types of property &#39;align&#39; are incompatible.        Type &#39;string&#39; is not assignable to type &#39;&quot;right&quot; | &quot;left&quot; | &quot;center&quot; | undefined&#39;.  TS2322</code></pre><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>经过查看代码发现， ColumnProps 的 align 属性的实际继承自 ColumnSharedType：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface ColumnSharedType&lt;RecordType&gt; &#123;    &#x2F;&#x2F; ...    align?: AlignType;&#125;export declare type AlignType &#x3D; &#39;left&#39; | &#39;center&#39; | &#39;right&#39;;</code></pre><p>也就是 column 中的 align 的类型为 string，而 string 无法 cast 到 AlignType。即：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type AlignType &#x3D; &#39;left&#39; | &#39;center&#39; | &#39;right&#39;;let align: AlignType | undefinedlet myAlign &#x3D; &quot;center&quot;&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;&quot;left&quot; | &quot;right&quot; | &quot;center&quot; | undefined&#39;.ts(2322)align &#x3D; myAlign</code></pre><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>TypeScript 3.4 版本以上提供了 const 断言，可以通过 as const 来消除以上报错：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const columns: ColumnProps&lt;MyRecord&gt;[] &#x3D; [&#123;  title: &#39;ID&#39;,  dataIndex: &#39;id&#39;,  align: &#39;center&#39; as const,&#125;]</code></pre><h4 id="const-assertions"><a href="#const-assertions" class="headerlink" title="const assertions"></a>const assertions</h4><p>以下内容翻译自 <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-4-rc/">https://devblogs.microsoft.com/typescript/announcing-typescript-3-4-rc/</a> 中的 <code>const</code> assertions。(翻译不动的地方会贴上原文)</p><p>当声明一个可变的变量或者属性时，TypeScript 经常拓宽值以确保我们可以在不写明确切的类型的情况下进行赋值。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let x &#x3D; &quot;hello&quot;;&#x2F;&#x2F; 我们可以给 x 赋值x &#x3D; &quot;world&quot;;</code></pre><p>严格来说，每一个字面量都有其字面类型。上面的 x 在类型推断时，由 <code>&quot;hello&quot;</code> 类型转为更为 widen 的 <code>string</code> 类型。</p><p>相对而言，如果 x 原始字面量类型为 “hello”， 那么我们就无法将 x 赋值为 “world”:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let x: &quot;hello&quot; &#x3D; &quot;hello&quot;;&#x2F;&#x2F; error!x &#x3D; &quot;world&quot;;</code></pre><p>上面的情况看起来比较极端，但是在一些情况下比较有用的，例如，我们经常创建一个联合属性的对象：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Shape &#x3D;    | &#123; kind: &quot;circle&quot;, radius: number &#125;    | &#123; kind: &quot;square&quot;, sideLength: number &#125;function getShapes(): readonly Shape[] &#123;    let result &#x3D; [        &#123; kind: &quot;circle&quot;, radius: 100, &#125;,        &#123; kind: &quot;square&quot;, sideLength: 50, &#125;,    ];        &#x2F;&#x2F; Some terrible error message because TypeScript inferred    &#x2F;&#x2F; &#39;kind&#39; to have the type &#39;string&#39; instead of    &#x2F;&#x2F; either &#39;&quot;circle&quot;&#39; or &#39;&quot;square&quot;&#39;.    return result;&#125;</code></pre><p>可修改性是 TypeScript 断定什么时候 widen 类型的重要因素，而非分析所有代码。（Mutability is one of the best heuristics of intent which TypeScript can use to determine when to widen (rather than analyzing our entire program).）</p><p>正如上述例子，不幸的是，JavaScript 中的属性默认可修改。这意味着经常会有不必要的 widen 类型，我们需要在特定的地方对类型进行确切的声明：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getShapes(): readonly Shape[] &#123;  &#x2F;&#x2F; This explicit annotation gives a hint  &#x2F;&#x2F; to avoid widening in the first place.  let result: readonly Shape[] &#x3D; [  &#123; kind: &quot;circle&quot;, radius: 100, &#125;,  &#123; kind: &quot;square&quot;, sideLength: 50, &#125;,  ];  return result;&#125;</code></pre><p>上述的方法可以解决问题，但是当数据结构越来越复杂的时候，这种方式将会显的笨重。</p><p>为了解决这个问题，TypeScript 3.4 为字面值引入了 const 断言。它的语法是一种类型断言，例如 <code>123 as const</code>。当我们这么使用的时候，意味着：</p><ol><li>字面量类型不会被 widen，如不会从 “hello” 变成 string</li><li>对象字面量的属性值为只读</li><li>数组字面量变成只读元组</li></ol><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Type &#39;10&#39;let x &#x3D; 10 as const;&#x2F;&#x2F; Type &#39;readonly [10, 20]&#39;let y &#x3D; [10, 20] as const;&#x2F;&#x2F; Type &#39;&#123; readonly text: &quot;hello&quot; &#125;&#39;let z &#x3D; &#123; text: &quot;hello&quot; &#125; as const;</code></pre><p>在 tsx 文件以外，还可以这么使用：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Type &#39;10&#39;let x &#x3D; &lt;const&gt;10;&#x2F;&#x2F; Type &#39;readonly [10, 20]&#39;let y &#x3D; &lt;const&gt;[10, 20];&#x2F;&#x2F; Type &#39;&#123; readonly text: &quot;hello&quot; &#125;&#39;let z &#x3D; &lt;const&gt;&#123; text: &quot;hello&quot; &#125;;</code></pre><p>This feature often means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Works with no types referenced or declared.&#x2F;&#x2F; We only needed a single const assertion.function getShapes() &#123;    let result &#x3D; [        &#123; kind: &quot;circle&quot;, radius: 100, &#125;,        &#123; kind: &quot;square&quot;, sideLength: 50, &#125;,    ] as const;        return result;&#125;for (const shape of getShapes()) &#123;    &#x2F;&#x2F; Narrows perfectly!    if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;        console.log(&quot;Circle radius&quot;, shape.radius);    &#125;    else &#123;        console.log(&quot;Square side length&quot;, shape.sideLength);    &#125;&#125;</code></pre><p>注意上面无需类型声明，const 断言允许 ts 使用最精确的表达式类型。</p><h5 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h5><p>需要注意的是，const 断言只能使用在简单的字面表达式：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Error!&#x2F;&#x2F;   A &#39;const&#39; assertion can only be applied to a string, number, boolean, array, or object literal.let a &#x3D; (Math.random() &lt; 0.5 ? 0 : 1) as const;&#x2F;&#x2F; Works!let b &#x3D; Math.random() &lt; 0.5 ?    0 as const :    1 as const;</code></pre><p>另外需要注意的是，const 不会将表达式转变为完全不可变：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">et arr &#x3D; [1, 2, 3, 4];let foo &#x3D; &#123;    name: &quot;foo&quot;,    contents: arr,&#125;;foo.name &#x3D; &quot;bar&quot;;   &#x2F;&#x2F; error!foo.contents &#x3D; [];  &#x2F;&#x2F; error!foo.contents.push(5); &#x2F;&#x2F; ...works!</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不变的承诺 Promise</title>
      <link href="/2020/08/25/%E4%B8%8D%E5%8F%98%E7%9A%84%E6%89%BF%E8%AF%BA%20Promise/"/>
      <url>/2020/08/25/%E4%B8%8D%E5%8F%98%E7%9A%84%E6%89%BF%E8%AF%BA%20Promise/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Promise 是异步编程的一种解决方案，可以解决前端的回调地狱。以下根据 <a href="https://es6.ruanyifeng.com/?search=promise&x=0&y=0#docs/promise">ES6 入门</a> 简单过一下 Promise 的基础及个人的一些见解补充，同时尝试实现一个符合 PromiseA+ 规范的 Promise。</p> <a id="more"></a><h4 id="Promise-基础"><a href="#Promise-基础" class="headerlink" title="Promise 基础"></a>Promise 基础</h4><h5 id="Promise-的状态"><a href="#Promise-的状态" class="headerlink" title="Promise 的状态"></a>Promise 的状态</h5><p>Promise 只有三种状态：<code>pending</code>（进行中），<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。</p><p>Promise 的状态改变只有两种情况：</p><p><code>pending</code> 到 <code>fulfilled</code> 以及 <code>pending</code> 到 <code>rejected</code>。当状态变成  <code>fulfilled</code> 或 <code>rejected</code>时，我们就称这个 Promise  <code>resolved</code>。</p><p>⚠️ 我们通常说的 resolved 仅指代 <code>fulfilled</code>，不包括 <code>rejected</code>。</p><h5 id="构造一个-Promise"><a href="#构造一个-Promise" class="headerlink" title="构造一个 Promise"></a>构造一个 Promise</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const promise &#x3D; new Promise(function(resolve, reject) &#123;  &#x2F;&#x2F; ... some code  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;    resolve(value);  &#125; else &#123;    reject(error);  &#125;&#125;);</code></pre><h5 id="promise-then"><a href="#promise-then" class="headerlink" title="promise.then"></a>promise.then</h5><p>Promise 的实例拥有 then 方法：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">promise.then(function(value) &#123;  &#x2F;&#x2F; success&#125;, function(error) &#123;  &#x2F;&#x2F; failure&#125;);</code></pre><p>⚠️  Promise 新建后立即执行，而 then 方法则属于微任务的回调，执行时机为宏任务执行之后，具体的事件循环机制后面开新坑总结。</p><h5 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h5><p>构造 Promise 时，第一个参数 resolve 函数所接收的参数，可以是一个普通的值，也可以是一个 promise。如果接收的是一个 promise 实例，那么 promise 的状态取决于 resolve 接收的 promise 的状态：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const p1 &#x3D; new Promise(function (resolve, reject) &#123;  setTimeout(() &#x3D;&gt; reject(new Error(&#39;fail&#39;)), 3000)&#125;)const p2 &#x3D; new Promise(function (resolve, reject) &#123;  setTimeout(() &#x3D;&gt; resolve(p1), 1000)&#125;)p2  .then(result &#x3D;&gt; console.log(result))  .catch(error &#x3D;&gt; console.log(error))&#x2F;&#x2F; 3s 后输出：Error: fail</code></pre><p>这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><h5 id="resolve-与-return"><a href="#resolve-与-return" class="headerlink" title="resolve 与 return"></a>resolve 与 return</h5><p>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">new Promise((resolve, reject) &#x3D;&gt; &#123;  resolve(1);  console.log(2);&#125;).then(r &#x3D;&gt; &#123;  console.log(r);&#125;);&#x2F;&#x2F; 2&#x2F;&#x2F; 1</code></pre><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">new Promise((resolve, reject) &#x3D;&gt; &#123;  return resolve(1);  &#x2F;&#x2F; 后面的语句不会执行  console.log(2);&#125;)</code></pre><h5 id="catch"><a href="#catch" class="headerlink" title=".catch"></a>.catch</h5><ol><li><p><code>Promise.prototype.catch()</code>方法是<code>.then(null | undefined, rejection)</code>，用于指定发生错误时的回调函数。</p></li><li><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止，即错误总是会被下一个<code>catch</code>语句捕获。</p></li><li><p><code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>与 <code>catch()</code> 方法。</p></li><li><p>promise 内部的错误不会抛到外层，因此 <code>try/catch</code> 无法捕获：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">try &#123;   const p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;        throw &#39;err&#39;    &#125;)    console.log(&#39;out&#39;)&#125; catch(e) &#123;    console.log(&#39;catch you&#39;, e)&#125;&#x2F;&#x2F; out&#x2F;&#x2F; 未捕获的异常：Uncaught (in promise) err</code></pre><p>因此最好 promise 后都用 catch 来捕获。</p></li></ol><h5 id="finally"><a href="#finally" class="headerlink" title=".finally()"></a>.finally()</h5><ul><li>ES2018 引入，即不管 Promise 对象最后状态如何，都会执行的操作。</li><li><code>finally</code>方法的回调函数不接受任何参数</li></ul><h4 id="手写一个简易的-Promise"><a href="#手写一个简易的-Promise" class="headerlink" title="手写一个简易的 Promise"></a>手写一个简易的 Promise</h4><p>手写一个符合 PromiseA+ 规范的 Promise 并不简单，可以先简单根据上述 promise 的基本功能实现一个<strong>简易版本</strong>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const PENDING &#x3D; &#39;pending&#39;const RESOLVED &#x3D; &#39;resolved&#39;const REJECTED &#x3D; &#39;rejected&#39;class MyPromise &#123;  constructor(fn) &#123;    this.state &#x3D; PENDING    &#x2F;&#x2F; 收集 .then 中的 resolve 的回调函数    this.resolveCallbacks &#x3D; []    &#x2F;&#x2F; 收集 .then 中的 reject 的回调函数    this.rejectCallbacks &#x3D; []    &#x2F;&#x2F; resolve(result)    this.result &#x3D; null    &#x2F;&#x2F; reject(reason)    this.reason &#x3D; null    &#x2F;&#x2F; 由于 fn 有可能异常，需要捕获    try &#123;      &#x2F;&#x2F; Promise 一实例化就执行传入的 fn      &#x2F;&#x2F; 注意此处将函数当作参数传入，需要 bind 绑定上下文      &#x2F;&#x2F; 或者 resolve &#x2F; reject 用箭头函数实现      fn(this.resolve.bind(this), this.reject.bind(this))    &#125; catch (error) &#123;      this.reject(error)    &#125;  &#125;  resolve(result) &#123;    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      &#x2F;&#x2F; 修改状态      this.state &#x3D; RESOLVED      this.result &#x3D; result      &#x2F;&#x2F; 执行 then 中的 resolve 回调函数      this.resolveCallbacks.forEach((cb) &#x3D;&gt; cb(result))    &#125;  &#125;  reject(reason) &#123;    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      &#x2F;&#x2F; 修改状态      this.state &#x3D; REJECTED      this.reason &#x3D; reason      &#x2F;&#x2F; 执行 then 中的 reject 回调函数      this.rejectCallbacks.forEach((cb) &#x3D;&gt; cb(reason))    &#125;  &#125;  then(onFulfilled, onRejected) &#123;    &#x2F;&#x2F; 调用 .then 时如果还在 pending 则将回调先存起来，等待 resolve 后执行    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      &#x2F;&#x2F; 收集回调      this.resolveCallbacks.push(onFulfilled)      this.rejectCallbacks.push(onRejected)    &#125;    &#x2F;&#x2F; 如果调用 .then 时已经 resolve &#x2F; reject, 那么直接执行对应的回调    if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;      onFulfilled(this.result)    &#125;    if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;      onRejected(this.reason)    &#125;  &#125;&#125;</code></pre><p>测试代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const myPromise &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;  setTimeout(() &#x3D;&gt; &#123;    resolve(&#39;resolved&#39;)  &#125;, 3000)&#125;)myPromise.then(  (result) &#x3D;&gt; &#123;    console.log(result)  &#125;,  (reason) &#x3D;&gt; &#123;    console.log(reason)  &#125;)</code></pre><p>Promise 的设计思路实际上就是观察者模式：收集回调函数，触发通知，依次执行回调。</p><p>上述版本还未能达到 Promise / A+ 的规范，比如 链式调用 等。</p><h4 id="符合-Promise-A-的-Promise"><a href="#符合-Promise-A-的-Promise" class="headerlink" title="符合 Promise / A+ 的 Promise"></a>符合 Promise / A+ 的 Promise</h4><p>参考 <a href="https://promisesaplus.com/">Promise / A+</a> ，以下还需要补充下面几点：</p><ol><li>then 方法的参数可选</li><li><code>onFulfilled</code> 和 <code>onRejected</code>是异步执行的，可以使用如 <code>setTimeout</code> 或 <code>setImmediate</code> 之类的“宏任务”机制，或者使用诸如 <code>MutationObserver</code> 或 <code>process.nextTick</code> 之类的“微任务”机制来实现。</li><li>链式调用 与 promise 解决步骤</li></ol><h5 id="值穿透"><a href="#值穿透" class="headerlink" title="值穿透"></a>值穿透</h5><p>针对 then 的参数可选这一点，如果 <code>onFulfilled</code>  和 <code>onRejectd</code> 不是函数，则会被忽略，并且将值传递给下一个 then。即所谓的值穿透，对 <code>then</code> 进行改造:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">then(onFulfilled, onRejected) &#123;  &#x2F;&#x2F; 如果不是函数，传递 result    onFulfilled &#x3D;      typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : (result) &#x3D;&gt; result  &#x2F;&#x2F; 如果不是函数，抛出 reason    onRejected &#x3D;      typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39;        ? onRejected        : (reason) &#x3D;&gt; &#123;            throw reason          &#125;  &#x2F;&#x2F; ... if (this.state &#x3D;&#x3D;&#x3D; PENDING) ... &#125;</code></pre><p>当然当前的简易版 promise 还不支持链式调用，值穿透也就无从谈起。</p><h5 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h5><p>在实现链式调用之前，我们完善代码，使得<code>onFulfilled</code> 和 <code>onRejected</code>是异步执行的。</p><p>当前执行以下代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var myPromise &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;  resolve(1)&#125;)myPromise.then(  (val) &#x3D;&gt; &#123;    console.log(val)  &#125;,  (val) &#x3D;&gt; &#123;    console.log(val)  &#125;)console.log(2)</code></pre><p>现输出 1 再输出 2，显然不是异步的。根据 Promise/ A+ 的规范，这里我们可以通过 setTimeout 来改造 resolve 和 reject ：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; ...resolve(result) &#123;  &#x2F;&#x2F; 通过 setTimeout 模拟异步  setTimeout(() &#x3D;&gt; &#123;    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      &#x2F;&#x2F; ...    &#125;  &#125;)&#125;reject(reason) &#123;    &#x2F;&#x2F; 通过 setTimeout 模拟异步  setTimeout(() &#x3D;&gt; &#123;    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;       &#x2F;&#x2F; ...    &#125;  &#125;)&#125;&#x2F;&#x2F; ...</code></pre><p>至此，输出顺序将是 2, 1。 符合预期</p><h5 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h5><p>现在来实现链式调用：</p><ol><li><code>then</code> 需要返回一个 Promise</li><li><code>then</code> 拿到上一次 then 的返回值</li><li>如果 then 返回的是一个 Promise 则需要等待该 promise 状态发生变化后再执行下一个 then</li></ol><p>promise2: 我们将 then 返回的 promise 命名为 promise2, 即 <code>promise2 = promise1.then(onFulfilled, onRejected);</code></p><p>x: 将 onFulfilled 或者 onRejected 的返回值命名为 x，这个 x 可以是一个 thenable。</p><p>resolutionProcedure: promise 解决步骤。如果 <code>x</code> 具有 thenable 特性，我们就假设 <code>x</code> 的行为至少有点像 promise，它将试图使 promise 接收 <code>x</code> 的状态。否则，它使用值 <code>x</code> 执行 <code>promise</code>。之所以是 thenable 是为了可以兼容别的 promise（例如 fetch）。实际上这个方法在 Promise / A+ 中有很多情况分叉，我们先简化成以下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更, 否则直接resolvex instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</code></pre><p>现在的 Promise 完整代码如下，<strong>接近完全体版本</strong>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const PENDING &#x3D; &#39;pending&#39;const RESOLVED &#x3D; &#39;resolved&#39;const REJECTED &#x3D; &#39;rejected&#39;class MyPromise &#123;  constructor(fn) &#123;    this.state &#x3D; PENDING    &#x2F;&#x2F; 收集 .then 中的 resolve 的回调函数    this.resolveCallbacks &#x3D; []    &#x2F;&#x2F; 收集 .then 中的 reject 的回调函数    this.rejectCallbacks &#x3D; []    &#x2F;&#x2F; resolve(result)    this.result &#x3D; null    &#x2F;&#x2F; reject(reason)    this.reason &#x3D; null    &#x2F;&#x2F; 由于 fn 有可能异常，需要捕获    try &#123;      &#x2F;&#x2F; Promise 一实例化就执行传入的 fn      &#x2F;&#x2F; 注意此处将函数当作参数传入，需要 bind 绑定上下文      &#x2F;&#x2F; 或者 resolve &#x2F; reject 用箭头函数实现      fn(this.resolve.bind(this), this.reject.bind(this))    &#125; catch (error) &#123;      this.reject(error)    &#125;  &#125;  resolve(result) &#123;    setTimeout(() &#x3D;&gt; &#123;      if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;        &#x2F;&#x2F; 修改状态        this.state &#x3D; RESOLVED        this.result &#x3D; result        &#x2F;&#x2F; 执行 then 中的 resolve 回调函数        this.resolveCallbacks.forEach((cb) &#x3D;&gt; cb(result))      &#125;    &#125;)  &#125;  reject(reason) &#123;    setTimeout(() &#x3D;&gt; &#123;      if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;        &#x2F;&#x2F; 修改状态        this.state &#x3D; REJECTED        this.reason &#x3D; reason        &#x2F;&#x2F; 执行 then 中的 reject 回调函数        this.rejectCallbacks.forEach((cb) &#x3D;&gt; cb(reason))      &#125;    &#125;)  &#125;  then(onFulfilled, onRejected) &#123;    &#x2F;&#x2F; 如果不是函数，传递 result    onFulfilled &#x3D;      typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : (result) &#x3D;&gt; result    &#x2F;&#x2F; 如果不是函数，抛出 reason    onRejected &#x3D;      typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39;        ? onRejected        : (reason) &#x3D;&gt; &#123;            throw reason          &#125;    &#x2F;&#x2F; 调用 .then 时如果还在 pending 则将回调先存起来，等待 resolve 后执行    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      const promise2 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;        const resolvedCallBack &#x3D; () &#x3D;&gt; &#123;          try &#123;            const x &#x3D; onFulfilled(this.result)            &#x2F;&#x2F; 简化逻辑的 resolutionProcedure            x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)            &#x2F;&#x2F; resolutionProcedure(promise2, x, resolve, reject)          &#125; catch (error) &#123;            reject(error)          &#125;        &#125;        const rejectCallBack &#x3D; () &#x3D;&gt; &#123;          try &#123;            const x &#x3D; onRejected(this.result)            &#x2F;&#x2F; 简化逻辑的 resolutionProcedure            x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)            &#x2F;&#x2F; resolutionProcedure(promise2, x, resolve, reject)          &#125; catch (error) &#123;            reject(error)          &#125;        &#125;        &#x2F;&#x2F; 收集回调        this.resolveCallbacks.push(resolvedCallBack)        this.rejectCallbacks.push(onRejected)      &#125;)      return promise2    &#125;    &#x2F;&#x2F; 如果调用 .then 时已经 resolve &#x2F; reject, 那么直接执行对应的回调    if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;      onFulfilled(this.result)    &#125;    if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;      onRejected(this.reason)    &#125;  &#125;&#125;</code></pre><h5 id="resolutionProcedure"><a href="#resolutionProcedure" class="headerlink" title="resolutionProcedure"></a>resolutionProcedure</h5><p>最后根据 Promise / A+ 的规范来完善 resolutionProcedure，实际上就是一系列的判断：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const resolutionProcedure &#x3D; (promise2, x, resolve, reject) &#x3D;&gt; &#123;  if (promise2 &#x3D;&#x3D;&#x3D; x) &#123;    return reject(new TypeError(&#39;Error&#39;))  &#125;  if (x instanceof MyPromise) &#123;    x.then(function(value) &#123;        resolutionProcedure(promise2, value, resolve, reject)    &#125;, reject)&#125;  let called &#x3D; false  if (x !&#x3D;&#x3D; null &amp;&amp; (typeof x &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof x &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;    try &#123;      let then &#x3D; x.then      if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;        then.call(          x,          y &#x3D;&gt; &#123;            if (called) return            called &#x3D; true            resolutionProcedure(promise2, y, resolve, reject)          &#125;,          e &#x3D;&gt; &#123;            if (called) return            called &#x3D; true            reject(e)          &#125;        )      &#125; else &#123;        resolve(x)      &#125;    &#125; catch (e) &#123;      if (called) return      called &#x3D; true      reject(e)    &#125;  &#125; else &#123;    resolve(x)  &#125;&#125;</code></pre><h4 id="符合-Promise-A-的-Promise-1"><a href="#符合-Promise-A-的-Promise-1" class="headerlink" title="符合 Promise / A+ 的 Promise"></a>符合 Promise / A+ 的 Promise</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const PENDING &#x3D; &#39;pending&#39;const RESOLVED &#x3D; &#39;resolved&#39;const REJECTED &#x3D; &#39;rejected&#39;const resolutionProcedure &#x3D; (promise2, x, resolve, reject) &#x3D;&gt; &#123;  if (promise2 &#x3D;&#x3D;&#x3D; x) &#123;    return reject(new TypeError(&#39;Error&#39;))  &#125;  if (x instanceof MyPromise) &#123;    x.then(function (value) &#123;      resolutionProcedure(promise2, value, resolve, reject)    &#125;, reject)  &#125;  let called &#x3D; false  if (x !&#x3D;&#x3D; null &amp;&amp; (typeof x &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof x &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;    try &#123;      let then &#x3D; x.then      if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;        then.call(          x,          (y) &#x3D;&gt; &#123;            if (called) return            called &#x3D; true            resolutionProcedure(promise2, y, resolve, reject)          &#125;,          (e) &#x3D;&gt; &#123;            if (called) return            called &#x3D; true            reject(e)          &#125;        )      &#125; else &#123;        resolve(x)      &#125;    &#125; catch (e) &#123;      if (called) return      called &#x3D; true      reject(e)    &#125;  &#125; else &#123;    resolve(x)  &#125;&#125;class MyPromise &#123;  constructor(fn) &#123;    this.state &#x3D; PENDING    &#x2F;&#x2F; 收集 .then 中的 resolve 的回调函数    this.resolveCallbacks &#x3D; []    &#x2F;&#x2F; 收集 .then 中的 reject 的回调函数    this.rejectCallbacks &#x3D; []    &#x2F;&#x2F; resolve(result)    this.result &#x3D; null    &#x2F;&#x2F; reject(reason)    this.reason &#x3D; null    &#x2F;&#x2F; 由于 fn 有可能异常，需要捕获    try &#123;      &#x2F;&#x2F; Promise 一实例化就执行传入的 fn      &#x2F;&#x2F; 注意此处将函数当作参数传入，需要 bind 绑定上下文      &#x2F;&#x2F; 或者 resolve &#x2F; reject 用箭头函数实现      fn(this.resolve.bind(this), this.reject.bind(this))    &#125; catch (error) &#123;      this.reject(error)    &#125;  &#125;  resolve(result) &#123;    setTimeout(() &#x3D;&gt; &#123;      if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;        &#x2F;&#x2F; 修改状态        this.state &#x3D; RESOLVED        this.result &#x3D; result        &#x2F;&#x2F; 执行 then 中的 resolve 回调函数        this.resolveCallbacks.forEach((cb) &#x3D;&gt; cb(result))      &#125;    &#125;)  &#125;  reject(reason) &#123;    setTimeout(() &#x3D;&gt; &#123;      if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;        &#x2F;&#x2F; 修改状态        this.state &#x3D; REJECTED        this.reason &#x3D; reason        &#x2F;&#x2F; 执行 then 中的 reject 回调函数        this.rejectCallbacks.forEach((cb) &#x3D;&gt; cb(reason))      &#125;    &#125;)  &#125;  then(onFulfilled, onRejected) &#123;    &#x2F;&#x2F; 如果不是函数，传递 result    onFulfilled &#x3D;      typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : (result) &#x3D;&gt; result    &#x2F;&#x2F; 如果不是函数，抛出 reason    onRejected &#x3D;      typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39;        ? onRejected        : (reason) &#x3D;&gt; &#123;            throw reason          &#125;    &#x2F;&#x2F; 调用 .then 时如果还在 pending 则将回调先存起来，等待 resolve 后执行    if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      const promise2 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;        const resolvedCallBack &#x3D; () &#x3D;&gt; &#123;          try &#123;            const x &#x3D; onFulfilled(this.result)            resolutionProcedure(promise2, x, resolve, reject)          &#125; catch (error) &#123;            reject(error)          &#125;        &#125;        const rejectCallBack &#x3D; () &#x3D;&gt; &#123;          try &#123;            const x &#x3D; onRejected(this.result)            resolutionProcedure(promise2, x, resolve, reject)          &#125; catch (error) &#123;            reject(error)          &#125;        &#125;        &#x2F;&#x2F; 收集回调        this.resolveCallbacks.push(resolvedCallBack)        this.rejectCallbacks.push(onRejected)      &#125;)      return promise2    &#125;    &#x2F;&#x2F; 如果调用 .then 时已经 resolve &#x2F; reject, 那么直接执行对应的回调    if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;      onFulfilled(this.result)    &#125;    if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;      onRejected(this.reason)    &#125;  &#125;&#125;</code></pre><p>至此我们完成了一个 符合 Promise / A+ 的 Promise，实际上 Promise 还会提供一些如 <code>.all</code>, <code>.race</code> 之类的 api，这里也实现一下。</p><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>Promise.all 接收多个 Promise 实例，返回一个新的 Promise 实例。例如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const p &#x3D; Promise.all([p1, p2, p3])</code></pre><p>上述的 p1, p2, p3 都是 Promise 实例，如果不是则会用 Promise.resolve 转成 promise。此外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><p>实现如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class MyPromise &#123;  &#x2F;&#x2F; ...  all(arr) &#123;    &#x2F;&#x2F; 用于存储返回值    let list &#x3D; []    &#x2F;&#x2F; 记录 resolve 了多少个 promise    let length &#x3D; 0    &#x2F;&#x2F; 执行 promise 的过程中是否有异常    let hasError &#x3D; false    &#x2F;&#x2F; 返回一个新的 Promise    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;      for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;        &#x2F;&#x2F; 判断元素是否为 MyPromise， 否则 resolve        const p &#x3D;          arr[i] instanceof MyPromise ? arr[i] : MyPromise.resolve(arr[i])        p.then((data) &#x3D;&gt; &#123;          list[i] &#x3D; data          length++          if (length &#x3D;&#x3D;&#x3D; arr.length) &#123;            &#x2F;&#x2F; 如果全部 promise 都 resolved            resolve(list)          &#125;        &#125;).catch((error) &#x3D;&gt; &#123;          if (!hasError) &#123;            &#x2F;&#x2F; 第一个被 reject 的实例的返回值，会传递给 p 的回调函数            reject(error)          &#125;          hasErr &#x3D; true        &#125;)      &#125;    &#125;)  &#125;  &#x2F;&#x2F; ...&#125;</code></pre><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>Promise.race()`方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const p &#x3D; Promise.race([p1, p2, p3]);</code></pre><p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class MyPromise &#123;  &#x2F;&#x2F; ...  race(arr) &#123;    &#x2F;&#x2F; 是否有结果    let hasResult &#x3D; false    &#x2F;&#x2F; 返回一个新的 Promise    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;      for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;        &#x2F;&#x2F; 判断元素是否为 MyPromise， 否则 resolve        const p &#x3D;          arr[i] instanceof MyPromise ? arr[i] : MyPromise.resolve(arr[i])        p.then((data) &#x3D;&gt; &#123;          if (!hasResult) &#123;            resolve(data)          &#125;          hasResult &#x3D; true        &#125;).catch((error) &#x3D;&gt; &#123;          if (!hasResult) &#123;            reject(error)          &#125;          hasResult &#x3D; true        &#125;)      &#125;    &#125;)  &#125;  &#x2F;&#x2F; ...&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svg 图片的上传下载</title>
      <link href="/2020/08/17/svg%20%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2020/08/17/svg%20%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近有个需求：</p><ol><li>根据传入的 code 生成条形码 svg 图片</li><li>将 svg 图片上传至 cdn</li><li>展示图片时需要点击按钮后保存至本地</li></ol><a id="more"></a><h4 id="生成条形码"><a href="#生成条形码" class="headerlink" title="生成条形码"></a>生成条形码</h4><p>这里借助一个开源的仓库</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import JsBarcode from &#39;jsbarcode&#39;;const generateBarcode &#x3D; async (barcode, options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;  &#x2F;&#x2F; 创建一个 svg 元素  const svg &#x3D; document.createElementNS(&#39;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&#39;, &#39;svg&#39;);  &#x2F;&#x2F; 甚至宽高  svg.setAttribute(&#39;width&#39;, &#96;$&#123;width&#125;px&#96;);  svg.setAttribute(&#39;height&#39;, &#96;$&#123;height&#125;px&#96;);  &#x2F;&#x2F; 生成条形码 svg 的图片  JsBarcode(svg, barcode, options);  return svg&#125;</code></pre><h4 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h4><h5 id="svg-转-canvas"><a href="#svg-转-canvas" class="headerlink" title="svg 转 canvas"></a>svg 转 canvas</h5><p>由于服务端同学提供的接口只支持 canvas，因此首先要将 svg 转成 canvas：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const svgToCanvas &#x3D; (svg) &#x3D;&gt; &#123;  &#x2F;&#x2F; svg.outerHTML 获取 svg 元素的 html 字符串  &#x2F;&#x2F; btoa 将 svg 转成 base64const href &#x3D; &#96;data:image&#x2F;svg+xml;base64,$&#123;window.btoa(    unescape(encodeURIComponent(svg.outerHTML)),  )&#125;&#96;;  &#x2F;&#x2F; 构建一个 Image  const img &#x3D; new Image();  img.width &#x3D; width;  img.height &#x3D; height;    img.onload &#x3D; () &#x3D;&gt; &#123;    &#x2F;&#x2F; 构建一个 canvas    const canvas &#x3D; document.createElement(&#39;canvas&#39;);    const ctx &#x3D; canvas.getContext(&#39;2d&#39;);    ctx.fillRect(0, 0, width, height);    &#x2F;&#x2F; 将 图片画到 canvas 中    ctx.drawImage(img, 0, 0, width, height);    &#x2F;&#x2F; 转成 jpeg 的 base64 const dataURI &#x3D; canvas.toDataURL(&#39;image&#x2F;jpeg&#39;);    &#x2F;&#x2F; 上传    upload(dataURI);  &#125;   img.src &#x3D; href;&#125;</code></pre><h5 id="Data-URL"><a href="#Data-URL" class="headerlink" title="Data URL"></a>Data URL</h5><p>通过 `canvas.toDataURL 将 canvas 转成 Data URL，一段 Data URL 由 4 个部分组成：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;&#x2F;&#x2F; 例如： &quot;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC&quot;</code></pre><h5 id="Base64的解码与编码"><a href="#Base64的解码与编码" class="headerlink" title="Base64的解码与编码"></a>Base64的解码与编码</h5><p><code>atob()</code> 函数能够解码通过base-64编码的字符串数据。</p><p><code>btoa()</code> 函数能够从二进制数据“字符串”创建一个base-64编码的ASCII字符串。</p><h5 id="Base64-转-Blob"><a href="#Base64-转-Blob" class="headerlink" title="Base64 转 Blob"></a>Base64 转 Blob</h5><p>上传图片文件需要将 base64 转成 Blob 对象，有两种方法：</p><p>######Base64 转 Blob 第一种方法：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function dataURItoBlob(dataURI: string) &#123;  &#x2F;&#x2F; 通过 atob 转回 string  const byteString &#x3D; atob(dataURI.split(&#39;,&#39;)[1]);  &#x2F;&#x2F; 获得文件类型  const mimeString &#x3D; dataURI.split(&#39;,&#39;)[0].split(&#39;:&#39;)[1].split(&#39;;&#39;)[0];  &#x2F;&#x2F; 转成   const ab &#x3D; new ArrayBuffer(byteString.length);  const ia &#x3D; new Uint8Array(ab);  for (let i &#x3D; 0; i &lt; byteString.length; i++) &#123;    ia[i] &#x3D; byteString.charCodeAt(i);  &#125;&#x2F;&#x2F; 转成 blob  const bb &#x3D; new Blob([ab], &#123; type: mimeString &#125;);  return bb;&#125;</code></pre><p> 思路：</p><ol><li>拆解 data uri，通过 atob 将 base64 解码成字符串</li><li>拆解 data uri，获得图片的格式</li><li>创建一个 arraybuffer</li><li>通过TypedArray（这里使用 Uint8Array）将字符串的内容写入 arraybuffer </li><li>将 array buffer 转成 blob</li></ol><h6 id="Base64-转-Blob-第二种方法："><a href="#Base64-转-Blob-第二种方法：" class="headerlink" title="Base64 转 Blob 第二种方法："></a>Base64 转 Blob 第二种方法：</h6><p>通过 <code>fetch</code> 将 dataURI 转成 blob：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const bb &#x3D; await fetch(dataURI).then((res) &#x3D;&gt; res.blob())</code></pre><h5 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h5><p>构造 FormData 上传图片文件：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const upload &#x3D; (dataURI: string) &#x3D;&gt; &#123;  &#x2F;&#x2F; 创建form对象const formData &#x3D; new FormData();  &#x2F;&#x2F; 通过 append 向 form 对象添加数据  formData.append(&#39;file&#39;, dataURItoBlob(dataURI));  const &#123; data &#125; &#x3D; await axios.post(&#39;&#x2F;api&#x2F;upload&#39;, formData, &#123;    headers: &#123;      &#39;Content-Type&#39;: &#39;multipart&#x2F;form-data&#39;,      &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;,    &#125;,  &#125;);&#125;</code></pre><h5 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h5><p>保存图片到本地：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const download &#x3D; (fileUrl, name) &#x3D;&gt; &#123;  const x &#x3D; new XMLHttpRequest();  x.open(&#39;GET&#39;, fileUrl, true);  x.responseType &#x3D; &#39;blob&#39;;  x.onload &#x3D; () &#x3D;&gt; &#123;    &#x2F;&#x2F; 转为 objectUrl    const url &#x3D; window.URL.createObjectURL(x.response);    &#x2F;&#x2F; 构建一个 a 标签    const a &#x3D; document.createElement(&#39;a&#39;);    a.href &#x3D; url;    a.download &#x3D; name;    a.click();  &#125;;  x.send();&#125;;</code></pre><p>利用 a 标签的 download 属性可以实现图片的下载，但是有个限制是 href 必须是同源的地址，否则无法下载。</p><p>因此这里通过 get 请求获得图片的 Blob 格式，并用 window.URL.createObjectURL 将 Blob 转成 objectUrl 解决了跨域问题。之后就可以用 a 标签的 download 属性下载文件。</p><h4 id="补充几个概念"><a href="#补充几个概念" class="headerlink" title="补充几个概念"></a>补充几个概念</h4><h5 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h5><p>上传图片时，我们实现了一个函数 dataURItoBlob， 通过这个函数来将 base64 转为 Blob，最终上传给接口的 formData 中的 file 也是一个 Blob 对象。</p><p>什么是 Blob 对象？</p><blockquote><p>一个 <strong>Blob</strong>对象表示一个不可变的, 原始数据的类似文件对象。Blob 表示的不一定是JavaScript原生格式的数据。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File"><code>File</code></a> 接口基于<code>Blob</code>，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p></blockquote><p>Blob 属于 web 提供的 api，因此 mdn 上说的 Blob 表示的不一定是JavaScript原生格式的数据。</p><h5 id="File"><a href="#File" class="headerlink" title="File"></a>File</h5><p>File 继承自 Blob，可以看作是特殊的 Blob。常见的获得 File 对象的方法有 <code>input</code> 标签上选择文件后返回的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileList"><code>FileList</code></a> 对象。</p><h5 id="Blob-转-URL"><a href="#Blob-转-URL" class="headerlink" title="Blob 转 URL"></a>Blob 转 URL</h5><p>在下载时，我们通过 get 请求获得了图片的 blob 格式，之后通过 URL.createObjectURL 转成 objectUrl，这样就可以像普通的 url，赋值给 img 的 src 属性或者 a 标签的 href 属性。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码层面解读Vue响应式原理</title>
      <link href="/2020/08/11/%E6%BA%90%E7%A0%81%E5%B1%82%E9%9D%A2%E8%A7%A3%E8%AF%BBVue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2020/08/11/%E6%BA%90%E7%A0%81%E5%B1%82%E9%9D%A2%E8%A7%A3%E8%AF%BBVue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在 Vue（以下均指的是 2.x 版本） 中，数据模型仅仅是普通的 JavaScript 对象，当你修改它们时，视图会进行更新，这就是 Vue 的响应式系统，其设计模式就是观察者模式。</p><a id="more"></a><h4 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h4><p>以下为阅读源码时，对响应式实现原理的理解，为了思路更清晰，仅考虑最简单的情况，并且可能会省略或修改部分代码。</p><p>首先，顺着 vue 的生命周期开始：</p><h5 id="beforeCreate-与-created"><a href="#beforeCreate-与-created" class="headerlink" title="beforeCreate 与 created"></a>beforeCreate 与 created</h5><p>首先 在 _init 方法中执行 beforeCreate 与 created ：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Vue.prototype._init &#x3D; function (options?: Object) &#123;  &#x2F;&#x2F; ...  callHook(vm, &#39;beforeCreate&#39;)  &#x2F;&#x2F; ...  initState(vm)  &#x2F;&#x2F; ...  callHook(vm, &#39;created&#39;)  &#x2F;&#x2F; ...&#125;</code></pre><p>记住这里执行了一个方法： <code>initState</code></p><p>#####initState</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export function initState (vm: Component) &#123;&#x2F;&#x2F; 略：...初始化 props，methods 等  if (opts.data) &#123;    initData(vm)  &#125; else &#123;    observe(vm._data &#x3D; &#123;&#125;, true &#x2F;* asRootData *&#x2F;)  &#125;  &#x2F;&#x2F; 略：...初始化 computed，watch 等&#125;</code></pre><p>这里的 initData 代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function initData (vm: Component) &#123;  &#x2F;&#x2F; 略：...将 data 的每个属性都挂在 vm 上,这样可以通过 this.xx 直接访问到  &#x2F;&#x2F; observe data  observe(data, true &#x2F;* asRootData *&#x2F;)&#125;</code></pre><p>记住 <code>observe</code> 这个方法。</p><h5 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h5><p><code>observe</code>  用于创建一个 observer 实例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;  let ob: Observer | void  &#x2F;&#x2F; 判断是否已经 observe 过，是的话直接返回  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) &#123;    &#x2F;&#x2F; observer 最终会挂在 value 的 __ob__ 属性上，因此可以这么判断是否  observe 过，详情看 Observer 的代码    ob &#x3D; value.__ob__  &#125; else if (...) &#123;    &#x2F;&#x2F; 否则满足一系列条件的情况下就会重新实例化一个 observer    ob &#x3D; new Observer(value)  &#125;  return ob&#125;</code></pre><p>实例化  observer 的过程中实际上会将传入对象的每个属性通过 <code>defineReactive</code> 方法转成响应式：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export class Observer &#123;  constructor (value: any) &#123;    this.value &#x3D; value    &#x2F;&#x2F; 初始化数据模型的 dep 实例    this.dep &#x3D; new Dep()    &#x2F;&#x2F; observer 最终会挂在 value 的 __ob__ 属性上    def(value, &#39;__ob__&#39;, this)    if (Array.isArray(value)) &#123;      &#x2F;&#x2F; 略：...重写 value 的一些数组方法      &#x2F;&#x2F; 略：...遍历数组元素并 observe    &#125; else &#123;      this.walk(value)    &#125;  &#125;    walk (obj: Object) &#123;    const keys &#x3D; Object.keys(obj)    for (let i &#x3D; 0; i &lt; keys.length; i++) &#123;       &#x2F;&#x2F; 遍历传入的每个属性，并用 defineReactive 转成响应式      defineReactive(obj, keys[i])    &#125;  &#125;&#125;</code></pre><h5 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h5><p>上面代码中最核心的一个函数是 <code>defineReactive</code>，做了以下几件事情：</p><ol><li>初始化目标属性的 dep 实例，这实际上是一个发布者</li><li>对该属性的子对象递归调用 observe</li><li>通过<code>Object.defineProperty</code>劫持该属性的 getter 与 setter：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export function defineReactive (  obj: Object,  key: string,  val: any,) &#123;  &#x2F;&#x2F; 初始化目标属性的 dep 实例  const dep &#x3D; new Dep()&#x2F;&#x2F; 略：... 一些容错判断  &#x2F;&#x2F; 略：... 一些初始化    &#x2F;&#x2F; 递归 observe  let childOb &#x3D; !shallow &amp;&amp; observe(val)  &#x2F;&#x2F; 劫持 get 与 set  Object.defineProperty(obj, key, &#123;    enumerable: true,    configurable: true,    get: function reactiveGetter () &#123;      &#x2F;&#x2F; ...一旦获取该属性就会进行依赖收集    &#125;,    set: function reactiveSetter (newVal) &#123;      &#x2F;&#x2F; ...一旦设置了新值就会派发更新    &#125;  &#125;)&#125;</code></pre><p>这里就用到了观察者模式：当这个属性更新时，会通过发布者通知到观察者，这些观察者收到通知后更新视图。这里发布者实际上是<code>Dep</code> 实例，观察者实际上是 <code>Watcher</code> 实例，它的 <code>update</code> 方法可以更新视图。</p><p>所以，依赖收集实际上就是将<code>Wathcer</code> 实例添加到 <code>Dep</code> 实例的观察者列表。</p><p>reactiveGetter 和 reactiveSetter 这两个方法的具体实现我们先放一边，这里只需要知道大概的作用即可，后面会详细介绍。我们现在来看看什么时候会触发 get 呢？答案是在挂载组件的时候。</p><h5 id="beforeMount-与-mounted"><a href="#beforeMount-与-mounted" class="headerlink" title="beforeMount 与 mounted"></a>beforeMount 与 mounted</h5><p>然后是在 mountComponent 中执行  beforeMount 以及 mounted：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export function mountComponent (  vm: Component,  el: ?Element,  hydrating?: boolean): Component &#123;  &#x2F;&#x2F; ...  callHook(vm, &#39;beforeMount&#39;)  &#x2F;&#x2F; 略：...这里有个非生产环境的判断，这里不考虑简化成如下：  let updateComponent &#x3D; () &#x3D;&gt; &#123;      vm._update(vm._render(), hydrating)   &#125;  &#x2F;&#x2F; 这里实例化 Watcher：可以看作是更新视图用的观察者，这里省略一些参数  new Watcher(vm, updateComponent)  &#x2F;&#x2F; ...仅考虑 new Vue 的情况，代码简化如下  callHook(vm, &#39;mounted&#39;)  return vm&#125;</code></pre><p>挂载组件的时候就会实例化一个 <code>Watcher</code></p><h5 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h5><p>当我们实例化 Watcher 的时候：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let uid &#x3D; 0export default class Watcher &#123;  constructor (    vm: Component,    expOrFn: string | Function,  ) &#123;    &#x2F;&#x2F; 略：...一些初始化    this.deps &#x3D; []    this.newDeps &#x3D; []    this.depIds &#x3D; new Set()    this.newDepIds &#x3D; new Set()    &#x2F;&#x2F; 略：...一些初始化    &#x2F;&#x2F; 略：...对 this.getter 的一些初始化    if (this.computed) &#123;      &#x2F;&#x2F; computed 的情况，本文暂不考虑    &#125; else &#123;      &#x2F;&#x2F; 初始化时就会执行 get 方法      this.value &#x3D; this.get()    &#125;  &#125;  get () &#123;    &#x2F;&#x2F; pushTarget 用于将 watcher 实例挂到 Dep 的 target 这个静态属性上    pushTarget(this)    let value    const vm &#x3D; this.vm    try &#123;      &#x2F;&#x2F; 此时的 this.getter 实际上就是 updateComponent      value &#x3D; this.getter.call(vm, vm)    &#125; catch (e) &#123;      &#x2F;&#x2F; 略：...错误处理    &#125; finally &#123;      &#x2F;&#x2F; 略：...递归访问 value，触发它所有子项的 getter      this.cleanupDeps()    &#125;    return value  &#125;  &#x2F;&#x2F; ...&#125;</code></pre><p><code>pushTarget</code> 将 <code>watcher</code> 实例挂到 <code>Dep</code> 的 <code>target</code> 这个静态属性, 用于 <code>Dep</code> 内部可以访问到：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function pushTarget (_target: ?Watcher) &#123;&#x2F;&#x2F; ...  Dep.target &#x3D; _target&#125;</code></pre><p>接着调用 <code>this.getter</code>, 这里的 <code>this.getter</code> 实际上就是 <code>updateComponent</code>:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">vm._update(vm._render(), hydrating)</code></pre><p><code>vm._render()</code> 会生成 VNode，这个过程会访问 vm 上的数据，至此就会触发数据对象的 getter，进行依赖收集。</p><h5 id="思路小结"><a href="#思路小结" class="headerlink" title="思路小结"></a>思路小结</h5><p>至此我们先梳理一下这一整个过程，以免遗忘：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">beforeCreate &#x3D;&gt; initState -&gt; observe -&gt; new Observer  -&gt; defineReactive：实例化 Dep，劫持对象属性 getter 与 setter&#x3D;&gt; created&#x3D;&gt; beforeMount  实例化 Watcher -&gt; 将 watcher 实例绑定到 Dep.target，并触发对象属性的 getter，收集依赖&#x3D;&gt; mounted&#x3D;&gt; 当数据模型变更时，触发 setter，更新视图</code></pre><p>在 defineReactive 中有个关键的步骤是实例化 <code>Dep</code>。</p><h5 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h5><p>上面说过 Dep 实例是一个发布者，其代码其实很简单：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default class Dep &#123;  constructor () &#123;    this.subs &#x3D; []  &#125;    addSub (sub: Watcher) &#123;    this.subs.push(sub)  &#125;  removeSub (sub: Watcher) &#123;    remove(this.subs, sub)  &#125;  depend () &#123;    if (Dep.target) &#123;      &#x2F;&#x2F; 这里将 Dep.target 即 watcher 添加到 subs 里      Dep.target.addDep(this)    &#125;  &#125;  notify () &#123;    &#x2F;&#x2F; 发布通知    const subs &#x3D; this.subs.slice()    for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123;      subs[i].update()    &#125;  &#125;&#125;</code></pre><p>我们最终调用的是 <code>depend</code>方法来添加观察者，即<code>Dep.target.addDep</code>，我们知道此时 Dep.target 实际上就是 watcher 实例。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; ...addDep (dep: Dep) &#123;  const id &#x3D; dep.id  if (!this.newDepIds.has(id)) &#123;    &#x2F;&#x2F; 将发布者 id 添加到 this.newDepIds    this.newDepIds.add(id)    &#x2F;&#x2F; 将发布者 添加到 this.newDeps    this.newDeps.push(dep)    if (!this.depIds.has(id)) &#123;      &#x2F;&#x2F; 如果旧的 发布者id 列表中没有这个发布者 id，那么就添加到发布者的观察者列表中      dep.addSub(this)    &#125;  &#125;&#125;&#x2F;&#x2F; ...</code></pre><p>而在 watcher 中，最终还是调用了传入的 dep 实例的 addSub 来添加到 dep 的观察者列表中。之所以这么设计，其原因是为了能在 watcher 中维护一个自己订阅的发布者列表。</p><p>那么 watcher 中的发布者列表有什么用呢？还记得 Watcher 实例化的最后会调用  <code>this.cleanupDeps()</code> 吗？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cleanupDeps () &#123;  let i &#x3D; this.deps.length  while (i--) &#123;    const dep &#x3D; this.deps[i]    if (!this.newDepIds.has(dep.id)) &#123;      dep.removeSub(this)    &#125;  &#125;  let tmp &#x3D; this.depIds  this.depIds &#x3D; this.newDepIds  this.newDepIds &#x3D; tmp  this.newDepIds.clear()  tmp &#x3D; this.deps  this.deps &#x3D; this.newDeps  this.newDeps &#x3D; tmp  this.newDeps.length &#x3D; 0&#125;</code></pre><p>这个函数实际上的作用是：</p><ol><li><p>如果无需再观察，则从发布者的观察者列表中移除</p></li><li><p>将本次的发布者 id 列表记录在 this.depsIds 中，清空 this.newDepIds</p></li><li><p>将本次的发布者列表记录在 this.deps 中，清空 this.newDeps</p><p>那么具体是如何将对象属性转为响应式的呢，我们看看其具体实现：</p></li></ol><h5 id="reactiveGetter"><a href="#reactiveGetter" class="headerlink" title="reactiveGetter"></a>reactiveGetter</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function reactiveGetter () &#123;  &#x2F;&#x2F; ...  &#x2F;&#x2F; 此时的 Dep.target 就是 watcher，关于 Dep 后面会详细解释  if (Dep.target) &#123;    &#x2F;&#x2F; 这里会将 watcher 实例添加进 dep 的 subs 中维护，即收集依赖    dep.depend()    if (childOb) &#123;      &#x2F;&#x2F; 子对象的依赖收集      childOb.dep.depend()      &#x2F;&#x2F; 略：...对数组的一些处理    &#125;  &#125;  &#x2F;&#x2F; 返回属性值  return value&#125;</code></pre><h5 id="reactiveSetter"><a href="#reactiveSetter" class="headerlink" title="reactiveSetter"></a>reactiveSetter</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function reactiveSetter (newVal) &#123;  &#x2F;&#x2F; value：属性值  const value &#x3D; ...  &#x2F;&#x2F; 略：...一些判断是否触发 setter 的条件  if (setter) &#123;    setter.call(obj, newVal)  &#125; else &#123;    val &#x3D; newVal  &#125;  &#x2F;&#x2F; 设置新值后需要重新 observe  childOb &#x3D; !shallow &amp;&amp; observe(newVal)  &#x2F;&#x2F; 发布通知  dep.notify()&#125;</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文简化了一些细节，但是 Vue 的响应式原理大致如此。当理解了原理之后，如果后面遗忘了的话，以下为重要的记忆点：</p><ol><li>observe：实例化 Observe，参数为数据模型，实例化过程会调用遍历对象属性调用 defineReactive</li><li>defineReactive：实例化 Dep，劫持对象属性的 getter 与 setter，getter 时进行依赖收集</li><li>在挂载组件的时候，会实例化 Watcher，此时会触发 getter</li><li>当更新对象属性时，会调用 Dep 实例的 notify，触发 watcher 的 update</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-JS中的观察者模式与发布订阅模式</title>
      <link href="/2020/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/08/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在上一篇文章《debounce与throttle》 中提到了 RxJS， RxJS 中有两个重要的概念: Observable（可被观察者） 和 Observer（观察者），RxJS 的 Observable 就是观察者模式和迭代器模式的组合。</p><p>在 javascript 中，观察者模式和发布订阅模式极为相似，因此本文将探讨这两种模式以及其应用。</p> <a id="more"></a><h4 id="观察者模式（Observer-pattern）"><a href="#观察者模式（Observer-pattern）" class="headerlink" title="观察者模式（Observer pattern）"></a>观察者模式（Observer pattern）</h4><blockquote><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 —— Graphic Design Patterns</p></blockquote><p>观察者模式有两个对象：一个是观察者，另一个上面提到的目标对象可以称为是发布者，基本的流程为：</p><ol><li>发布者维护一个观察者列表，可以添加或者删除观察者</li><li>当发布者发布通知时，遍历观察者列表，并调用观察者提供的方法</li></ol><p>发布者的实现如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 发布者class Publisher &#123;  constructor() &#123;    &#x2F;&#x2F; 维护一个观察者列表    this.observers &#x3D; []      &#125;      &#x2F;&#x2F; 添加观察者  addObserver(observer) &#123;    this.observers.push(observer)  &#125;  &#x2F;&#x2F; 移除观察者  removeObserver(observer) &#123;    this.observers &#x3D; this.observers.filter(item &#x3D;&gt; item !&#x3D;&#x3D; observer)  &#125;  &#x2F;&#x2F; 发布通知  notify() &#123;    this.observers.forEach((item) &#x3D;&gt; &#123;      &#x2F;&#x2F; 执行观察者提供的方法，这里假设为 update      item.update()    &#125;)  &#125;&#125;</code></pre><p>订阅者则比较简单，实现如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Observer &#123;  constructor(name) &#123;    this.name &#x3D; name  &#125;  update() &#123;    &#x2F;&#x2F; 更新状态    console.log(&#96;observer $&#123;this.name&#125; update&#96;)  &#125;&#125;</code></pre><p>最终：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const a &#x3D; new Observer(&#39;a&#39;)const b &#x3D; new Observer(&#39;b&#39;)const c &#x3D; new Observer(&#39;c&#39;)const publisher &#x3D; new Publisher()publisher.addObserver(a)publisher.addObserver(b)publisher.addObserver(c)&#x2F;&#x2F; 发布通知publisher.notify()&#x2F;&#x2F; a b c</code></pre><p>Vue 的响应式原理就是观察者模式的一个典型应用，关于 Vue 的响应式由于篇幅原因，将会另起一篇详细分析。</p><h4 id="发布订阅模式（Pub-sub-pattern）"><a href="#发布订阅模式（Pub-sub-pattern）" class="headerlink" title="发布订阅模式（Pub-sub pattern）"></a>发布订阅模式（Pub-sub pattern）</h4><p>发布订阅模式是从观察者模式发展而来，两者的区别在于：观察者模式中发布者与观察者是松耦合，而发布订阅则在发布者与订阅者中加入了事件中心实现发布者与观察者的完全解耦。</p><p>用发布订阅模式模拟事件绑定：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class EventCenter &#123;  constructor() &#123;    this.observers &#x3D; &#123;&#125;  &#125;  addListener(type, fn) &#123;    this.observers[type] &#x3D; [...(this.observers[type] || []), fn]  &#125;  removeListener(type, fn) &#123;    let listeners &#x3D; this.observers[type];    if (!listeners || !listeners.length) return;    this.observers[type] &#x3D; listeners.filter(v &#x3D;&gt; v !&#x3D;&#x3D; fn);  &#125;  dispatchEvent(type) &#123;    let listeners &#x3D; this.observers[type];    if (!listeners || !listeners.length) return;    listeners.forEach(fn &#x3D;&gt; fn());          &#125;&#125;const evtCenter &#x3D; new EventCenter()function handleClick () &#123;  console.log(&#39;click&#39;)&#125;&#x2F;&#x2F; 订阅 click 事件evtCenter.addListener(&#39;click&#39;, handleClick)&#x2F;&#x2F; 发布 click 事件evtCenter.dispatchEvent(&#39;click&#39;)&#x2F;&#x2F; 取消订阅evtCenter.removeListener(&#39;click&#39;, handleClick)</code></pre><p>可以看到与观察者模式不同，在发布订阅模式中，我们的发布和订阅都是通过事件中心来进行调度的。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debounce与throttle</title>
      <link href="/2020/08/06/debounce%E4%B8%8Ethrottle/"/>
      <url>/2020/08/06/debounce%E4%B8%8Ethrottle/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>测试同学提了个 bug，在搜索框中疯狂输入文字，不一会儿接口就报错了。这个 bug 实际上就是由于每输入一个字符时，就去请求接口引起的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const handleSearch &#x3D; () &#x3D;&gt; &#123;&#x2F;&#x2F; ...请求接口&#125;&lt;Input onChange&#x3D;&#123;handleSearch&#125; &#x2F;&gt;</code></pre><p>解决方法是通过 <code>debounce</code> 来控制输入的频率。</p><p>实际上 <code>debounce</code> 和 <code>throttle</code> 这两个概念经常是一起出现，在工作中也常常使用到。在早年接触前端的时候，项目里有 <code>lodash</code>，因此直接使用其提供的  <code>debounce</code> 和 <code>throttle</code> 。而在一些简单的项目里，往往不引入 <code>lodash</code>，这个时候就需要自己实现，于此做个记录。</p><a id="more"></a><h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><p><code>debounce</code> 也就是防抖，看看 lodash 中 debounce 的定义：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">_.debounce(func, [wait&#x3D;0], [options&#x3D;&#123;&#125;])</code></pre><p>返回一个函数，该函数会距离上次调用后，延迟 <code>wait</code> 毫秒后调用<code>func</code>。</p><p>在上面的 bug 中，对原搜索方法进行防抖处理后，仅当用户停止输入 300 毫秒后，才请求接口进行搜索：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 停止输入 300 ms 后，进行搜索_.debounce(handleSearch, 300)</code></pre><p>####throttle</p><p><code>throttle</code> 我们称之为截流，同样看看 loads 中 throttle 的定义：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">_.throttle(func, [wait&#x3D;0], [options&#x3D;&#123;&#125;])</code></pre><p>返回一个函数，该函数最多每 <code>wait</code> 毫秒调用一次 <code>func</code>。</p><p>如果对搜索方法进行截流，则无论用户输入多快，每 1 秒仅请求一次：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 停止输入 300 ms 后，进行搜索_.debounce(handleSearch, 1000)</code></pre><h4 id="手写一个-debounce"><a href="#手写一个-debounce" class="headerlink" title="手写一个 debounce"></a>手写一个 debounce</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function debounce(func, wait &#x3D; 0) &#123;  let timeout  return function(...args) &#123;    if(timeout) &#123;      clearTimeout(timeout)    &#125;    timeout &#x3D; setTimeout(() &#x3D;&gt; func.call(this, ...args), wait)  &#125;&#125;</code></pre><p>由于 func 被当作是参数传递进来，注意上面的 func 需要绑定 this。并且在使用时如果有 this 指向，需要显式指明 this，如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const o &#x3D; &#123;  a: 1,  b: function() &#123;      console.log(this.a);  &#125;&#125;const c &#x3D; debounce(o.b).bind(o);</code></pre><p>对 debounce 进一步拓展，如果需要在调用时立刻执行一次，则可以：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function debounce(func, wait &#x3D; 0, head) &#123;  let timeout;  return function (...args) &#123;    const callNow &#x3D; head &amp;&amp; !timeout;    timeout &amp;&amp; clearTimeout(timeout);    timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;      if(!callNow) &#123;        func.call(this, ...args);      &#125;      timeout &#x3D; null    &#125;, wait);    if (callNow) &#123;      func.call(this, ...args)    &#125;;  &#125;;&#125;</code></pre><h4 id="手写一个-throttle"><a href="#手写一个-throttle" class="headerlink" title="手写一个 throttle"></a>手写一个 throttle</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function throttle(func, timeFrame &#x3D; 0) &#123;  let lastTime &#x3D; 0;  return function () &#123;      const now &#x3D; new Date();      if (now - lastTime &gt;&#x3D; timeFrame) &#123;          func.call(this, ...args);          lastTime &#x3D; now;      &#125;  &#125;;&#125;</code></pre><h4 id="what’s-more-rxjs"><a href="#what’s-more-rxjs" class="headerlink" title="what’s more: rxjs"></a>what’s more: rxjs</h4><p>截流和防抖很多时候是出现在事件中的，使用 rxjs 则可以使用 debounceTime 和 throttleTime：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; fromEvent &#125; from &#39;rxjs&#39;;import &#123; debounceTime &#125; from &#39;rxjs&#x2F;operators&#39;;const inputEle &#x3D; document.getElementById(&#39;input&#39;)const inputs &#x3D; fromEvent(inputEle, &#39;input&#39;);const result &#x3D; inputs.pipe(debounceTime(1000));&#x2F;&#x2F; 如果是节流可使用 throttleTime&#x2F;&#x2F; const result &#x3D; inputs.pipe(throttleTime(1000));result.subscribe(x &#x3D;&gt; console.log(x));</code></pre><h4 id="rxjs-react"><a href="#rxjs-react" class="headerlink" title="rxjs + react"></a>rxjs + react</h4><p>如果是 react 中的事件需要防抖，那么可以通过 <code>Subject</code> 来实现：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; useEffect &#125; from &quot;react&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;import &quot;rxjs&#x2F;add&#x2F;operator&#x2F;debounceTime&quot;;const value$ &#x3D; new Subject().debounceTime(300);export default function App() &#123;  useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; value$.subscribe(console.log)      return () &#x3D;&gt; subscription.unsubscribe()  &#125;, [])  const onChange &#x3D; e &#x3D;&gt; &#123;    value$.next(e.target.value);  &#125;;  return (    &lt;div&gt;      &lt;input onChange&#x3D;&#123;onChange&#125; &#x2F;&gt;    &lt;&#x2F;div&gt;  );&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当我们说到打包时，我们在说什么</title>
      <link href="/2020/07/31/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E5%88%B0%E6%89%93%E5%8C%85%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/"/>
      <url>/2020/07/31/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E5%88%B0%E6%89%93%E5%8C%85%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>从早期的 grunt (我接触前端开发的时候这个已经趋于没落) 到 gulp，再到如今的 webpack，rollup ，parcel，以及 snowpack，vite，如今的前端已经脱离了刀耕火种的时代，各种打包工具层出不穷。前端项目基本离不开打包这个过程。那么当我们说到打包（bundle）时，我们在说的是什么？</p><p>这里不对 webpack 或者这些打包工具的使用进行具体说明，本文想探究的是打包的本质。</p><a id="more"></a><h4 id="从模块化说起"><a href="#从模块化说起" class="headerlink" title="从模块化说起"></a>从模块化说起</h4><p>在没有模块化之前，前端开发时需要格外注意命名冲突以及文件之间的相互依赖，参考 <a href="https://github.com/seajs/seajs/issues/547#issue-11105836。">https://github.com/seajs/seajs/issues/547#issue-11105836。</a></p><p>模块化实际上就是将程序分解成离散的功能块，使代码易于复用，维护和测试。如 less 中通过 @import 引入的样式，ES6 Module / CommonJs 引入的 Js 等都可以称为模块。</p><p>然而浏览器不支持模块化，因此我们需要一个打包工具，将代码中诸如 require, @import, import 进来的模块打包成一个或者多个文件(即 bundle)。</p><h4 id="打包的本质"><a href="#打包的本质" class="headerlink" title="打包的本质"></a>打包的本质</h4><p>参考 webpack 的定义：</p><blockquote><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p></blockquote><p>而至于这个过程中，对代码进行压缩，混淆等等则是锦上添花的功能。</p><h4 id="打包的过程"><a href="#打包的过程" class="headerlink" title="打包的过程"></a>打包的过程</h4><p>这里以 webpack 为例：</p><ol><li>初始化：从配置文件和 Shell 语句中读取并合并配置参数</li><li>开始编译：根据上面得到的参数初始化 Compiler，加载插件（Plugins），执行 Compiler 的 run 方法开始编译</li><li>入口文件：配置的 entry</li><li>从入口文件开始，针对不同的模块使用对应的 Loader 编译，再找到该模块所依赖的模块，递归这个步骤</li><li>完成编译：经过上述步骤后得到每个模块编译后的内容以及相互之间的依赖关系</li><li>输出：根据依赖关系，将模块组合成一个个代码块（Chunk），最后输出成文件</li></ol><h4 id="实现一个简易的打包工具"><a href="#实现一个简易的打包工具" class="headerlink" title="实现一个简易的打包工具"></a>实现一个简易的打包工具</h4><p>参考 <a href="https://github.com/ronami">ronami</a>/<strong><a href="https://github.com/ronami/minipack">minipack</a></strong> 实现一个支持 ES Module 的简易打包工具（这里不考虑循环依赖等情况）：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const fs &#x3D; require(&#39;fs&#39;)const path &#x3D; require(&#39;path&#39;)const babylon &#x3D; require(&#39;babylon&#39;)const traverse &#x3D; require(&#39;babel-traverse&#39;).defaultconst &#123; transformFromAst &#125; &#x3D; require(&#39;babel-core&#39;)</code></pre><p>引入上述相关依赖：</p><ul><li>babylon：生成 AST（抽象语法树）</li><li>babel-traverse：来分析文件的依赖</li><li>transformFromAst：将 AST 转为 ES5</li></ul><p><strong>首先</strong> 定义一个函数用于读取文件的内容和依赖：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * 读取文件内容和依赖 *&#x2F;function createAsset(filePath) &#123;&#x2F;&#x2F; 读取文件内容  const content &#x3D; fs.readFileSync(filePath, &#39;utf-8&#39;)  &#x2F;&#x2F; 生成 AST  const ast &#x3D; babylon.parse(content, &#123;    sourceType: &#39;module&#39;,  &#125;)  &#x2F;&#x2F; 当前文件的依赖关系  const dependencies &#x3D; []  traverse(ast, &#123;    &#x2F;&#x2F; 当遇到导入的声明时，将其内容 push 到 dependencies 里    ImportDeclaration: (&#123; node &#125;) &#x3D;&gt; &#123;      dependencies.push(node.source.value)    &#125;,  &#125;)  &#x2F;&#x2F; 将 AST 转为 ES5  const &#123; code &#125; &#x3D; transformFromAst(ast, null, &#123;    presets: [&#39;env&#39;],  &#125;)  return &#123;    filePath,    dependencies,    code,  &#125;&#125;</code></pre><p>Asset 接口如下：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Assets &#123;&#x2F;&#x2F; 文件路径  filePath: string;  &#x2F;&#x2F; 文件的依赖  dependencies: string[];  &#x2F;&#x2F; 转为 ES5 后的文件内容  code: string;  &#x2F;&#x2F; 相对路径  relativePath?: string;&#125;</code></pre><p>例如，我们现在有个文件 entry.js ，内容如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; entry.jsimport a from &#39;.&#x2F;a.js&#39;console.log(a)</code></pre><p>运行 <code>createAsset(&#39;./entry.js&#39;)</code> 将会返回：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;  filePath: &#39;.&#x2F;entry.js&#39;,  dependencies: [ &#39;.&#x2F;a.js&#39; ],  code: &#96;&quot;use strict&quot;;var _a &#x3D; require(&quot;.&#x2F;a.js&quot;);var _a2 &#x3D; _interopRequireDefault(_a);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;console.log(_a2.default);&#96;&#125;</code></pre><p><strong>接着</strong>定义一个函数用于构建依赖关系图( dependency graph )：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * 构建依赖关系图 *&#x2F;function createGraph(entry) &#123;  &#x2F;&#x2F; 从入口文件开始  const entryAsset &#x3D; createAsset(entry);  &#x2F;&#x2F; 初始时，queue 中只有 entryAsset, 之后分析依赖关系，会将新的 Asset push 到 queue 中用于分析，直到分析完全部依赖  const queue &#x3D; [entryAsset]  &#x2F;&#x2F; 遍历所有文件依赖关系  for (const asset of queue) &#123;    &#x2F;&#x2F; 获得文件目录    const dirname &#x3D; path.dirname(asset.filePath)    &#x2F;&#x2F; 遍历当前文件依赖关系    asset.dependencies.forEach((relativePath) &#x3D;&gt; &#123;      &#x2F;&#x2F; 获得绝对路径      const absolutePath &#x3D; path.join(dirname, relativePath)      const childAsset &#x3D; createAsset(absolutePath)      childAsset.relativePath &#x3D; relativePath      &#x2F;&#x2F; 将当前文件所依赖的文件的 Asset 也 push 到 queue 中用于遍历      queue.push(childAsset)    &#125;)  &#125;  return queue&#125;</code></pre><p>例如，在上面的基础上，有个 a.js 以及 b.js 文件, 运行 <code>createGraph</code>会返回：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; a.jsimport b from &#39;.&#x2F;b.js&#39;const a &#x3D; &#39;1&#39;export default a&#x2F;&#x2F; b.jsconst b &#x3D; &#39;2&#39;export default b&#x2F;&#x2F; createGraph(&#39;.&#x2F;entry.js&#39;)[  &#123;    filePath: &#39;.&#x2F;entry.js&#39;,    dependencies: [ &#39;.&#x2F;a.js&#39; ],    code: &#96;&quot;use strict&quot;;var _a &#x3D; require(&quot;.&#x2F;a.js&quot;);var _a2 &#x3D; _interopRequireDefault(_a);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;console.log(_a2.default);&#96;  &#125;,  &#123;    filePath: &#39;a.js&#39;,    dependencies: [ &#39;.&#x2F;b.js&#39; ],    code: &#96;&quot;use strict&quot;;Object.defineProperty(exports, &quot;__esModule&quot;, &#123;  value: true&#125;);var _b &#x3D; require(&quot;.&#x2F;b.js&quot;);var _b2 &#x3D; _interopRequireDefault(_b);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;var a &#x3D; &#39;1&#39;;exports.default &#x3D; a;&#96;,    relativePath: &#39;.&#x2F;a.js&#39;  &#125;,  &#123;    filePath: &#39;b.js&#39;,    dependencies: [],    code: &#96;&quot;use strict&quot;;Object.defineProperty(exports, &quot;__esModule&quot;, &#123;  value: true&#125;);var b &#x3D; &#39;2&#39;;exports.default &#x3D; b;&#96;,    relativePath: &#39;.&#x2F;b.js&#39;  &#125;]</code></pre><p><strong>最后</strong>实现一个打包函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function bundle(entry) &#123;  const graph &#x3D; createGraph(entry)  let modules &#x3D; &#39;&#39;  &#x2F;&#x2F; 构建函数参数  graph.forEach((mod) &#x3D;&gt; &#123;    const filePath &#x3D; mod.relativePath || entry    &#x2F;&#x2F; 拼装成 modules    modules +&#x3D; &#96;&#39;$&#123;filePath&#125;&#39;: (      function (module, exports, require) &#123; $&#123;mod.code&#125; &#125;    ),&#96;  &#125;)  &#x2F;&#x2F; 最终结果  const result &#x3D; &#96;    (function(modules) &#123;&#x2F;&#x2F; ast 转 es5 的代码是 commonjs 风格，而浏览器不支持 commonjs，因此自定义 require，以文件名作为 id      function require(id) &#123;        const module &#x3D; &#123; exports : &#123;&#125; &#125;        modules[id](module, module.exports, require)        return module.exports      &#125;&#x2F;&#x2F; 引入入口文件代码      require(&#39;$&#123;entry&#125;&#39;)    &#125;)(&#123;$&#123;modules&#125;&#125;)  &#96;  &#x2F;&#x2F; 当生成的内容写入到文件中  fs.writeFileSync(&#39;.&#x2F;bundle.js&#39;, result)&#125;　</code></pre><p>最终输出一个 IIFE：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">;(function (modules) &#123;  function require(id) &#123;    const module &#x3D; &#123; exports: &#123;&#125; &#125;    modules[id](module, module.exports, require)    return module.exports  &#125;  require(&#39;.&#x2F;entry.js&#39;)&#125;)(&#123;  &#39;.&#x2F;entry.js&#39;: function (module, exports, require) &#123;    &#39;use strict&#39;    var _a &#x3D; require(&#39;.&#x2F;a.js&#39;)    var _a2 &#x3D; _interopRequireDefault(_a)    function _interopRequireDefault(obj) &#123;      return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;    &#125;    console.log(_a2.default)  &#125;,  &#39;.&#x2F;a.js&#39;: function (module, exports, require) &#123;    &#39;use strict&#39;    Object.defineProperty(exports, &#39;__esModule&#39;, &#123;      value: true,    &#125;)    var _b &#x3D; require(&#39;.&#x2F;b.js&#39;)    var _b2 &#x3D; _interopRequireDefault(_b)    function _interopRequireDefault(obj) &#123;      return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;    &#125;    var a &#x3D; &#39;1&#39;    exports.default &#x3D; a  &#125;,  &#39;.&#x2F;b.js&#39;: function (module, exports, require) &#123;    &#39;use strict&#39;    Object.defineProperty(exports, &#39;__esModule&#39;, &#123;      value: true,    &#125;)    var b &#x3D; &#39;2&#39;    exports.default &#x3D; b  &#125;,&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-JS中的单例模式</title>
      <link href="/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-JS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>此前项目有个 im  模块，需要用到 websocket。使用 websocket 需要建立连接：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const initWs &#x3D; () &#x3D;&gt; &#123;  const ws &#x3D; new WebSocket(&#39;wss:&#x2F;&#x2F;xxx.com&#39;);  ws.onopen(() &#x3D;&gt; &#123;    console.log(&#39;opened&#39;)  &#125;)  ws.onmessage((evt) &#x3D;&gt; &#123;    console.log(&#39;Received evt&#39;, evt.data)  &#125;)  &#x2F;&#x2F;....  return ws&#125;</code></pre><p>我们肯定不希望在每个用到 ws 的地方都重复初始化，即我们只需要一个 WebSocket 的实例。</p><a id="more"></a><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const wsA &#x3D; new SingleWs()const wsB &#x3D; new SingleWs()&#x2F;&#x2F; 有没有办法使得:wsA instanceof WebSocket &amp;&amp; wsB instanceof WebSocket &amp;&amp; wsA &#x3D;&#x3D;&#x3D; wsB</code></pre><p>那么要如何做到这一点？实际上就可以用到单例模式。下面列举几个实现的方法：</p><h4 id="使用全局变量"><a href="#使用全局变量" class="headerlink" title="使用全局变量"></a>使用全局变量</h4><p>这个可能是最容易想到的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.ws &#x3D; window.ws || initWs()</code></pre><p>将 ws 挂在 window 对象上，使用时也用 window.ws，显然这个解决方案有个问题是需要小心 window.ws 被覆盖。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包可以保持局部变量保持在内存中不被销毁，通过这个特性可以就可以避免污染全局变量，如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const SingleWs &#x3D; (function() &#123; let ws &#x3D; null; &#x2F;&#x2F; const initWs &#x3D; .... return &#123;   getWs() &#123;     if(!ws) &#123;       ws &#x3D; initWs()     &#125;     return ws   &#125;  &#125;&#125;)()const wsA &#x3D; SingleWs.getWs()const wsB &#x3D; SingleWs.getWs()console.log(wsA instanceof WebSocket &amp;&amp; wsB instanceof WebSocket &amp;&amp; wsA &#x3D;&#x3D;&#x3D; wsB)</code></pre><p>然而上面的写法也有一些缺点，如 getWs 可以被改写。</p><p>写法还可以进一步改写：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const SingleWs &#x3D; (function() &#123; let ws &#x3D; null; &#x2F;&#x2F; const initWs &#x3D; ....  return () &#x3D;&gt; &#123;    if(!ws) &#123;      ws &#x3D; initWs()    &#125;    return ws  &#125;&#125;)()&#x2F;&#x2F; 这里的 new 可以不写const wsA &#x3D; new SingleWs()const wsB &#x3D; new SingleWs()wsA instanceof WebSocket &amp;&amp; wsB instanceof WebSocket &amp;&amp; wsA &#x3D;&#x3D;&#x3D; wsB</code></pre><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>通过模块化也能实现上述的效果：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; ws.jslet ws &#x3D; null&#x2F;&#x2F; const initWs &#x3D; ....function SingleWs() &#123;  if (ws) &#123;    return ws  &#125;  ws &#x3D; initWs()  return ws&#125;export default SingleWs</code></pre><h4 id="通过-class-的静态属性来实现"><a href="#通过-class-的静态属性来实现" class="headerlink" title="通过 class 的静态属性来实现"></a>通过 class 的静态属性来实现</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class SingleWs &#123;  constructor() &#123;    if (!SingleWs.instance) &#123;      SingleWs.instance &#x3D; this.initWs()    &#125;    return SingleWs.instance  &#125;  initWs() &#123;    &#x2F;&#x2F; ...      &#125;&#125;const wsA &#x3D; new SingleWs()const wsB &#x3D; new SingleWs()console.log(wsA instanceof WebSocket &amp;&amp; wsB instanceof WebSocket &amp;&amp; wsA &#x3D;&#x3D;&#x3D; wsB)</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>JS 中的单例模式：</p><ol><li>实例化时，判断是否已经存在实例。</li><li>如果不存在，则初始化，并将生成的实例存储起来。</li><li>存储的方法可以是全局变量，闭包，模块以及类的静态属性。</li><li>如果已经存在实例，那么就直接返回该实例。</li></ol>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】ReactHooks-并非黑魔法，本质是数组</title>
      <link href="/2020/07/26/%E3%80%90%E8%AF%91%E3%80%91ReactHooks-%E5%B9%B6%E9%9D%9E%E9%BB%91%E9%AD%94%E6%B3%95%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B0%E7%BB%84/"/>
      <url>/2020/07/26/%E3%80%90%E8%AF%91%E3%80%91ReactHooks-%E5%B9%B6%E9%9D%9E%E9%BB%91%E9%AD%94%E6%B3%95%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本文翻译自 <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">React hooks: not magic, just arrays</a>，该文章很好的阐释了 react hooks 原理，我将保持原文的意思进行翻译，如有自己感觉不清楚的地方将会在括号中注明。以下为翻译内容。</p><p>我是 hooks api 的忠实粉丝。然而 hooks 在使用时却有一些<a href="https://reactjs.org/docs/hooks-rules.html">奇怪的约束</a>。在这里，我给尝试去理解这些规则由来的人提供一个了模型，用于思考如何去使用这些新 api。</p><a id="more"></a><h4 id="hooks-的规则"><a href="#hooks-的规则" class="headerlink" title="hooks 的规则"></a>hooks 的规则</h4><p>在 <a href="https://reactjs.org/docs/hooks-rules.html">hooks proposal documentation</a> 的提纲中，React 核心团队规定了两条开发者在使用 hooks 时需要遵守的主要规则：</p><ul><li>不要在循环，条件或者是嵌套函数中使用 hooks</li><li>只能在 React Functions 中才能使用 hooks</li></ul><p>后者我认为是显而易见的。要将行为附加到函数式组件上，你需要能够以某种方式将该行为与组件关联起来。（原文为： To attach behaviour to a functional component you need to be able to associate that behaviour with the component somehow. 不太理解作者想表达的意思）</p><p>前者我认为会比较让人困惑，因为像这样使用 api 可能看起来不太自然。而这正是我今天想要探讨的内容。</p><h4 id="hooks-的状态管理都是基于数组"><a href="#hooks-的状态管理都是基于数组" class="headerlink" title="hooks 的状态管理都是基于数组"></a>hooks 的状态管理都是基于数组</h4><p>为了更清晰地理解心智模型，让我们来看一下如何实现一个简单的 hooks api。</p><p><strong>注意这只是 API 的一种可能的实现方式及猜想，用于让你理解，而非 API 真正的内部实现方式</strong></p><h4 id="我们如何实现-useState"><a href="#我们如何实现-useState" class="headerlink" title="我们如何实现 useState?"></a>我们如何实现 <code>useState</code>?</h4><p>让我们打开一个实例来演示如何实现一个 state hook。</p><p>首先，我们定义一个组件：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">function RenderFunctionComponent() &#123;  const [firstName, setFirstName] &#x3D; useState(&quot;Rudi&quot;);  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;);  return (    &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;  );&#125;</code></pre><p>这个 Hooks api 背后的思想是，你可以用 hook 函数返回的数组的第二个元素作为 setter 方法，这个 setter 方法可以控制被 hook 管理的状态。</p><h4 id="那么-React-是如何做到这个的呢？"><a href="#那么-React-是如何做到这个的呢？" class="headerlink" title="那么 React 是如何做到这个的呢？"></a>那么 React 是如何做到这个的呢？</h4><p>让我们看看这个在 React 内部是如何运作的。以下内容将在特定组件的上下文中运行。这就是说数据存储在要渲染的组件的上一层。这个 state 不与其他组件共享，但是维护在一个可以用于该组件后续渲染的作用域内。（原文：The following would work within the execution context for rendering a particular component. That means that the data stored here lives one level outside of the component being rendered. This state is not shared with other components but it is maintained in a scope that is accessible to subsequent rendering of the specific component）</p><ol><li><p>初始化</p><p>创建两个空数组：<code>setter</code> 和 <code>state</code></p><p>将指针设置为 0</p><p><img src="https://miro.medium.com/max/1280/1*LAZDuAEm7nbcx0vWVKJJ2w.png" alt="Image for post"></p></li><li><p>首次渲染</p><p>首次运行该组件。</p><p>每次调用 <code>useState</code> ，如果是首次运行，则 push 一个 setter 方法（绑定到指针的位置）到 setters 数组中，并且 push 一些 state 到 state 数组中。</p><p><img src="https://miro.medium.com/max/1260/1*8TpWnrL-Jqh7PymLWKXbWg.png" alt="Image for post"></p></li><li><p>后续渲染</p><p>每次后续渲染，指针将被重置，然后从各个数组中读取对应的值。</p><p><img src="https://miro.medium.com/max/1254/1*qtwvPWj-K3PkLQ6SzE2u8w.png" alt="Image for post"></p></li><li><p>事件处理</p><p>每一个 setter 都保存一个对应的指针位置的引用，因此触发任意一个 <code>setter</code> 都可以修改 state 数组中对应指针位置的 state。</p><p><img src="https://miro.medium.com/max/1260/1*3L8YJnn5eV5ev1FuN6rKSQ.png" alt="Image for post"></p></li></ol><h4 id="简单的实现-And-the-naive-implementation"><a href="#简单的实现-And-the-naive-implementation" class="headerlink" title="简单的实现(And the naive implementation)"></a>简单的实现(And the naive implementation)</h4><p>下面是简单的代码演示：</p><p><strong>注意：这不代表 hooks 的实际实现，但是应该能给你一个理解 hooks 工作原理的思路。这就是我为什么使用块级变量的原因（原文： That is why we are using module level vars etc）</strong></p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">let state &#x3D; [];let setters &#x3D; [];let firstRun &#x3D; true;let cursor &#x3D; 0;function createSetter(cursor) &#123;  return function setterWithCursor(newVal) &#123;    state[cursor] &#x3D; newVal;  &#125;;&#125;&#x2F;&#x2F; This is the pseudocode for the useState helperexport function useState(initVal) &#123;  if (firstRun) &#123;    state.push(initVal);    setters.push(createSetter(cursor));    firstRun &#x3D; false;  &#125;  const setter &#x3D; setters[cursor];  const value &#x3D; state[cursor];  cursor++;  return [value, setter];&#125;&#x2F;&#x2F; Our component code that uses hooksfunction RenderFunctionComponent() &#123;  const [firstName, setFirstName] &#x3D; useState(&quot;Rudi&quot;); &#x2F;&#x2F; cursor: 0  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;); &#x2F;&#x2F; cursor: 1  return (    &lt;div&gt;      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Richard&quot;)&#125;&gt;Richard&lt;&#x2F;Button&gt;      &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;    &lt;&#x2F;div&gt;  );&#125;&#x2F;&#x2F; This is sort of simulating Reacts rendering cyclefunction MyComponent() &#123;  cursor &#x3D; 0; &#x2F;&#x2F; resetting the cursor  return &lt;RenderFunctionComponent &#x2F;&gt;; &#x2F;&#x2F; render&#125;console.log(state); &#x2F;&#x2F; Pre-render: []MyComponent();console.log(state); &#x2F;&#x2F; First-render: [&#39;Rudi&#39;, &#39;Yardley&#39;]MyComponent();console.log(state); &#x2F;&#x2F; Subsequent-render: [&#39;Rudi&#39;, &#39;Yardley&#39;]&#x2F;&#x2F; click the &#39;Fred&#39; buttonconsole.log(state); &#x2F;&#x2F; After-click: [&#39;Fred&#39;, &#39;Yardley&#39;]</code></pre><h4 id="为什么顺序很重要？"><a href="#为什么顺序很重要？" class="headerlink" title="为什么顺序很重要？"></a>为什么顺序很重要？</h4><p>现在如果在一个生命周期里，我们基于外部的因素或者组件状态改变了 hooks 的顺序，将会发生什么事情？</p><p>让我们试试看 react 不建议我们做的事情：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">let firstRender &#x3D; true;function RenderFunctionComponent() &#123;  let initName;  if(firstRender)&#123;    [initName] &#x3D; useState(&quot;Rudi&quot;);    firstRender &#x3D; false;  &#125;  const [firstName, setFirstName] &#x3D; useState(initName);  const [lastName, setLastName] &#x3D; useState(&quot;Yardley&quot;);  return (    &lt;Button onClick&#x3D;&#123;() &#x3D;&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;&#x2F;Button&gt;  );&#125;</code></pre><p>我们在一个条件语句中使用了 <code>useState</code>，让我们看看造成了什么样的破坏：</p><h4 id="坏组件的第一次渲染"><a href="#坏组件的第一次渲染" class="headerlink" title="坏组件的第一次渲染"></a>坏组件的第一次渲染</h4><p><img src="https://miro.medium.com/max/1270/1*C4IA_Y7v6eoptZTBspRszQ.png" alt="Image for post"></p><p>在这个时候，我们的实例变量 <code>firstName</code> 和 <code>lastName</code> 指向的正确的数据，但是我们看看第二次渲染发生了什么：</p><h4 id="坏组件的第二次渲染"><a href="#坏组件的第二次渲染" class="headerlink" title="坏组件的第二次渲染"></a>坏组件的第二次渲染</h4><p><img src="https://miro.medium.com/max/1274/1*aK7jIm6oOeHJqgWnNXt8Ig.png" alt="Image for post"></p><p>现在我们的 state 存储出现异常， <code>firstName</code> 和 <code>lastName</code> 都指向 “Rudi”。上述明显错误的操作给了我们一个思路：为什么 hooks 要如此规定。</p><blockquote><p>The React team are stipulating the usage rules because not following them will lead to inconsistent data</p></blockquote><h4 id="想想-hooks-操作一系列的数组，那么你就不会打破规则了（Think-about-hooks-manipulating-a-set-of-arrays-and-you-wont-break-the-rules）"><a href="#想想-hooks-操作一系列的数组，那么你就不会打破规则了（Think-about-hooks-manipulating-a-set-of-arrays-and-you-wont-break-the-rules）" class="headerlink" title="想想 hooks 操作一系列的数组，那么你就不会打破规则了（Think about hooks manipulating a set of arrays and you wont break the rules）"></a>想想 hooks 操作一系列的数组，那么你就不会打破规则了（Think about hooks manipulating a set of arrays and you wont break the rules）</h4><p>现在应该能很清晰理解为什么不能在条件或者循环语句中使用 <code>use</code> hook 了：因为我们使用了指针指向了数组，如果在 render 的时候改变了顺序，那么指针就不能对应正确的数据，所以调用 use 也不会指向正确的数据和 setter。</p><p>因此，诀窍就是将 hooks 想像成用恒定的指针来管理一系列数组。如果能做到这个，那么一切就能按预期进行。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>希望我已经就如何思考 hooks api 的工作原理指出了一个清晰的心智模型。（后面就偷个懒不翻译了，基本是上述观点的重复强调。）</p><p>Hopefully I have laid out a clearer mental model for how to think about what is going on under the hood with the new hooks API. Remember the true value here is being able to group concerns together so being careful about order and using the hooks API will have a high payoff.</p><p>Hooks is an effective plugin API for React Components. There is a reason why people are excited about this and if you think about this kind of model where state exists as a set of arrays then you should not find yourselves breaking the rules around their usage.</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见的安全问题汇总</title>
      <link href="/2020/07/23/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/23/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近安全部门的小伙伴提了一个前端安全的漏洞，想到前端开发过程中有时候往往追求开发效率，忽略掉一些安全问题，以下简单总结一些自己遇到过的以及一些常见的攻击手段，以自查自省。</p><a id="more"></a><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>回到安全部门提出的漏洞，场景还原如下：<br>这是一个老项目，展示文章用，页面路由为 <a href="http://xxx/article/:id?these-are-queries，node">http://xxx/article/:id?these-are-queries，node</a> 层收到这个 url 后，返回返回该文章 html，内容则包括了【推荐文章】， 而推荐文章的链接则是根据 url 的值来的，仅变化 id。此时如果在 url 上的 query 上构造一段恶意脚本，然后引导用户打开，那么用户打开页面后就会运行该恶意脚本。<br>上述正是一个典型的 XSS 攻击，定义如下：</p><blockquote><p>XSS是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p></blockquote><p>XSS 的本质是信任了某些不安全的输入，导致恶意代码混入正常代码，进而发生的攻击行为。常见的不安全输入有：</p><ol><li>上面提到的 url 参数，这种需要诱导用户取点击</li><li>用户输入的内容，比如用户发表评论</li><li>第三方的链接等</li></ol><p>防范的方法通常是：对用户输入内容和服务端返回内容进行过滤和转译。</p><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>CSRF 攻击常见的过程如下：</p><ol><li>用户登录你的网站，产生登录凭证，如 cookie</li><li>用户被<strong>诱导</strong>登录到恶意网站</li><li>恶意网站携带刚刚在浏览器产生的凭证向你的服务器发送一个恶意请求</li><li>你的服务器无法识别是否恶意请求，请求完成，用户受害。</li></ol><p>与上面提到的 XSS 攻击有个明显的区别在于：CSRF 攻击发生在恶意网站，而不是被攻击的网站。而这也使得攻击者并不能获取到受害者的登录凭证，仅仅只能使用。<br>防范的方法通常是：</p><ol><li>请求 url 添加 token 或者是在 http 请求头自定义属性进行验证</li><li>同源检测，通过解析 请求头中的 referer 判断请求来源</li><li>Samesite，Google 起草了一份草案来改进 HTTP 协议，为 Set-Cookie 响应头新增 Samesite 属性，用于标明 Cookie 是否能作用于其他网站，目前兼容性还不是很好。</li></ol><h4 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h4><p>当我们使用 iframe 加载第三方网站时，第三方网站可以对我们的网站执行恶意操作，如操作DOM，加载 js 等。<br>防范的方法是通过设置 sandbox 属性控制 iframe 的操作权限。</p><h4 id="opener"><a href="#opener" class="headerlink" title="opener"></a>opener</h4><p>我们在通常通过以下写法在 新 tab 下打开链接：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">1. &lt;a target&#x3D;&#39;_blank&#39; href&#x3D;&#39;new-site.com&#39;&gt;2. window.open(&#39;new-site.com&#39;)</code></pre><p>上述两种写法的问题在于， <code>new-site.com</code> 是可以通过 <code>window.opener</code> 来拿到源页面的 <code>window</code> 对象，进而进行恶意操作。<br>防范的方法通常是：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">1. &lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;new-site.com&quot; rel&#x3D;&quot;noopener noreferrer nofollow&quot;&gt;a标签跳转url&lt;&#x2F;a&gt;2. function openurl(url) &#123;    var newTab &#x3D; window.open();    newTab.opener &#x3D; null;    newTab.location &#x3D; url;&#125;</code></pre><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul><li><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html">前端安全系列（一）：如何防止XSS攻击？</a></p></li><li><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">前端安全系列（二）：如何防止CSRF攻击？</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN 避坑指北</title>
      <link href="/2020/07/21/RN%20%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97/"/>
      <url>/2020/07/21/RN%20%E9%81%BF%E5%9D%91%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p>记录平时开发 rn 时遇到的问题，特指 0.59 版本，不同版本可能情况不同，仅供参考。</p><a id="more"></a><h5 id="一像素问题"><a href="#一像素问题" class="headerlink" title="一像素问题"></a>一像素问题</h5><p>rn 解决一像素很简单，只需要  <code>StyleSheet.hairlineWidth</code> 即可解决。</p><h5 id="TextInput-组件"><a href="#TextInput-组件" class="headerlink" title="TextInput  组件"></a>TextInput  组件</h5><p>自带内边距，多行文字时文字居中展示，想要消除需要设置样式如下：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;&#x2F; 文字向上对齐textAlignVertical: &#39;top&#39;&#x2F;&#x2F; 消除内边距padding: 0</code></pre><p>Placeholder 在 ios 和 android 下默认颜色表现不一致，可以通过 <code>placeholderTextColor</code>  属性进行设置：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">placeholderTextColor&#x3D;&quot;#CCCCCC&quot;</code></pre><h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><p>因为设计理念的问题，android 下几乎无法实现和 ios 一致的阴影效果。而 flutter 基于 skia 引擎渲染，应该会有比较好的表现？有空尝试下。 🤔</p><h5 id="border-虚线"><a href="#border-虚线" class="headerlink" title="border 虚线"></a>border 虚线</h5><p>border 虚线也是一个比较棘手的问题, android 上实测无效，详情看 <a href="https://github.com/facebook/react-native/issues/17251">issue</a>。解决方案是循环一个 pattern 然后 overhidden 掉，又多了一个让我想尝试 flutter 的理由 😂</p><h5 id="多行文字"><a href="#多行文字" class="headerlink" title="多行文字"></a>多行文字</h5><p>多行文字在 android 机型下有可能会出现高度不够导致文字被截掉的问题，解决方法：设置  <code>lineHeight</code></p><h5 id="实现不同字号的文字底部对齐"><a href="#实现不同字号的文字底部对齐" class="headerlink" title="实现不同字号的文字底部对齐"></a>实现不同字号的文字底部对齐</h5><p>例如 ¥500 想要 ¥ 字号小一点，而 500 字号大一点，但是需要底部对齐，则可以用 Text 包裹起来，如下：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;Text&gt;  &lt;Text style&#x3D;&#123;&#123; fontSize: 12 &#125;&#125;&gt;¥&lt;&#x2F;Text&gt;  &lt;Text style&#x3D;&#123;&#123; fontSize: 20 &#125;&#125;&gt;500&lt;&#x2F;Text&gt;&lt;&#x2F;Text&gt;</code></pre><h5 id="Text-组件样式继承"><a href="#Text-组件样式继承" class="headerlink" title="Text 组件样式继承"></a>Text 组件样式继承</h5><p>众所周知，css 如果想设置默认的全局样式相当简单，比如字体颜色默认为 ‘#323232’ , 只要在 body 上设置一下 <code>color: #323232</code> 即可 ，然而对于 RN 来说则有两种解决方案：</p><ol><li><p>将原生 Text 替换成自定义 Text 组件（官方推荐）</p><blockquote><p>The recommended way to use consistent fonts and sizes across your application is to create a component <code>MyAppText</code> that includes them and use this component across your app</p></blockquote><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React from &#39;react&#39;;import &#123; TextProps, StyleSheet, Text &#125; from &#39;react-native&#39;;const styles &#x3D; StyleSheet.create(&#123;  defaultStyle: &#123;    color: &#39;#323232&#39;,  &#125;,&#125;);export default function CustomText(props: TextProps &amp; &#123; children?: any &#125;) &#123;  const &#123; style, ...restProps &#125; &#x3D; props;  return (    &lt;Text style&#x3D;&#123;[styles.defaultStyle, style]&#125; &#123;...restProps&#125;&gt;      &#123;props.children&#125;    &lt;&#x2F;Text&gt;  );&#125;</code></pre></li><li><p>参考 <a href="https://github.com/Ajackster">Ajackster</a>/<strong><a href="https://github.com/Ajackster/react-native-global-props">react-native-global-props</a></strong> 的实现，在项目入口位置，修改组件的 render 方法。</p></li></ol><p>方案二虽然方便，但不是官方解法，万一有坑就 GG 了。而方案一如果是已有项目，则需要批量修改代码。<br>这里顺便提一下在 vscode 里批量替换的方法：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 将正则，大小写，全匹配 三个按钮点亮find: Text(,|\s)(.*react-native&#39;;)replace: $2\nimport Text from &#39;Your&#x2F;Text&#39;;</code></pre><p>一开始我是这么写的，只考虑到了单行，结果下面这种情况没有替换掉：</p><pre class="line-numbers language-none"><code class="language-none">import &#123;  StyleSheet,  ViewStyle,  View,  Text,  Image,  TouchableOpacity,&#125; from &#39;react-native&#39;;</code></pre><p>后面换成 <code>\sText[,|\s]\n?([\s\S]*&#39;react-native&#39;;)</code> 在浏览器里可以匹配上，但是 vscode 无法匹配 🤔。 最后简单写个脚本补全上面的漏网之鱼:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const fs &#x3D; require(&#39;fs&#39;);const util &#x3D; require(&#39;util&#39;);const path &#x3D; require(&#39;path&#39;);const glob &#x3D; require(&#39;glob&#39;);const replace &#x3D; async () &#x3D;&gt; &#123;  try &#123;    glob(&#39;src&#x2F;**&#x2F;*.tsx&#39;, &#123;&#125;, function (er, files) &#123;      const reg &#x3D; &#x2F;\sText[,|\s]\n?([\s\S]*&#39;react-native&#39;;)&#x2F;;      files.forEach(async (file) &#x3D;&gt; &#123;        const content &#x3D; await util.promisify(fs.readFile)(file, &#39;utf8&#39;);        const newContent &#x3D; content.replace(reg, (m, p1) &#x3D;&gt; &#123;          return &#96; $&#123;p1.trim()&#125;import Text from &#39;@&#x2F;components&#x2F;Text&#39;;&#96;;        &#125;);        await util.promisify(fs.writeFile)(file, newContent, &#39;utf8&#39;);      &#125;);    &#125;);  &#125; catch (error) &#123;    console.log(error);  &#125;&#125;;replace();</code></pre><p>🤔 上面 CustomText 的写法有一个问题，即嵌套 Text 的样式如果是自定义组件中默认的样式，将不会被继承:</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;Text style&#x3D;&#123;&#123; color: &#39;red&#39; &#125;&#125;&gt;  &lt;Text&gt;red&lt;&#x2F;Text&gt;  &lt;Text&gt;red&lt;&#x2F;Text&gt;&lt;&#x2F;Text&gt;&lt;CustomText style&#x3D;&#123;&#123; color: &#39;red&#39; &#125;&#125;&gt;  &lt;CustomText&gt;not red&lt;&#x2F;Text&gt;  &lt;CustomText&gt;not red&lt;&#x2F;Text&gt;&lt;&#x2F;CustomText&gt;</code></pre><p>改良版： </p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">import React, &#123; Children, isValidElement, cloneElement &#125; from &#39;react&#39;;import &#123; TextProps, StyleSheet, Text &#125; from &#39;react-native&#39;;const styles &#x3D; StyleSheet.create(&#123;  defaultStyle: &#123;    color: &#39;#323232&#39;,  &#125;,&#125;);export default function CustomText(  props: TextProps &amp; &#123; children?: any; useDefaultStyle?: boolean &#125;,) &#123;  const &#123; style, useDefaultStyle &#x3D; true, ...restProps &#125; &#x3D; props;  const newStyle &#x3D; useDefaultStyle ? [styles.defaultStyle, style] : style;  const childrenWithProps &#x3D; Children.map(props.children, (child) &#x3D;&gt; &#123;    if (isValidElement(child)) &#123;     &#x2F;&#x2F; 如果子元素是个组件，则子组件不使用默认 style      return cloneElement(child as React.ReactElement&lt;any&gt;, &#123;        useDefaultStyle: false,      &#125;);    &#125;    return child;  &#125;);  return (    &lt;Text style&#x3D;&#123;newStyle&#125; &#123;...restProps&#125;&gt;      &#123;childrenWithProps&#125;    &lt;&#x2F;Text&gt;  );&#125;</code></pre><ul><li><p><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view">react-native-scrollable-tab-view</a></p><p><a href="https://github.com/ptomasroos/react-native-scrollable-tab-view">react-native-scrollable-tab-view</a> 组件作为 ScrollView 的子组件时不可用，会出现 tab 选中不一致，tab content 无法撑开的现象，详情看：<a href="https://github.com/ptomasroos/react-native-scrollable-tab-view/issues/982">https://github.com/ptomasroos/react-native-scrollable-tab-view/issues/982</a></p></li><li><p>设置环境变量<br>通常我们的 web 项目可以在 npm script 里通过设置 NODE_ENV 来设置不同的环境变量。比如 <code>NODE_ENV=develope node index.js</code>, 之后可以在代码中通过 <code>process.env.NODE_ENV</code> 来判断具体是哪个环境。rn 项目要达到同样的目的，则需要额外安装 babel 插件 <a href="https://www.npmjs.com/package/babel-plugin-transform-inline-environment-variables">babel-plugin-transform-inline-environment-variables</a>（或者可以通过 <a href="https://github.com/luggit/react-native-config">react-native-config</a>，不过这个方法没有去验证，因为低于 6.x 版本的需要客户端 link）</p></li></ul><h5 id="ScrollView-与-Keyboard"><a href="#ScrollView-与-Keyboard" class="headerlink" title="ScrollView 与 Keyboard"></a>ScrollView 与 Keyboard</h5><p>场景： 当 ScrollView / FlatList / SectionList 中包含输入框时，点击输入框唤起键盘。如果此时输入框右侧有清除输入的按钮，点击时首先会将键盘收起，之后再次点击才会执行 onPress。</p><p>方案：将 <code>keyboardShouldPersistTaps</code> 属性设置为 <code>always</code>，点击清除输入的按钮，键盘不会自动收起。</p><h5 id="iOS-Text"><a href="#iOS-Text" class="headerlink" title="iOS Text"></a>iOS Text</h5><p>ios 的 Text 组件 <code>borderRadius</code> | <code>textAlignVertical</code> 属性无效，只能外层再包个 View</p><h5 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h5><p>RN 的盒模型是 border-box, 即 宽高包括了 padding 和 border。</p><p>在开发中发现如果容器具有 backgroundColor 与 borderRadius 后，设置一个不同颜色的 border, 该容器外围会有一层浅浅的 backgroundColor 描边（目前仅 ios 有这种情况）解决方案：在容器外层再包一个 View，设置 border 样式</p><h5 id="FlatList-的-onViewableItemsChanged"><a href="#FlatList-的-onViewableItemsChanged" class="headerlink" title="FlatList 的 onViewableItemsChanged"></a>FlatList 的 onViewableItemsChanged</h5><p>onViewableItemsChanged 的方法在 FlatList 的生命周期中不可以改变，否则报错：</p><pre class="line-numbers language-none"><code class="language-none">Invariant Violation: Changing onViewableItemsChanged on the fly is not supported</code></pre><p>如果是类组件，可以在 constructor 中定义该方法，如果是函数组件，可以通过 useRef 包裹该方法。</p><h5 id="等宽字体"><a href="#等宽字体" class="headerlink" title="等宽字体"></a>等宽字体</h5><p>如果字体不是等宽的话，倒计时组件会产生宽度抖动。ios 和 安卓平台的字体并不通用，参考 <a href="https://github.com/react-native-training/react-native-fonts。">https://github.com/react-native-training/react-native-fonts。</a> 想要设置等宽字体可以设置 Text 如下样式属性：</p><pre class="line-numbers language-none"><code class="language-none">fontVariant: [&#39;tabular-nums&#39;] &#x2F;&#x2F; 仅 IOSfontFamily: Platform.OS &#x3D;&#x3D;&#x3D; &#39;android&#39; ? &#39;monospace&#39; : undefined &#x2F;&#x2F; 如果是安卓则设置字体为 monospace</code></pre><p>注意如果 fontFamily 指定的字体不存在，则页面将报错</p><h5 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h5><p>轮播图一开始用的是社区里 star 数比较高的 <a href="https://github.com/leecade/react-native-swiper/issues/932">https://github.com/leecade/react-native-swiper/issues/932</a> ，</p><p>☠️ 但是这个组件存在一个坑：如果 loop 为 true，rerender 的时候，会先展示最后一项，再闪回到第一项。这个 bug 存在好几年了，提了很多 issue，都没有解决掉，例如 <a href="https://github.com/leecade/react-native-swiper/issues/932">https://github.com/leecade/react-native-swiper/issues/932</a> </p><p>由于项目比较紧张，又没有时间自己去实现一个，后面发现 <a href="https://github.com/f111fei/react-native-banner-carousel">https://github.com/f111fei/react-native-banner-carousel</a> 这个仓库不存在该问题。后续还是需要自己去研究一下 rn 的轮播图实现方案。</p><h5 id="stickyHeaderIndices"><a href="#stickyHeaderIndices" class="headerlink" title="stickyHeaderIndices"></a>stickyHeaderIndices</h5><p>ScrollView 提供 stickyHeaderIndices 可以指定滚动时吸顶的组件索引</p><p>☠️ 这个属性如果是动态的会导致 ScrollView 无法正常渲染，见 // <a href="https://github.com/facebook/react-native/issues/25157">https://github.com/facebook/react-native/issues/25157</a> ，解决的方法是将 removeClippedSubviews 设置成 false </p><h5 id="关闭弹窗与跳转新页面"><a href="#关闭弹窗与跳转新页面" class="headerlink" title="关闭弹窗与跳转新页面"></a>关闭弹窗与跳转新页面</h5><p>在我们的 ios 客户端发现一个问题：点击一个 Modal 中的内容后，关闭该 modal 并打开一个新的 webview，此时有很大概率无法打开新 webview。</p><p>猜测是由于关闭 modal 的动画影响到打开新 webview（不清楚是否 ios 原生就是如此）</p><p>解决方案就是延迟 300ms 后再打开新 webview</p><h4 id="SectionList-scrollToLocation"><a href="#SectionList-scrollToLocation" class="headerlink" title="SectionList scrollToLocation"></a>SectionList scrollToLocation</h4><p>在 stickySectionHeadersEnabled 为 true 的时候，以下代码的作用是滚动到第一个 section 的第一个元素。但是在 ios 和 android 平台表现不一致，ios 会认为 sticky 元素需要占位置，而安卓则不占位，导致安卓下列表会被遮挡。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">sectionListRef.current.scrollToLocation(&#123;  sectionIndex: 0,  itemIndex: 0,&#125;);</code></pre><p>解决方案：根据平台添加 viewOffset 属性，设置滚动偏移量。</p><h4 id="FlatList-性能优化"><a href="#FlatList-性能优化" class="headerlink" title="FlatList 性能优化"></a>FlatList 性能优化</h4><p>RN 的长列表性能一向不太好，即使用了 FlatList 依然要注意性能优化。比如列表项中如果有图片，那么要注意压缩大小等。</p><p>未完待续～</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次搭建 react 项目遇到的坑</title>
      <link href="/2020/07/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%20react%20%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2020/07/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%20react%20%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>电商项目需要搭建一个 h5 项目。这里简单记录一下搭建过程遇到的坑，作为总结。</p><a id="more"></a><p>ui 框架：为了统一 ui 框架，因此选择使用 antd-mobile。<br>打包：parceljs 在此前的项目中已经使用过很多次了，打包速度较 cra 快，且配置简单，因此拟用 parcel。<br>ts：多人项目还是上 ts，没什么好说的。<br>很快就搭建好 demo，接着就开始遇到一些问题。</p><h5 id="antd-mobile-按需加载"><a href="#antd-mobile-按需加载" class="headerlink" title="antd-mobile 按需加载"></a>antd-mobile 按需加载</h5><p>antd-mobile 按需加载推荐使用 <a href="https://github.com/ant-design/babel-plugin-import">babel-plugin-import</a></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; .babelrc or babel-loader option&#123;  &quot;plugins&quot;: [    [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd-mobile&quot;, &quot;style&quot;: &quot;css&quot; &#125;] &#x2F;&#x2F; &#96;style: true&#96; 会加载 less 文件  ]&#125;</code></pre><p>此前 parcel 实际上内置支持了 ts，直接转成 es5 了，因此此前没有额外再配置 babel。<br>🤔 babel-plugin-import 只支持 es6 module 写法的代码，看来需要先把 ts 转成 es6 然后在通过 babel 转成 es5， 没问题，安排～ 于是：</p><ol><li><p>新增 .babelrc</p></li><li><p>修改 tsconfig 的 module 为 <code>es6</code></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;module&quot;: &quot;ES6&quot;  &#125;&#125;</code></pre><p>项目启动，没问题。但是 vscode 开始报错：</p></li></ol><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import React from &#39;react&#39;&#x2F;&#x2F; Module &#39;&quot;&#x2F;node_modules&#x2F;@types&#x2F;react&#x2F;index&quot;&#39; can only be default-imported using the &#39;allowSyntheticDefaultImports&#39; flag</code></pre><p>根本原因是由于 react 导出如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module.exports &#x3D; require(&#39;react.development.js&#39;)</code></pre><p>而非</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module.exports.default &#x3D; require(&#39;react.development.js&#39;)</code></pre><p>Babel 会在 commonjs 格式添加 default 导出，那我们要做的就是让 ts 不要提示这种类型的报错：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;allowSyntheticDefaultImports&quot;: true    &#x2F;&#x2F; ...  &#125;&#125;</code></pre><p>🤔 不过为什么一开始 parcel 不会报错呢？</p><p>接下来路由动态引入组件开始报错：</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import React, &#123; Suspense, lazy &#125; from &#39;react&#39;const List &#x3D; lazy(() &#x3D;&gt; import(&#39;.&#x2F;modules&#x2F;List&#39;))&#x2F;&#x2F; Dynamic imports are only supported when the &#39;--module&#39; flag is set to &#39;es2020&#39;, &#39;esnext&#39;, &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, or &#39;umd&#39;.</code></pre><p>看来 <code>es6</code> 是不支持 import() 语法, 那好办，将 module 改成 <code>esnext</code>：</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;compilerOptions&quot;: &#123;    &quot;module&quot;: &quot;ESNext&quot;,  &#125;&#125;</code></pre><p>接下来引入 anti-mobile 组件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; List &#125; from &#39;antd-mobile&#39;&#x2F;&#x2F; Cannot find module &#39;antd-mobile&#39; or its corresponding type declarations.</code></pre><p>此时提示找不到对应的模块声明， 此时我的内心是崩溃的，看起来应该是模块解析路径不对，因此在 tsconfig 中显式配置 <code>moduleResolution</code>:</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;moduleResolution&quot;: &quot;Node&quot;    &#x2F;&#x2F; ...  &#125;&#125;</code></pre><p>不再报错了，看看 ts 文档的解释吧，ts 共有两种可用的模块解析策略：<a href="https://www.tslang.cn/docs/handbook/module-resolution.html#node">Node</a>和<a href="https://www.tslang.cn/docs/handbook/module-resolution.html#classic">Classic</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module &#x3D;&#x3D;&#x3D; &quot;AMD&quot; or &quot;System&quot; or &quot;ES6&quot; ? &quot;Classic&quot; : &quot;Node&quot;</code></pre><p>🤔 按理说 module 为 esnext 的话岂不是应该按 node 策略解析？但是目前看来似乎不是这样的？</p><h5 id="配置-antd-mobile-主题"><a href="#配置-antd-mobile-主题" class="headerlink" title="配置 antd-mobile 主题"></a>配置 antd-mobile 主题</h5><p>接下来需要配置主题，anti-mobile 推荐使用 <a href="http://lesscss.org/usage/#using-less-in-the-browser-modify-variables">modifyVars</a> 来配置主题。<br>将 .babelrc 改成做一下调整：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;    ...    &quot;plugins&quot;: [        [&quot;import&quot;, &#123;&quot;libraryName&quot;: &quot;antd-mobile&quot;, &quot;style&quot;: true&#125;],        ...    ]&#125;</code></pre><p>按照 webpack 的经验，此时需要开启 <code>javascriptEnabled: true</code>问题来了 parcel 内置支持 less ，那我们要在哪里去配置 less 呢？根据 <a href="https://github.com/parcel-bundler/parcel/issues/907">issue</a> 提到可以用 .lessrc 文件来配置，但是我经过尝试发现其实是无效的。。<br>至此基本放弃 parcel。parcel 在快速搭建实验性项目时确实有一定的优势，不过生态确实不如 webpack，由此转向使用 create-react-app</p><h5 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h5><p>使用 cra 很快也建好 demo，解决如何让 cra 创建的项目支持 less ，这个简单：<br>通过 <code>customize-cra</code> 提供的 <code>addLessLoader</code> 方法即可，同时也提供了 <code>fixBabelImports</code> 可以很方便的添加 babel-plugin-import 配置：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const &#123; override, fixBabelImports, addLessLoader &#125; &#x3D; require(&#39;customize-cra&#39;)module.exports &#x3D; override(  fixBabelImports(&#39;import&#39;, &#123;    libraryName: &#39;antd-mobile&#39;,    style: true,  &#125;),  addLessLoader(&#123;    lessOptions: &#123;      javascriptEnabled: true,      modifyVars: &#123;        &#39;@brand-primary&#39;: &#39;#ff74b9&#39;,        &#39;brand-primary-tap&#39;: &#39;#ff9cca&#39;,      &#125;,    &#125;,  &#125;))</code></pre><h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><p>接着是配置路径别名遇到的问题，通过 <code>customize-cra</code> 提供的 <code>addWebpackAlias</code> 可以配置别名，但是 typescript 一直无法解析对应别名，那么应该只需要配置好 ts 的 paths 就行了吧：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;baseUrl&quot;: &quot;.&quot;,    &quot;paths&quot;: &#123;      &quot;@&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;*&quot;]    &#125;    &#x2F;&#x2F; ...  &#125;&#125;</code></pre><p>vscode 不再报错了,接下来就是见证奇迹的时刻了<code>npm run start</code>：<br>控制台显示 <code>- compilerOptions.paths must not be set (aliased imports are not supported)</code> 并且 cra 会自动把 tscongfig 中的 paths 移除掉 😂<br>根据 <a href="https://github.com/timarney/react-app-rewired/issues/375">issue</a>，使用将 baseUrl 和 paths 的配置移动到单独的文件后，在 tsconfig 里通过 extends 的方式继承，虽然控制台依然提示错误，但是别名可以生效。</p><h5 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h5><p>在 build 时，mini-css-extract-plugin 提示 Conflicting order， 错误位置在 antd-mobile 的样式文件。根据 <a href="https://github.com/ant-design/ant-design/issues/14895">issue</a> 以及 <a href="https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250"> issue </a>看来这个问题主要是由于懒加载加上 antd 组件导入顺序不一致导致的，目前看来无需解决。</p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
